## 8. 泛型与类型擦除 [5]

### 8.1 擦除机制
- 是什么：编译期做类型检查与插入强制转换；运行时参数化类型被擦除成其上界（默认 Object）。  
- 为什么：与旧 JVM 字节码兼容，不需修改运行时。  
- 怎么用：通过 Class<T> 或 Type/ParameterizedType 获取结构；无法直接获得泛型实参运行时类（List<String> 只见到 List）。  
- 关键细节：
  - instanceof 不能含泛型实参：if (list instanceof List<String>) 非法。
  - 运行时 List<String> 与 List<Integer> 的 getClass() 相同。  
  - 桥接方法保证多态（编译器合成）。  
- 常见陷阱：试图反射获取 T 的真实类型；滥用强制转换隐藏类型错误。  
- 面试提示：一句话示例“擦除后容器只保留原始结构，元素类型安全靠编译期”。  
- 案例：某工具库内部反射期望 List<String> 元信息失败，改用 TypeToken 解决。

### 8.2 通配符与 PECS 原则
- 是什么：? extends T（生产者只读） / ? super T（消费者写入）。  
- 为什么：平衡泛型协变/逆变不可用的限制。  
- 怎么用：只读数据源 List<? extends Number>；写入聚合 List<? super Number>。  
- 关键细节：? super 读出退化为 Object；? extends 不允许 add（除 null）。  
- 常见陷阱：误在 ? extends 集合中 add 导致编译错误；? super 读取后错误强转。  
- 面试提示：快速写出：copy(List<? extends T> src, List<? super T> dst)。  
- 案例：实现通用 copy 方法减少重复。

### 8.3 上界与多重约束
- 是什么：<T extends A & B & C> 要求 T 同时具有多个接口能力（类必须放首位且最多一个）。  
- 为什么：算法对能力集合有要求（排序+克隆+序列化）。  
- 怎么用：public <T extends Comparable<T> & Serializable> void sortAndStore(List<T> list)。  
- 关键细节：多重界定后访问受限于交集；避免过度复杂导致理解困难。  
- 常见陷阱：界定链过长暴露实现细节。  
- 面试提示：指出“类在最前+多个接口”。  
- 案例：限制缓存键必须既可序列化又可自然排序。

### 8.4 数组协变 vs 泛型不协变
- 是什么：数组协变（Sub[] → Super[]）；泛型不协变需通配符。  
- 为什么：数组保留运行时类型信息能抛出 ArrayStoreException；泛型擦除无法安全协变。  
- 怎么用：避免创建参数化类型数组：List<String>[] → 使用 List<?>[] 或 List<List<String>>。  
- 关键细节：new T[] 不允许；@SuppressWarnings("unchecked") 仅在无法避免时局部使用。  
- 常见陷阱：使用参数化数组导致堆污染。  
- 面试提示：给出“Object[] arr= new String[1]; arr[0]=Integer”抛异常示例。  
- 案例：重构框架内部 T[] 缓冲改用 List<T> 减少警告。

### 8.5 桥接方法 (Bridge Method)
- 是什么：编译器生成合成方法维持泛型与擦除后签名一致。  
- 为什么：保证多态：子类重写返回更具体类型仍能被父类引用正确调用。  
- 怎么用：理解反射时 isSynthetic() 过滤。  
- 关键细节：影响 AOP/反射扫描（需跳过）。  
- 常见陷阱：统计方法数出现重复。  
- 面试提示：举例 Comparator<String>#compare 与原始类型兼容。  
- 案例：反射框架过滤 synthetic 方法避免重复注册。

### 8.6 设计原则
- 是什么：保持泛型 API 简洁、类型安全、意图明确。  
- 为什么：过度嵌套降低可读与可维护性。  
- 怎么用：拆分复杂 Map<String, List<Map<K,V>>> → 定义值对象；对外暴露窄泛型。  
- 关键细节：倾向具体类型返回；通配符用于入参增加适配性。  
- 常见陷阱：统一使用通配符导致调用方推断困难。  
- 面试提示：说明“返回具体，接收泛化”策略。  
- 案例：简化分页 API：Page<T> 而非 Map<String,Object>。

### 8.7 TypeToken 与反射泛型信息
- 是什么：通过匿名子类捕获泛型参数（Guava TypeToken / 自定义）。  
- 为什么：运行时获取 List<String> 中 String 类型信息用于序列化、转换。  
- 怎么用：new TypeToken<List<String>>(){} 获取 ParameterizedType。  
- 关键细节：只能在创建时立即捕获；需缓存避免重复解析。  
- 常见陷阱：在非匿名子类或擦除路径中失去信息。  
- 面试提示：说明“绕过擦除以获取实际类型参数”。  
- 案例：JSON 反序列化泛型集合使用 TypeToken 精确还原元素类型。

### 8.8 泛型类型推断与菱形语法
- 是什么：<> 让编译器推断构造时实参类型（List<String> list = new ArrayList<>();）。  
- 为什么：减少冗余。  
- 怎么用：在复杂嵌套结构中使用菱形语法提升可读。  
- 关键细节：类型推断基于赋值目标；过度推断可能退化为 Object。  
- 常见陷阱：返回值推断不佳导致原始类型警告。  
- 面试提示：指出“菱形语法仅在 Java 7+”。  
- 案例：Map<String,List<Integer>> m = new HashMap<>(); 清晰。

### 8.9 通配符捕获 (Capture Conversion)
- 是什么：编译器在内部为 ? 创建隐式类型变量以支持安全操作。  
- 为什么：允许在方法内部转换 List<?> → List<T> 受控使用。  
- 怎么用：私有辅助方法 <T> void process(List<T> list) 接受 List<?> 调用。  
- 关键细节：调用者仍保持 ? 协议安全。  
- 常见陷阱：试图直接强转 (List<String>) list<?>。  
- 面试提示：说明捕获转换帮助局部泛化。  
- 案例：validate(List<?> l) 内部使用辅助泛型方法消除警告。

### 8.10 堆污染与 @SafeVarargs
- 是什么：泛型类型不一致引用写入不安全数据。  
- 为什么：导致后续读取 ClassCastException。  
- 怎么用：避免参数化数组；使用不可变集合；在 final / static / private 可变参数泛型方法上加 @SafeVarargs。  
- 关键细节：@SafeVarargs 仅声明“方法内部不执行不安全操作”。  
- 常见陷阱：错误标注 @SafeVarargs 掩盖真实风险。  
- 面试提示：解释“为什么泛型 varargs 会有警告”。  
- 案例：combine(List<String>... lists) 误加入 List<Integer> 产生隐藏问题。

### 8.11 原始类型 (Raw Type) 风险
- 是什么：未参数化使用泛型类，如 List raw = new ArrayList();。  
- 为什么：绕过类型检查引入运行时失败。  
- 怎么用：始终加参数；迁移旧代码逐步泛型化。  
- 关键细节：原始类型与擦除后不同（编译器施加 unchecked 警告）。  
- 常见陷阱：公共 API 暴露 Raw Type 导致传播。  
- 面试提示：说明“Raw Type = 放弃泛型安全”。  
- 案例：旧工具方法返回 raw Map 在调用层出现强转异常。

### 8.12 泛型与性能 / JIT
- 是什么：泛型仅编译期存在，不增加运行时对象；类型转换仍需在边界执行。  
- 为什么：性能影响主要在额外的强制转换与无法特化原始类型（不存在 List<int>)。  
- 怎么用：对性能敏感的数值集合可使用 Trove/FastUtil（特化）或原始数组。  
- 关键细节：装箱/拆箱成本高于泛型本身；JIT 可消除部分边界转换。  
- 常见陷阱：将性能问题归因于“使用泛型”而非装箱。  
- 面试提示：强调“泛型本身开销可忽略，关注装箱与分配”。  
- 案例：改 List<Long> 计数为 LongAdder 提升吞吐。

### 8.13 典型问答速记
| 问题 | 速答 |
| ---- | ---- |
| 为何需要擦除 | 与旧 JVM 兼容，减少运行时复杂性 |
| 如何获取泛型实参 | 使用 Type/ParameterizedType 或 TypeToken 捕获 |
| PECS 原则含义 | 生产者 extends 只读，消费者 super 可写 |
| 泛型数组为何危险 | 运行时类型信息丢失导致堆污染风险 |
| 桥接方法作用 | 保持泛型重写后多态一致性 |
| @SafeVarargs 使用条件 | final/static/private 泛型可变参且内部安全 |
| Raw Type 风险 | 跳过编译期检查导致运行时 ClassCastException |
| 不能写入 ? extends 集合原因 | 类型不确定，写入破坏类型安全 |
| 泛型性能问题本质 | 装箱与转换，而非泛型语法本身 |

### 8.14 答题骨架示例（“解释 PECS 原则并举例”）
1. 是什么：协变与逆变在 Java 泛型不可直接表达，通过通配符分离读/写。  
2. 为什么：保证类型安全又提升灵活性。  
3. 示例：copy(List<? extends T> src, List<? super T> dst)。  
4. 关键：? extends 禁止写入（无法证明安全），? super 读取退化 Object。  
5. 陷阱：在 ? extends 集合 add 导致编译错误；误强转 ? super 读取类型。  
6. 案例：通用集合复制与归并 API。

### 8.15 最佳实践清单
- 返回值尽量使用具体类型（List<User>），入参可用通配符增加兼容（Collection<? extends User>）。  
- 避免 Raw Type；出现 unchecked 警告先审查再有选择 @SuppressWarnings。  
- 避免参数化类型数组；若必须使用，限制作用域并说明理由。  
- 泛型工具方法加入合理上界（<T extends Comparable<? super T>> 排序）。  
- 缓存反射得到的 Type 元信息（避免重复解析）。  
- 利用 TypeToken 捕获复杂嵌套类型用于序列化/转换。  
- 可变参数泛型方法审查堆污染后标注 @SafeVarargs。  
- 不滥用通配符造成阅读困难；保持 API 简明单一职责。  
- 文档中明确泛型参数含义（T = 元素类型、K/V = 键值）。  
