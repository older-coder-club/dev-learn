
## 5. 序列化与 JSON 生态 [3]

### 5.1 Java 原生序列化问题
- 是什么：基于对象图快照（ObjectOutputStream/ObjectInputStream），通过类名+serialVersionUID 编码字段。
- 为什么：性能低（反射+写冗余元数据）、安全风险（Gadget 链执行任意代码）、演进困难（字段/类结构变化易失效）。
- 怎么用：避免用于远程调用/跨服务数据存储；仅在同进程短期缓存可控场景且确保白名单时考虑；优先选择 JSON / ProtoBuf / Avro / Kryo。
- 关键细节：serialVersionUID 不匹配抛 InvalidClassException；transient 字段不序列化；writeReplace/readResolve 可修改过程；深对象图可能递归、栈与内存膨胀。
- 常见陷阱：未显式声明 serialVersionUID；通过默认反序列化处理不可信输入；序列化包含敏感字段（密码）。
- 面试提示：列举三个缺点：性能差 / 安全差 / 演进差；给替代方案与迁移策略。
- 案例：将 Session Java 序列化改为 JSON + Gzip，CPU 降 40%，跨版本兼容问题消失。
- 速记：原生序列化 = 慢 + 不安全 + 不易演进；能不用就不用。

### 5.2 Externalizable vs Serializable
- 是什么：Externalizable 由类自行实现 readExternal/writeExternal；Serializable 自动按字段。
- 为什么：精确控制序列化字段、顺序、版本兼容与性能。
- 怎么用：实现 Externalizable 并提供无参构造；在 writeExternal 中按顺序写基础类型/字符串；在 readExternal 中严格按同顺序读取。
- 关键细节：顺序不一致直接数据错位；必须处理 IO 异常；可跳过不再需要的旧字段以实现自定义演进；性能优于默认反射路径。
- 常见陷阱：忘记无参构造导致反序列化失败；新增字段未处理旧版本兼容；写入对象未进行 null 判定。
- 面试提示：说明何时选 Externalizable（性能敏感 + 精确版本控制）。
- 案例：将高频传输对象改 Externalizable，反序列化耗时从 120µs 降至 35µs。
- 速记：手写读写换性能与灵活度；顺序必须匹配。

### 5.3 JSON 框架对比
- 是什么：Jackson（功能全面 + Streaming + 注解丰富），Gson（简单轻量）、Fastjson（性能好但历史有安全 CVE）。
- 为什么：选型需兼顾性能、可维护性、安全、生态。
- 怎么用：统一配置单例 ObjectMapper（禁 FAIL_ON_UNKNOWN_PROPERTIES；注册模块：JavaTimeModule；设置日期格式）；Streaming API 处理超大 JSON。
- 关键细节：ObjectMapper 重建成本高；Afterburner 模块可减少反射；开启 @JsonIgnoreProperties 控制兼容；默认多态 (@JsonTypeInfo use=Id.CLASS) 禁止用于不可信输入。
- 常见陷阱：频繁新建 ObjectMapper 引起 GC 和配置不一致；开启默认多态导致反序列化 RCE；深度过大未限制导致内存膨胀。
- 面试提示：强调复用 Mapper + 安全禁多态 + 限制深度。
- 案例：统一 Mapper 后 GC 次数减少 15%，平均延迟降低 8%。
- 速记：Jackson 首选；Mapper 复用；禁默认多态。

### 5.4 多态与类型信息
- 是什么：反序列化时还原子类类型（type 字段 / @JsonTypeInfo / 自定义反射注册）。
- 为什么：集合或接口字段需恢复多种具体实现。
- 怎么用：自定义安全白名单（手动映射 type→Class）；显式写枚举/字符串标识而非类全名。
- 关键细节：直接使用 CLASS/OBJECT 类型信息带来任意类加载与执行风险；需限制允许反序列化的包或类型集合；向后兼容时新增类型需同步白名单。
- 常见陷阱：使用默认 @JsonTypeInfo(use=Id.CLASS) 暴露类路径；忽略未知 type 导致失败或安全绕过；没有版本字段导致旧客户端无法识别新子类。
- 面试提示：多态 = 安全白名单 + 显式 type 字段。
- 案例：迁移默认多态到枚举白名单，消除审计警告。
- 速记：多态需白名单；拒绝 CLASS 反射自动。

### 5.5 兼容与演进
- 是什么：在不同版本中保持数据格式可解析与语义正确（向后/向前兼容）。
- 为什么：微服务异步升级；缓存持久化可能存储旧版本数据。
- 怎么用：新增字段提供默认值；避免重命名（改为新增 + 弃用注释）；多阶段移除（弃用标记 → 双写 → 删除）；利用 wrapper 加 version 字段分支处理。
- 关键细节：字段删除需保留读取逻辑临时兼容；枚举新增值旧客户端处理方式（默认 fallback）；避免强耦合顺序字段（JSON 使用键值更稳）。
- 常见陷阱：直接删除字段导致旧数据反序列化异常；重命名字段无迁移策略；缺少版本号无法区分旧格式。
- 面试提示：描述“新增字段默认值 + 版本号分支 + 双阶段删除”流程。
- 案例：引入 version 后成功跨 3 版本平滑升级无缓存失效。
- 速记：加字段安全；删字段分阶段；版本号必备。

### 5.6 性能优化
- 是什么：降低序列化 CPU、内存与延迟。
- 为什么：高 QPS 接口（JSON 编解码占用 20~40% CPU）。
- 怎么用：Streaming 解析大数组；关闭冗余特性(INDENT_OUTPUT)；预热缓存序列化器；紧凑字段名（非外部协议时）；启用 Afterburner。
- 关键细节：深度递归对象需拆分；Large String 避免重复构造；可用二进制协议（ProtoBuf/Avro）压缩尺寸与延迟。
- 常见陷阱：为调试开启 pretty 导致流量增加；频繁创建临时对象 (DateFormat)；未使用缓存导致重复反射。
- 面试提示：给基准：优化前后 QPS / p99 延迟。
- 案例：Streaming 处理 2MB JSON 降低峰值内存 45%。
- 速记：复用 Mapper + Streaming 大对象 + 减少反射。

### 5.7 安全防护
- 是什么：防止反序列化导致远程代码执行、资源耗尽、内存膨胀。
- 为什么：外部输入不可信；历史多 CVE。
- 怎么用：限制最大深度、集合大小、字符串长度；禁默认类型推断；使用白名单；校验数字范围；异常/拒绝日志。
- 关键细节：黑名单不可靠（绕过）；需集中配置安全策略；及时升级安全漏洞版本；记录被拒计数做监控。
- 常见陷阱：无深度/大小限制；解析异常吞掉不记录；允许动态类加载。
- 面试提示：强调白名单 + 限制 + 升级。
- 案例：引入限制后恶意 payload 执行时间从秒级降为快速拒绝毫秒级。
- 速记：白名单+限深度+监控拒绝。

### 5.8 二进制协议选择 (ProtoBuf / Avro / Kryo)
- 是什么：紧凑高效二进制序列化（ProtoBuf：IDL + tag；Avro：Schema 演进；Kryo：高性能对象图）。
- 为什么：节省带宽 + 降延迟 + 明确 schema 管理。
- 怎么用：定义 .proto / Avro schema；生成类；集中版本控制；Kryo 注册类 ID 提升性能。
- 关键细节：ProtoBuf 字段号稳定不可复用；Avro 读写器协商 schema；Kryo 需固定注册顺序避免跨版本错位。
- 常见陷阱：乱改字段号；未跟踪 schema 演进；Kryo 默认反射安全风险。
- 面试提示：对比 JSON: 可读性 vs 性能体积。
- 案例：JSON→ProtoBuf 报文尺寸减 55%，CPU -30%。
- 速记：ProtoBuf: tag 稳定；Avro: 动态 schema；Kryo: 注册性能。

### 5.9 压缩与分层
- 是什么：序列化后再压缩（Gzip/LZ4/Zstd）降低传输体积。
- 为什么：大对象网络成本高；节省带宽。
- 怎么用：判断平均与 p95 大小阈值；选择 LZ4/Zstd 平衡速度；小对象跳过压缩。
- 关键细节：压缩小数据反增延迟；Gzip CPU 高；需添加原始长度字段。
- 常见陷阱：对所有消息统一压缩；无缓存导致大量分配。
- 面试提示：展示压缩收益阈值策略。
- 案例：仅对 >4KB JSON 启用 Zstd 总体 CPU 持平吞吐提升。
- 速记：按阈值压缩；快算法优先。

### 5.10 对象图与循环引用
- 是什么：对象间相互引用形成图；序列化需处理重复与循环。
- 为什么：避免无限递归与重复写大量冗余数据。
- 怎么用：JSON 中显式打断（DTO 扁平化）；二进制协议避免双向结构或使用引用标记；分层装配。
- 关键细节：Hibernate 懒加载字段序列化风险；双向关系需 @JsonIgnore 或 DTO。
- 常见陷阱：直接序列化 JPA 实体出现栈溢出或性能灾难。
- 面试提示：说明“API 层使用独立 DTO”。
- 案例：双向实体改 DTO 后响应时间稳定。
- 速记：DTO 扁平化；禁止直接实体对象图。

### 5.11 测试与校验清单
| 项 | 检查点 |
|----|--------|
| 兼容 | 新老版本互反序列化成功 |
| 性能 | 基准 QPS / p99 / GC |
| 安全 | 超深 / 超长 / 未知类型拒绝 |
| 内存 | 峰值使用监控 |
| 精度 | 数值/日期格式正确 |
| 默认值 | 新字段空值解析正确 |

### 5.12 快速对比表
| 方案 | 可读性 | 体积 | 性能 | 演进 | 安全风险 |
|------|--------|------|------|------|---------|
| Java 序列化 | 差 | 大 | 低 | 差 | 高 |
| JSON (Jackson) | 高 | 中 | 中 | 好 | 中 |
| ProtoBuf | 低 | 小 | 高 | 好 | 低 |
| Avro | 低 | 小 | 高 | 优 (Schema) | 低 |
| Kryo | 低 | 小 | 高 | 中 (需管理注册) | 中 |

### 5.13 面试速答汇总
| 问题 | 速答 |
| ---- | ---- |
| 原生序列化为何弃用 | 慢 不安全 不易演进 |
| Externalizable 用途 | 自定义读写与版本控制 |
| ObjectMapper 复用原因 | 避免反射初始化与配置分散 |
| 多态安全策略 | 白名单 + 禁 CLASS |
| 演进删除字段策略 | 双阶段：弃用→清理 |
| JSON 性能优化手段 | Streaming + Afterburner + 复用 |
| Gadget 攻击成因 | 反序列化执行链触发任意代码 |
| ProtoBuf 字段注意 | tag 不可复用 更改仅新增 |
| 循环引用处理 | DTO 扁平化/忽略双向字段 |
| 何时压缩 | 大于阈值时启用 快算法优先 |

### 5.14 答题模板示例（“如何设计安全的 JSON 反序列化”）
1. 是什么：对不可信输入解析 → 对象。  
2. 为什么：防止内存膨胀与 gadget RCE。  
3. 怎么用：单例 Mapper + 禁默认多态 + 限制深度/集合大小 + 白名单类型。  
4. 关键细节：失败记录拒绝计数；升级安全补丁；Streaming 大对象。  
5. 陷阱：多次构造 Mapper、启用 CLASS 多态、无限深度。  
6. 案例：上线限制后攻击 payload 秒级→毫秒拒绝。  
7. 速记：单例+白名单+限深度+日志监控。

### 5.15 最佳实践速记
- 禁原生序列化（除封闭短期内存场景）。  
- 统一单例配置 ObjectMapper。  
- 禁默认 CLASS 多态；用枚举或 type 字段 + 白名单。  
- 新字段默认值 + 版本号分阶演进。  
- Streaming 解析超大 JSON；基准验证优化。  
- 限制深度/集合大小/字符串长度。  
- 大消息按阈值选择压缩算法。  
- DTO 解耦持久层实体，避免循环与懒加载陷阱。  
- 定期安全升级与审计拒绝指标。  