## 10. 语言新特性[3]

### 10.1. Record（Java 16+）
- 是什么：不可变数据载体语法糖，自动生成构造器、equals/hashCode/toString、组件访问器。
- 为什么：减少样板，鼓励值对象语义，提升可读性。
- 怎么用：record User(Long id, String name) {}；在 compact constructor 内加入校验。
- 关键细节：字段隐式 final；可定义静态成员与实例方法；不能继承其他类（隐式 extends Object）；可实现接口。
- 常见陷阱：在 equals/hashCode 中再手写逻辑重复；将可变集合作为组件未做 defensive copy。
- 面试提示：强调“领域值对象 + 不变性”。
- 案例：DTO 类 120 行 → Record 12 行。
- 速记：Record = 精简不可变数据容器。

### 10.2. Sealed Classes（Java 17）
- 是什么：通过 permits 限定允许的子类集合。
- 为什么：穷举模式匹配更安全；限制扩展面。
- 怎么用：sealed interface Shape permits Circle, Rectangle {}
- 关键细节：子类必须是 final / sealed / non-sealed；模块/包可见性影响封闭性；与模式匹配 switch 协同简化分支。
- 常见陷阱：忘记给子类声明 final/sealed/non-sealed 导致编译出错；跨包扩展受限。
- 面试提示：说明“可控继承层次 + 模式匹配优化”。
- 案例：支付状态枚举扩展迁移到 sealed 层次，避免被外部添加非法子类。
- 速记：Sealed = 受控扩展集合。

### 10.3. Pattern Matching for instanceof / switch（Java 16+ / 21）
- 是什么：instanceof 自动绑定变量；switch 支持类型/模式匹配（含守护条件）。
- 为什么：减少显式强转与冗长分支；提高可读性。
- 怎么用：if (obj instanceof User u) { u.name(); }；switch (shape) { case Circle c -> ... ; case Rectangle r -> ... }
- 关键细节：匹配顺序自上而下；封闭层次（sealed）可启用穷举检查；guard (when) 提升表达力。
- 常见陷阱：重复模式导致不可达；在 switch 中遗漏 default 导致编译警告（非穷举）。
- 面试提示：突出“减少样板 + 增强穷举保障”。
- 案例：旧 instanceof 链 30 行 → 模式 switch 12 行。
- 速记：Pattern Matching = 自动绑定 + 穷举安全。

### 10.4. Switch Expressions（Java 14）
- 是什么：switch 作为表达式返回值；箭头语法减少 fall-through。
- 为什么：消除样板 break；更函数化。
- 怎么用：int score = switch(level) { case HIGH -> 100; case LOW -> 10; default -> 50; };
- 关键细节：多个标签逗号分隔；yield 用于代码块内返回值；表达式分支不可隐式贯穿。
- 常见陷阱：误认为箭头允许隐式共享状态；忽略 default。
- 面试提示：说明“更安全不再意外贯穿”。
- 案例：枚举映射优化。
- 速记：新 switch = 值表达 + 安全标签。

### 10.5. Text Blocks（Java 15）
- 是什么：""" 多行字符串，提高可读性（SQL/JSON）。
- 为什么：减少转义与拼接。
- 怎么用：String sql = """SELECT * FROM user WHERE id = ?""";
- 关键细节：自动去除公共缩进；末尾换行处理规则；仍需参数化防注入。
- 常见陷阱：缩进误差导致不期望空格；直接拼接用户输入。
- 面试提示：强调“维护成本降 + 安全仍需校验”。
- 案例：SQL 片段行数减少与错误率下降。
- 速记：""" 优化多行字面量。

### 10.6. Virtual Threads（Java 21 LTS / Project Loom）
- 是什么：用户模式轻量线程，调度由 JVM 管理，阻塞调用不占 OS 线程长期资源。
- 为什么：降低并发编程复杂度（保留同步风格）同时扩展到大量并发（百万级）。
- 怎么用：Thread.startVirtualThread(() -> handler()); Executors.newVirtualThreadPerTaskExecutor()
- 关键细节：阻塞 I/O 自动挂起；不适合长期占用 CPU 紧循环；ThreadLocal 行为需关注（频繁创建）；栈深回收与调度策略仍需度量。
- 常见陷阱：期望 CPU 密集加速（瓶颈仍在核心数）；忽略同步结构竞争；过度依赖 ThreadLocal 增成本。
- 面试提示：回答“区别于传统线程：调度+栈在堆分片可切换”。
- 案例：从 500 线程池迁移虚拟线程 → 并发连接提升 20x，代码保持阻塞风格。
- 速记：虚拟线程 = 轻阻塞并发。

### 10.7. Structured Concurrency（Java 21 Incubator）
- 是什么：对并发任务形成结构化生命周期（类似作用域），统一取消与聚合异常。
- 为什么：避免“分叉后遗忘”线程/任务；资源与错误集中管理。
- 怎么用：try (var scope = new StructuredTaskScope.ShutdownOnFailure()) { scope.fork(...); scope.join(); scope.throwIfFailed(); }
- 关键细节：不同策略 Scope（ShutdownOnFailure / ShutdownOnSuccess）；join 等待所有；聚合异常简化处理。
- 常见陷阱：混用自定义线程池与 scope 导致取消不一致。
- 面试提示：说明“结构化=可见边界 + 统一错误处理”。
- 案例：并发远程聚合改造减少孤儿任务。
- 速记：Structured = 任务生命周期显式。

### 10.8. Scoped Values（Java 21 Preview）
- 是什么：线程栈上下文替代部分 ThreadLocal 场景，更轻量可安全传递。
- 为什么：减少不可控 ThreadLocal 泄漏与复杂清理。
- 怎么用：ScopedValue.runWhere(SOME_KEY, value, () -> logic());
- 关键细节：只读语义；嵌套覆盖；虚拟线程适配良好。
- 常见陷阱：尝试存可变共享对象并修改；当成写缓存。
- 面试提示：对比 ThreadLocal：无显式 remove，生命周期作用域清晰。
- 案例：请求上下文迁移减少清理代码。
- 速记：Scoped = 受控上下文只读。

### 10.9. Foreign Function & Memory API（Java 22+ / Panama）
- 是什么：安全访问本地内存与调用 native 函数替代 JNI（MemorySegment, Linker）。
- 为什么：降低 JNI 样板与开销；高性能与安全边界。
- 怎么用：MemorySegment.allocateNative(...); Linker.link(…).
- 关键细节：生命周期/作用域控制（Arena）；内存布局（ValueLayout）；安全检查可启用/禁用。
- 常见陷阱：错误作用域释放后仍访问；未对齐布局。
- 面试提示：强调“性能 + 安全比 JNI 更可维护”。
- 案例：解析二进制协议使用本地内存减少复制。
- 速记：FFM = 现代化安全替代 JNI。


### 10.10. LTS 演进对比速查
| 版本 | 主要语言/语法特性 | 价值 |
| ---- | ---------------- | ---- |
| 8 | Lambda, Stream, Optional | 行为参数化 |
| 11 | var 局部推断(10+), 新 HttpClient | 减样板 / 标准化客户端 |
| 17 | Sealed, Pattern Matching instanceof, Records, Text Blocks | 不变值对象 + 模式增强 |
| 21 | Virtual Threads, Structured Concurrency, Pattern Matching Switch | 轻量并发 + 安全穷举 |

### 10.11 面试高频速答
| 问题 | 速答 |
| ---- | ---- |
| Record vs Lombok | 原生语义 + 自动 equals/hashCode，无需注解处理器 |
| Sealed 好处 | 限制继承集合，模式匹配可穷举 |
| 虚拟线程优势 | 阻塞风格保留，极大提升并发数量 |
| Structured Concurrency 解决什么 | 避免孤儿任务，集中错误与取消 |
| Scoped Value 对比 ThreadLocal | 受限作用域只读，无手动清理 |
| Pattern Matching switch 何时安全省略 default | 在 sealed 完全穷举子类时 |
| Foreign Memory API 替代 JNI 好处 | 更少样板 + 安全检查 + 性能 |

### 10.12. 答题骨架示例（“虚拟线程与线程池差异”）
1. 是什么：JVM 管理调度的超轻量线程（百万级）。  
2. 为什么：阻塞 I/O 不再占用昂贵平台线程，简化异步回调。  
3. 怎么用：newVirtualThreadPerTaskExecutor / Thread.startVirtualThread。  
4. 关键细节：ThreadLocal 使用成本；CPU 密集仍受核心限制；阻塞点可安全挂起。  
5. 陷阱：误将其用于忙循环；滥用 ThreadLocal。  
6. 案例：连接数扩展 20x。  

### 10.13. 最佳实践清单
- 使用 Record 表达纯数据，不加入复杂可变逻辑。
- Sealed + switch 模式组合实现穷举业务状态。
- 并发场景优先评估虚拟线程替代复杂回调。
- Scoped Value 替代易泄漏 ThreadLocal 场景。
- Pattern Matching 提升类型分发清晰度，避免 instanceof 链。
- 充分验证预览/孵化特性在生产启用前的稳定性与兼容性。
- Text Blocks 用于多行常量，仍保持参数化防注入。
- FFM API 替代 JNI 时明确生命周期与对齐策略。
- 度量虚拟线程迁移收益（吞吐、阻塞栈分布）而非盲目替换。