## 7. 字符串与编码处理 [4]

### 7.1 String 不可变性
- 是什么：java.lang.String 为 final；内部 value（JDK 9 起为 byte[]）与 coder 均 final，不提供原地修改方法。  
- 为什么：
  - 线程安全共享：不可变对象多线程读无需同步。
  - 安全性：防止 URL、文件路径、类名等被篡改（ClassLoader、反射场景）。
  - 缓存优化：hashCode 计算后缓存（字段 hash），重复使用 O(1) 获取。
  - 结构稳定：作为 Map/Set key 时值不变，避免哈希不一致。  
- 怎么用：直接共享 String；在构造安全敏感对象时复制外部可变源（如 char[] → new String()）。  
- 关键细节：
  - new String(char[]) 会拷贝数组（防止后续数组被修改）。
  - 与 StringBuilder 不同（后者可变）。
  - equals 比较逐字符；intern 可复用同 literal 引用。  
- 常见陷阱：
  - 过度创建 new String("abc") 无意义（与字面量相同）。
  - 误将 StringBuilder 暴露为字段造成逃逸修改风险。  
- 面试提示：说明“不可变性 = 并发安全 + 作为集合键稳定 + hash 缓存提升频繁查找性能”。
- 案例：缓存层以 URL 作为 key，使用 String 避免后续被外部修改导致缓存命中率下降。

### 7.2 存储与 Compact Strings（JDK 9）
- 是什么：JDK 9 以后 value 由 char[] 改为 byte[] + coder（0=LATIN1, 1=UTF16）。  
- 为什么：大量业务字符串为 ASCII/LATIN1（英文、数字）可减半内存；提升缓存命中率与减少 GC 压力。  
- 怎么用：开发者无需改代码，JVM 自动判定编码。  
- 关键细节：
  - coder 决定解码路径；LATIN1 单字节，UTF16 双字节。
  - 影响：String.length() 在 LATIN1 下仍返回代码单元数（同原语义）。
  - substring（JDK 7+）复制新数组，避免“共享大父数组”导致内存泄漏。  
- 常见陷阱：
  - 误以为可通过手工 API 强制 LATIN1；这是内部实现细节不可控。
  - 忽略多语言内容混用导致判断为 UTF16 内存仍较大。  
- 面试提示：说明 Compact Strings 降低对堆与 GC 的压力，适用于大量英文标识场景。
- 案例：电商日志字段（orderId、userId）迁移至 JDK 11 后堆使用下降 ~8%。

### 7.3 拼接与性能
- 是什么：字符串拼接存在编译期与运行期差异：常量折叠 vs 动态构建。  
- 为什么：String 不可变，频繁 + 生成大量中间对象增加 GC。  
- 怎么用：
  - 循环内使用 StringBuilder / StringBuffer（线程安全但慢）；
  - Java 15+：使用 Text Blocks（"""）改善多行可读性；
  - 大规模构建：预估容量 new StringBuilder(expectedLength)。  
- 关键细节：
  - 编译器将 a + b + c 优化为单个 StringBuilder（非循环）。
  - 日志框架使用占位符减少无谓拼接：logger.info("id={} name={}", id, name)。
  - format() 可读性高但性能差（格式解析）。  
- 常见陷阱：
  - 在日志级别关闭时仍进行字符串拼接（缺少 isDebugEnabled 判断或使用参数化日志）。
  - 大循环内 String += 触发多次扩容与复制。  
- 面试提示：说明“循环中使用 + 导致指数级对象创建”并给具体优化对比。
- 案例：某批处理将 1e6 行 CSV 构造改为 StringBuilder 预分配，GC 次数从 12 次降到 2 次。

### 7.4 字符串常量池与 intern
- 是什么：JVM 维护字符串常量池（字面量与第一次调用 intern() 的结果）。  
- 为什么：避免重复常量对象；提升比较通过引用（==）判定的可能性（慎用）。  
- 怎么用：
  - 仅对少量高度重复值（枚举名称、状态码）调用 intern。
  - 避免对大量动态内容（如用户输入）intern。  
- 关键细节：
  - JDK 7 起常量池转入堆，不再受 PermGen 限制但仍可能导致堆膨胀。
  - intern 返回池内引用，若未存在则添加。
  - 不推荐用 == 比较业务字符串。  
- 常见陷阱：
  - 滥用 intern 导致内存不可回收热点膨胀。
  - 在缓存场景通过 intern 期望获得 Map 减少 equals 成本收益微弱。  
- 面试提示：说明 intern 是空间换引用复用的特定场景工具而非通用性能优化。
- 案例：将支付状态码（<50 种）intern 后节省重复对象但未显著影响整体性能（展示理性评估）。

### 7.5 编码与 Charset 管理
- 是什么：字符→字节转换需显式 charset；默认平台编码不可靠。  
- 为什么：
  - 避免跨平台（Windows GBK vs Linux UTF-8）出现乱码。
  - 网络协议、消息传输需统一编码保障一致性。  
- 怎么用：
  - 始终使用 StandardCharsets.UTF_8；
  - new String(bytes, StandardCharsets.UTF_8)；
  - Files.newBufferedReader(path, UTF_8)。  
- 关键细节：
  - 不要省略 charset 参数（默认编码可变）；
  - BOM（UTF-8 BOM）可能影响某些解析器；
  - InputStreamReader 默认平台编码。  
- 常见陷阱：
  - JSON/CSV 读写未指定编码，线上与测试环境不一致；
  - 使用 String.getBytes() 无参导致潜在不可预测字节序列。  
- 面试提示：举一个“测试环境 UTF-8 → 生产 GBK 导致消息解析失败”的案例。
- 案例：接口签名校验使用 bytes 不同编码导致签名不一致，修复方式：强制 UTF-8。

### 7.6 Unicode、代码点与代理对 (Surrogate Pair)
- 是什么：Java 内部使用 UTF-16 代码单元；部分字符（emoji、罕见汉字）占两个 char（代理对）。  
- 为什么：处理长度、截取、展示时需基于代码点避免截断非法。  
- 怎么用：
  - str.codePointCount(0, str.length());
  - 遍历：str.offsetByCodePoints(index, 1)；
  - 正确截取：使用 BreakIterator 或基于 codePoint API。  
- 关键细节：
  - charAt 返回单个代码单元，可能不是完整字符；
  - emoji 长度显示与代码点数量不同；
  - 盲目 substring 可能截断代理对产生乱码。  
- 常见陷阱：
  - length() 作为“字符数”用于限制昵称长度不准确；
  - UI 截断导致显示“残缺方框”。  
- 面试提示：说明对“字符”与“代码点”区分与业务长度校验正确方式。
- 案例：昵称限制 10 “字符”实际使用 length 导致允许 10 个代理对（20 code units）→ 风险：过长展示溢出。

### 7.7 Locale、大小写与正规化
- 是什么：不同语言存在大小写与排序差异（例：土耳其语 I ↔ ı）。  
- 为什么：错误 Locale 导致认证、搜索、比较失败。  
- 怎么用：
  - toLowerCase(Locale.ROOT) 用于稳定逻辑（标识规范化）；
  - Collator 排序；Normalizer 进行 Unicode 规范化（NFC/NFD）。  
- 关键细节：
  - 默认 Locale 随系统；不适合用于协议/标识转换；
  - 正规化避免组合字符差异（é vs e + ´）。  
- 常见陷阱：
  - 使用默认 toLowerCase 导致跨区行为差异；
  - 未正规化造成缓存键不一致。  
- 面试提示：举例“土耳其语用户登录失败”场景说明 Locale 重要性。
- 案例：国际站对产品 SKU 进行 lowerCase 未指定 Locale 导致少数地区异常。

### 7.8 安全与边界处理
- 是什么：字符串输入需防止注入与资源耗尽（超长、异常编码）。  
- 为什么：避免 SQL/LDAP/命令注入；防止超长 payload 造成内存压力。  
- 怎么用：
  - 长度限制 + 白名单字符（正则）；
  - 参数化语句避免拼接；
  - 验证编码后再入库。  
- 关键细节：
  - 正则需预编译避免重复编译；
  - 过滤后保持失败原因透明（返回统一错误码）。  
- 常见陷阱：
  - 直接拼接 SQL："... where name = '" + userInput + "'"；
  - 未限制上传文件名长度造成日志污染。  
- 面试提示：描述“统一输入校验 → 安全基线”的策略。
- 案例：过滤日志中控制字符防止终端逃逸攻击。

### 7.9 性能度量与工具
- 是什么：针对字符串操作热点使用基准验证真实开销。  
- 为什么：避免凭感觉优化或过度设计。  
- 怎么用：
  - JMH：基线对比 + vs StringBuilder；
  - Java Flight Recorder：识别高频分配；
  - Allocation profiling：async-profiler 观察分配火焰图。  
- 关键细节：
  - 预热迭代确保 JIT 优化生效；
  - 分离不同长度、不同字符集场景。  
- 常见陷阱：
  - 忽略逃逸分析使得优化判断失真；
  - 在未隔离 GC 噪声条件下测量。  
- 面试提示：强调“以基准数据证明优化有效”，展示量化能力。
- 案例：JMH 测试 1e5 次拼接：String += 耗时 320ms → StringBuilder 90ms。

### 7.10 高频问答速记
| 问题 | 速答 |
| ---- | ---- |
| String 为什么不可变 | 并发安全 + 安全性 + hash 缓存 + 作为 Map key 稳定 |
| JDK9 改成 byte[] 意义 | 降低 ASCII / LATIN1 场景内存占用 |
| intern 适用场景 | 少量高频重复字面值；避免动态海量值 |
| length() 与真实字符数差异 | 遇代理对（emoji）length() > codePointCount |
| 编码必须显式指定原因 | 默认编码不可靠导致跨平台乱码与签名失败 |
| 循环中 + 低效原因 | 产生多余中间对象与扩容复制 |
| Locale.ROOT 用途 | 稳定大小写规范化避免地区差异 |

### 7.11 面试答题骨架示例（“如何优化大量字符串拼接”）
1. 是什么：循环内频繁 String += 构建大文本。  
2. 问题：不可变导致多次分配与复制，GC 压力增大。  
3. 优化：使用单个 StringBuilder 预估容量；日志参数化；必要时使用 char[] 聚合。  
4. 数据：基准对比前后耗时与分配次数。  
5. 风险：过度 micro-optimization；维护复杂度提升。  
6. 收益：延迟下降 X%、GC 次数减少 Y%。  