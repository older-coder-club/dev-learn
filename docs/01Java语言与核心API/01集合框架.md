
## 1. 集合框架与数据结构 [5]

### 1.1 集合体系与设计哲学
是什么：接口层次（Collection、List、Set、Queue、Map）+ 具体实现按访问/顺序/并发/内存取舍。  
为什么：统一 API 降低替换成本；不同结构在查找、插入、遍历、并发、空间上表现不同。  
怎么用：根据主操作+约束选型：  
- 随机访问多→ArrayList  
- 去重无序→HashSet  
- 有序/范围→TreeMap/TreeSet/ConcurrentSkipListMap  
- 频繁头尾→ArrayDeque  
- 多线程读写→ConcurrentHashMap  
- 读远多写少→CopyOnWriteArrayList  
关键细节：fail-fast 迭代器依赖 modCount；List.of 真不可变 vs Collections.unmodifiableXXX 仅包装；迭代修改用 Iterator.remove；对外返回集合做 defensive copy。  
常见陷阱：过度使用 LinkedList（定位 O(n) + 额外指针）；忽略初始容量导致频繁扩容；误把包装视图当不可变；遍历时结构修改抛异常。  
面试提示：快速画“操作→结构”矩阵并说明选型理由与替代方案。  
案例：将热点用户权限校验 List.contains 改为 HashSet.contains，平均耗时由 2ms 降至 30µs。  
速记：默认 ArrayList/HashMap；特殊需求再换；迭代期间修改用迭代器。

### 1.2 ArrayList vs LinkedList
是什么：ArrayList 动态数组；LinkedList 双向链表。  
为什么：数组连续内存提升缓存命中；链表仅在已定位节点附近插入删除才具优势。  
怎么用：通用选择 ArrayList；栈/队列优先 ArrayDeque；极少场景需 LinkedList。  
关键细节：ArrayList 扩容因子约 1.5；扩容复制 O(n)；LinkedList 节点多对象增加 GC；迭代无法预取；中间插入实际需遍历 O(n)。  
常见陷阱：误认为“中间插入 O(1)”忽略定位；使用 LinkedList 做随机访问退化；大量节点造成内存碎片。  
面试提示：指出链表理论优势与实际定位成本差距。  
案例：将 LinkedList 替换为 ArrayList 后 GC 次数下降 25%。  
速记：几乎全部用 ArrayList；链表优势基本无法被充分利用。

### 1.3 HashMap 内部结构与演进
是什么：数组桶 + 链表 / 红黑树（链≥8 且容量≥64 时树化）。  
为什么：常态 O(1) 查找；树化避免极端碰撞退化 O(n)。  
怎么用：预估初始容量 (元素数/负载因子)；良好 hashCode/equals；批量构建一次性 putAll。  
关键细节：默认负载因子 0.75；resize 触发点 size > cap * loadFactor；扰动函数减少低位碰撞；树化与反树化阈值（链<6 可能回退）。  
常见陷阱：未重写 equals/hashCode 导致重复键；大量低质量 hash 造成长链；高负载因子追求省内存导致碰撞上升。  
面试提示：树化条件 + 为何不是默认树（空间与维护开销折中）。  
案例：调优初始容量减少 4 次扩容，接口冷启动缩短 120ms。  
速记：估容量、防碰撞、理解树化阈值。

### 1.4 ConcurrentHashMap
是什么：并发哈希表（CAS + 局部 synchronized + 红黑树），替代旧分段锁。  
为什么：降低锁粒度提升吞吐；并发扩容协同迁移。  
怎么用：复合逻辑用 compute/merge/putIfAbsent；计数场景搭配 LongAdder；只读快照可用普通 HashMap 安全发布。  
关键细节：size() 近似值；扩容时线程协作迁移；树化逻辑与 HashMap 一致；键/值不可为 null。  
常见陷阱：外层再加 synchronized；依赖 size 精确控制；复合操作分两步导致竞态。  
面试提示：解释为什么组合操作用内置方法而不是手写双检。  
案例：用 merge 替换 get+put 减少锁竞争 TPS 提升 18%。  
速记：内部原子方法保证一致；不要额外大锁。

### 1.5 CopyOnWrite 家族
是什么：写时复制新数组，读用旧快照。  
为什么：读多写极少场景提供无锁稳定迭代。  
怎么用：订阅者列表、配置快照、白名单集合。  
关键细节：写操作 O(n) + 短暂双倍内存；迭代不见最新写入；大集合写频上升会放大 GC。  
常见陷阱：用于高频写集合；期望实时读到最新数据；大对象元素导致复制成本高。  
面试提示：强调“读多写少”量化标准（如写占比 <1%）。  
案例：监听器集合从 synchronizedList 换 CopyOnWriteArrayList，平均响应延迟降 40%。  
速记：读快照写复制；高频写禁用。

### 1.6 阻塞队列与并发队列
是什么：生产者消费者协调 + 背压；不同实现满足容量/顺序/延迟需求。  
为什么：平衡速率差异、隔离峰值、控制内存。  
怎么用：  
- ArrayBlockingQueue：固定容量低延迟  
- LinkedBlockingQueue：通用中等吞吐  
- SynchronousQueue：零缓冲直接交接（cachedThreadPool）  
- DelayQueue：延迟任务  
- PriorityBlockingQueue：按优先级出队（无严格稳定排序）  
关键细节：SynchronousQueue 没有容量；LinkedBlockingQueue 两锁减少冲突；容量过大掩盖消费瓶颈；PriorityBlockingQueue 比较器需稳定。  
常见陷阱：无限容量队列导致内存膨胀；优先级队列使用可变对象更新后顺序错误；不关注剩余容量监控。  
面试提示：描述“背压 = 队列容量 + 拒绝策略 + 监控”三要素。  
案例：线程池队列从无界改为定长+拒绝策略后避免 OOM。  
速记：定长可控；零容量交接；延迟与优先级专用。

### 1.7 跳表与有序视图 (ConcurrentSkipListMap)
是什么：随机多层索引结构并发有序 Map。  
为什么：避免 TreeMap 全局锁；提供近似 O(log n) 范围查询。  
怎么用：排行榜、时间窗口裁剪、按前缀/区间扫描。  
关键细节：空间换时间；极端退化概率低；迭代有序但操作成本高于 HashMap；并发下弱一致视图（遍历中可能看到插入）。  
常见陷阱：误用做高频随机访问（哈希更优）；忽略内存消耗；范围操作未界限截止导致长时间遍历。  
面试提示：强调“有序 + 并发 + 范围查询”结合场景。  
案例：使用跳表替换全量排序列表，区间检索延迟由 90ms 降 8ms。  
速记：并发有序区间友好；随机访问别用。

### 1.8 不可变集合与 Defensive Copy
是什么：不可变集合（创建后状态固定）与防御性复制（避免外部篡改内部结构）。  
为什么：并发安全、缓存稳定、降低状态复杂度。  
怎么用：配置数据 List.of / Map.of；构造时复制传入集合；返回内部集合时 copy 或 unmodifiable 包装。  
关键细节：unmodifiableXXX 仍共享底层；深度结构需递归复制；序列化时注意包装对象行为；值对象搭配不可变集合更安全。  
常见陷阱：只做浅复制；误认为包装即防修改（底层仍能改）；在性能热点大量复制未衡量成本。  
面试提示：回答模式：不可变=线程安全+缓存；defensive copy 保封装。  
案例：订单聚合对象改为不可变后并发读 QPS 提升 25% 无需额外锁。  
速记：返回副本；内部不泄漏；浅复制不够。

---

### 1.x 补充：选型速览与复杂度
| 操作/结构 | ArrayList | LinkedList | HashMap | TreeMap | ConcurrentHashMap | SkipListMap | CopyOnWriteList |
|-----------|----------|-----------|--------|--------|------------------|-------------|----------------|
| 随机访问 | O(1) | O(n) | Key O(1) | Key O(log n) | Key 近似 O(1) | Key O(log n) | O(1) (读快照) |
| 插入尾部 | Amortized O(1) | O(1) 已定位 | - | - | - | - | 写 O(n) |
| 中间插入 | O(n) | O(1) 已定位 | - | - | - | - | 写 O(n) |
| 有序视图 | 否 | 否 | 否 | 是 | 否 | 是 | 否 |
| 并发支持 | 需外部同步 | 需外部同步 | 需外部同步 | 需外部同步 | 是 | 是 | 读无锁 |
速记：90% 场景 = ArrayList + HashMap + ConcurrentHashMap + ArrayDeque。

### 1.x 容量规划公式
ArrayList 初始容量 ≈ 预估元素数  
HashMap 初始容量 ≈ 预估元素数 / 0.75  
ConcurrentHashMap 估容量同 HashMap（过大浪费，过小扩容抖动）