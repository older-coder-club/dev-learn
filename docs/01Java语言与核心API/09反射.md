## 9. 反射与注解机制 [4]

### 9.1 ClassLoader 体系与双亲委派
是什么：层次（Bootstrap→Platform→App→自定义）；双亲委派保证核心类一致与安全。  
为什么：版本隔离/插件/安全。  
怎么用：自定义 URLClassLoader 或模块 Layer；ServiceLoader 依赖 Thread Context ClassLoader；热卸载需丢引用+关闭 Loader 资源。  
关键细节：不同 Loader 同名类不兼容；线程上下文影响 SPI；资源 & Jar 句柄需关闭；模块强封装影响反射。  
陷阱：Class.forName 用错 Loader；静态缓存持自定义 Loader 泄漏；不调用父委派。  
面试提示：举“线程上下文 + SPI”与一次泄漏案例。  
速记：隔离=自定义 Loader；SPI=ContextLoader；泄漏=静态持引用。

### 9.2 模块系统与反射安全迁移 (Java 8→17)
是什么：Java 9+ 模块封装限制深反射；需要最小开放。  
为什么：减少内部依赖面，提升安全与可维护性。  
怎么用：清点反射访问 → 使用公开 API 或 MethodHandle → 必需时 --add-opens 精确到包。  
关键细节：--add-opens（运行期深反射） vs --add-exports（编译+访问）；弃用 --illegal-access；jdeps 识别非法依赖。  
陷阱：一刀切 ALL-UNNAMED；环境不一致导致线上 IllegalAccessException。  
面试提示：列迁移步骤四步（扫描→分类→替换→最小开放）。  
速记：扫描→替换→精确 opens；禁止大范围。

### 9.3 反射使用与性能优化
是什么：运行期结构访问 (Class/Field/Method)。  
为什么：框架通用化；但频繁反射阻碍 JIT 内联。  
怎么用：启动期批量扫描+缓存；字段访问用 MethodHandle / VarHandle；构造器句柄预热。  
关键细节：setAccessible 在强封装受限；InvocationTargetException 需 unwrap；canAccess 替代旧 API；缓存避免重复查找。  
陷阱：热路径每次 getDeclaredXxx；吞 cause；广域扫描慢。  
面试提示：给启动优化数字（扫描缓存缩短启动 x%）。  
速记：一次扫描缓存；句柄替反射；保 cause。

### 9.4 MethodHandle / VarHandle / invokedynamic / LambdaMetaFactory
是什么：低层可优化调用与变量访问抽象；Lambda 通过 invokedynamic 引导。  
为什么：比反射更易 JIT 内联，支持细粒度内存语义。  
怎么用：lookup.findVirtual/findStatic/findConstructor；VarHandle 获取字段并选择语义（acquire/release/opaque/volatile）；LambdaMetaFactory 自定义动态接口实现。  
关键细节：invokeExact 签名严格；组合器 filter/dropArguments；acquire+release 半栅栏；opaque 最弱仅可见性；减少匿名类。  
陷阱：未缓存 lookup；用 invoke 失签名校验；误把 volatile 当唯一选择。  
面试提示：强调“性能与可组合”对比反射。  
速记：缓存句柄；精确语义；lambda = invokedynamic。

### 9.5 动态代理技术栈对比与自调用陷阱
是什么：JDK Proxy(接口) / CGLIB(继承) / ByteBuddy(DSL) / ASM(底层)。  
为什么：实现横切（事务、缓存、限流、监控）。  
怎么用：场景→接口用 JDK；需类增强用 CGLIB/ByteBuddy；性能敏感+复杂结构用 ASM。  
关键细节：final 类/方法无法 CGLIB；代理链顺序影响语义；自调用绕过代理切面。  
陷阱：吞异常静默失败；过度多层代理栈深；原始对象混用。  
面试提示：解释自调用失效与解决（拆分或注入自身代理）。  
速记：接口→Proxy；类→CGLIB/ByteBuddy；自调用风险。

### 9.6 Java Agent 与 Instrumentation
是什么：premain/agentmain 在类加载前后修改字节码。  
为什么：非侵入监控、性能探针、减少运行时反射。  
怎么用：MANIFEST + Premain-Class；Instrumentation.addTransformer + ASM/ByteBuddy。  
关键细节：transform 必须轻量；redefine vs retransform；避免阻塞 I/O。  
陷阱：长耗时 transform 拖慢启动；无过滤处理全部类。  
面试提示：Agent 优于运行时反射（一次织入）。  
速记：启动织入；轻量 transform；过滤类。

### 9.7 代码生成：ASM vs ByteBuddy
是什么：ASM 底层指令级；ByteBuddy 高层 DSL。  
为什么：权衡开发效率 vs 性能与灵活度。  
怎么用：高频模式/简单增强→ByteBuddy；极致调优或特殊字节码结构→ASM。  
关键细节：ByteBuddy 可回落 ASM；验证栈帧；缓存生成类。  
陷阮：未缓存导致重复生成；手写 ASM 容易栈错误。  
面试提示：说明选择依据（复杂度+性能）。  
速记：默认 ByteBuddy；极限 ASM。

### 9.8 注解模型与元注解
是什么：结构化元数据；@Retention/@Target/@Inherited/@Repeatable。  
为什么：提升配置自描述与工具能力。  
怎么用：RUNTIME 用于框架处理；SOURCE 用于代码生成；Repeatable 通过容器注解。  
关键细节：@Inherited 仅类；default 值类型受限；合成注解需解析。  
陷阱：忘 Retention 导致运行时不可见；滥用 RUNTIME 增扫描成本。  
面试提示：列自定义注解最小示例并解释 Retention。  
速记：Retention=生命周期；Inherited 仅类。

### 9.9 编译期注解处理 (APT) 与运行时扫描优化
是什么：JSR 269 编译期处理生成代码替代运行时反射；运行时扫描需控制范围。  
为什么：减少启动与反射开销；早失败。  
怎么用：AbstractProcessor + Filer 生成源；限定基础包 + 预索引(Jandex/Spring AOT)。  
关键细节：多轮处理；增量编译声明；Native Image 需配置反射元数据。  
陷阱：无包限制全盘扫描；代码生成包名错误。  
面试提示：对比“扫描注解 vs 预生成访问器”。  
速记：能编译期就编译期；扫描限包+索引。

### 9.10 反射安全与最小权限
是什么：限制深反射绕过封装与敏感访问。  
为什么：减少攻击面与版本升级破坏。  
怎么用：白名单类型/包；最小 --add-opens；拒绝外部任意类名反射。  
关键细节：Class.forName 参数校验；禁止泛滥 setAccessible；模块封装。  
陷阱：默认开放 ALL-UNNAMED；反序列化类名执行构造。  
面试提示：白名单 + 最小开放策略。  
速记：白名单+精确 opens+拒绝外来类名。

### 9.11 内存与 Metaspace 泄漏 + 插件卸载
是什么：动态类与 ClassLoader 未卸载导致 Metaspace 增长。  
为什么：长期运行系统可能 OOM。  
怎么用：jcmd VM.class_histogram / JFR Class Load；插件独立 Loader + 关闭线程/资源；移除静态引用。  
关键细节：ClassLoader 存活=类存活；线程池/ThreadLocal 持引用常见源头。  
陷阱：静态缓存 Map<Class<?>,Meta> 永久持有；未关闭 URLClassLoader。  
面试提示：三步：采集→定位→清理。  
速记：Histogram 定位；清理引用；卸载资源。

### 9.12 高频反射替换模式
| 场景 | 传统 | 优化 | 备注 |
|------|------|------|------|
| Bean 属性复制 | 反射 Field | MethodHandle/生成访问类 | 减调用开销 |
| JSON 序列化 | 反射遍历 | 预生成访问器 | 启动加速 |
| AOP 调用链 | Method.invoke | MethodHandle switch | 高频路径 |
| 配置绑定 | 深度反射 | 编译期绑定器 | 减分配 |
| 事件总线 | 反射查找处理器 | 预编译路由表 | O(1) 分发 |

速记：高频预生成；低频保留反射。

### 9.13 基准与度量策略
是什么：用 JMH / JFR / async-profiler 量化优化收益。  
怎么用：分离句柄查找与调用；预热充分；输出调用次数/吞吐/分配。  
关键细节：避免把 lookup 放测量循环；关注 p95/p99。  
陷阱：一次跑得出结论；混合基准不隔离变量。  
速记：JMH 分层；缓存句柄；看 p99。

### 9.14 面试速答汇总
| 问题 | 速答 |
| ---- | ---- |
| 双亲委派意义 | 防篡改 + 类型一致性 + 安全 |
| MethodHandle 优势 | 可内联 + 低反射开销 |
| VarHandle 语义选项 | acquire/release/opaque/volatile 按需屏障 |
| 自调用事务失效 | 直接调用未走代理链 |
| 模块迁移关键 | 最小 --add-opens + jdeps 清单 |
| APT 价值 | 早失败 + 减运行时扫描 |
| Metaspace 泄漏排查 | Histogram → 找 Loader 引用 → 清理 |
| 安全策略核心 | 白名单类型 + 最小开放包 |

### 9.15 答题骨架示例（“如何优化反射热点”）
1. 识别：JFR/火焰图定位频繁 Method.invoke。  
2. 替换：启动缓存 MethodHandle / 代码生成访问器。  
3. 度量：JMH 基准（反射 vs 句柄）吞吐提升。  
4. 安全：减少 setAccessible；迁移模块最小开放。  
5. 回退：低频路径保留反射简化实现。  
6. 输出：数字+示例（QPS + p99 改善）。  
速记：找热点→句柄/生成→基准验证→最小开放。

### 9.16 最佳实践清单
- 扫描限包；能编译期生成不运行时遍历。  
- 启动阶段统一缓存 MethodHandle/VarHandle。  
- 高频反射替换为生成类或句柄；低频保持简单。  
- 模块迁移逐项收缩 --add-opens。  
- 监控 Metaspace 与类加载速率；定期泄漏审计。  
- 插件卸载：线程池/定时任务/静态集合全部清理。  
- 安全：拒绝外部类名直接反射；白名单策略。  
- 基准：所有优化需数据支撑（JMH + JFR）。 