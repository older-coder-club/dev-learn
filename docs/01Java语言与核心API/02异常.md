## 2. 异常体系与最佳实践 [4]

### 2.1 Checked vs Unchecked 异常分层
- 是什么：Checked（需声明/捕获，如 IOException）、Unchecked（RuntimeException 及其子类）。  
- 为什么：区分“可恢复 vs 编程错误/前置条件失败”，提高 API 语义清晰度。  
- 怎么用：外部资源/环境问题 → Checked；参数校验/逻辑缺陷 → Unchecked。领域层可使用自定义 RuntimeException 精简调用。  
- 关键细节：过度 Checked 污染调用链；异常翻译需保留 cause；公共库慎抛具体实现细节异常（泄漏底层）。  
- 常见陷阱：全部声明 throws Exception；层层捕获重复 log；忽略 cause 导致排障困难。  
- 面试提示：说明“可恢复性”判断标准 + 领域异常包装。  
- 案例：将多处 IOException → DataAccessException(Runtime) 简化上层调用 30 行 try/catch。  
- 速记：Checked=外部可恢复；Unchecked=编程/前置条件；只翻译不吞 cause。

### 2.2 异常传播与语义保留
- 是什么：重新抛出或包装保持原始堆栈与上下文。  
- 为什么：定位根因需要完整链；避免信息丢失。  
- 怎么用：catch -> 仅一次 log（边界）-> throw new DomainException("描述", e); 添加关键业务标识（ID）。  
- 关键细节：重复 log=日志风暴；保持原始消息可辅助底层排查；统一异常层次（BaseException）。  
- 常见陷阱：多层 log 同一堆栈；丢 cause；吞异常返回 null。  
- 面试提示：强调“只在系统边界 log 一次”原则。  
- 案例：减少重复 log 后单次故障日志量下降 70%。  
- 速记：边界一次 log；保 cause；附业务上下文。

### 2.3 性能与误用
- 是什么：异常构造抓栈昂贵；频发异常使路径退化。  
- 为什么：异常路径少数运行；热循环抛异常显著影响吞吐。  
- 怎么用：预检查输入格式；可预见失败用 Optional/Result；解析前先 fast‑fail 校验。  
- 关键细节：大批量解析不要用异常判定结束；日志级别按严重度；避免控制流 via Exception。  
- 常见陷阱：for 循环用 try/catch+异常终止；批量校验靠异常；吞异常静默失败。  
- 面试提示：给“异常控制流 vs 预检查”性能对比。  
- 案例：JSON 解析改预校验异常数从万级降为个位。  
- 速记：异常=稀有路径；热循环先校验不用异常。

### 2.4 try-with-resources 与 Suppressed
- 是什么：自动关闭 AutoCloseable 资源；suppressed 保存关闭阶段次要异常。  
- 为什么：减少漏关与异常丢失；逆序释放。  
- 怎么用：try (A a=...; B b=...) { ... } catch(Exception e){ log(e); for(var s: e.getSuppressed()) log(s); }  
- 关键细节：关闭顺序逆序；不要重复 finally close；主异常优先。  
- 常见陷阱：混用手动关闭；忽略 suppressed 导致次异常缺失；资源未实现 AutoCloseable。  
- 面试提示：解释 suppressed 出现场景（主执行异常+关闭异常）。  
- 案例：数据库连接与语句自动关闭避免泄漏。  
- 速记：自动逆序关；suppressed 记次异常；不再写冗长 finally。

### 2.5 InterruptedException 处理
- 是什么：中断标志用于协作取消（非硬杀）。  
- 为什么：及时停止阻塞/长任务释放资源。  
- 怎么用：catch 后 Thread.currentThread().interrupt() 恢复标志或向上抛；循环检测 Thread.interrupted()。  
- 关键细节：阻塞方法抛出后清除标志；恢复中断避免“吞掉”信号；不要空 catch。  
- 常见陷阱：吞中断继续执行；用 Boolean 标志替代中断；既清除又不恢复。  
- 面试提示：说明“清除 vs 恢复”区别与正确模式。  
- 案例：修复吞中断导致线程无法停止问题。  
- 速记：捕获→恢复或上抛；不吞；循环检测。

### 2.6 自定义异常设计
- 是什么：域层/应用层定义语义明确异常层次：BaseAppException -> ValidationException / ConflictException / NotFoundException。  
- 为什么：精确分类便于统一处理与转换为 HTTP/错误码。  
- 怎么用：抽象基类携带错误码、可序列化上下文；公共异常工厂构建。  
- 关键细节：避免过度层级；错误码集中常量；消息面向运维非用户。  
- 常见陷阱：滥用泛型 Exception；错误码散落。  
- 面试提示：展示“异常分类 → 通用处理器”。  
- 案例：统一异常映射减少重复 if instanceof。  
- 速记：分层少而精；集中错误码；语义清晰。

### 2.7 异常 vs 返回值
- 是什么：失败表达：异常（意外） vs 返回值 (Optional/Result)（常态缺失）。  
- 为什么：区分控制流成本与语义。  
- 怎么用：预期频繁出现的“未找到” -> Optional；违反前置条件 -> IllegalArgumentException。  
- 关键细节：Optional 不做字段；Result 封装错误码+消息；避免异常滥用性能热点。  
- 常见陷阱：大量“找不到”抛异常；Result 与异常混乱。  
- 面试提示：给判断规则：频率高→返回值，罕见→异常。  
- 案例：缓存 miss 改 Optional 减少异常数。  
- 速记：常态缺失用返回值；异常留给意外。

### 2.8 常见陷阱清单
| 场景 | 陷阱 | 风险 | 规避 |
| ---- | ---- | ---- | ---- |
| 层层捕获再 log | 重复日志 | 噪音难定位 | 边界一次 log |
| 抛 Exception | 类型不清 | 调用方不知处理策略 | 精细化分层 |
| 吞 InterruptedException | 线程不停止 | 资源耗尽 | 恢复标志或上抛 |
| 用异常做循环结束 | 高成本 | 性能急降 | 预判条件 |
| 忽略 suppressed | 丢次异常 | 排障缺信息 | 输出 getSuppressed |
| 不保留 cause | 根因消失 | 排查困难 | 包装时传入 cause |
| 返回 null 代替异常 | 语义不明 | NPE 或静默失败 | Optional/Result |
| 重复包装不同层异常 | 嵌套复杂 | 可读性差 | 最少一次翻译 |

### 2.9 面试速答（抽取要点）
| 问题 | 速答 |
| ---- | ---- |
| Checked 用途 | 外部可恢复条件 |
| Unchecked 用途 | 编程错误/不变量破坏 |
| 为什么不多层 log | 造成日志风暴难定位 |
| InterruptedException 正确处理 | 恢复中断或向上抛出，不吞 |
| try-with-resources 优势 | 自动逆序关闭+保留 suppressed |
| 何时用 Optional 而非异常 | 预计频繁“缺失”非异常态 |
| 异常翻译原则 | 语义提升+保留 cause |
| 性能关注点 | 热路径不靠异常控制流 |

### 2.10 答题模板示例（“如何设计异常体系”）
1. 是什么：领域+技术分层异常（Validation/Conflict/NotFound/Infra）。  
2. 为什么：统一处理策略与精确响应码。  
3. 怎么用：基类携错误码；DAO IOException → DataAccessException；service 抛 DomainException。  
4. 关键细节：一次 log；保 cause；区分常态缺失。  
5. 常见陷阱：抛 Exception；吞中断；重复包装。  
6. 案例：引入分层后全局异常处理器减少 40% 重复 if。  
7. 速记：语义分层+保 cause+边界 log+缺失用返回值。

### 2.11 最佳实践速记清单
- 边界一次 log；内部只抛不重复打印。  
- 未找到常态用 Optional；异常限意外。  
- 保留 cause；自定义异常含错误码与上下文。  
- 捕获 InterruptedException 必恢复标志。  
- try-with-resources 覆盖所有 Closeable。  
- 避免在高频循环中抛异常作为分支。  
- 提前校验参数防止后置 NPE/IllegalState。  
- 输出 suppressed 辅助排查关闭链路。  