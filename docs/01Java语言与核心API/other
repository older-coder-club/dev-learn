## 12. 数值与精度 (BigDecimal) [3]

### 12.1 精度与构造
是什么：BigDecimal 提供任意精度十进制。  
为什么：避免二进制浮点误差在金额场景。  
怎么用：BigDecimal.valueOf(double) 或字符串构造；避免 new BigDecimal(double)。  
关键细节：scale 与 value 区分；equals 考虑 scale。  
面试提示：展示误差例子 (new BigDecimal(0.1))。

### 12.2 舍入与 scale
是什么：RoundingMode 控制除法/格式化行为。  
为什么：财务计算规范要求；不同模式对结果影响显著。  
怎么用：setScale(scale, RoundingMode.HALF_UP)；统一常量。  
关键细节：compareTo 忽略 scale；HALF_EVEN 减少统计偏差。  
面试提示：说明选择 HALF_EVEN 的原因。

### 12.3 性能
是什么：高精度运算创建大量对象。  
为什么：热点路径需优化减少分配。  
怎么用：缓存常量；提前乘除；使用原始 long 表示分转换。  
关键细节：作为 Map key 性能差；注意 equals/scale。  
面试提示：给转化为“分”存储提升性能案例。

---

## 13. 对象与不可变设计 [4]

### 13.1 不可变好处
是什么：状态固定对象。  
为什么：降低并发复杂度；缓存与哈希稳定。  
怎么用：字段 final + 无 setter；构造完成即有效。  
关键细节：内部数组 defensive copy；确保深层不可变。  
面试提示：举值对象示例（Money、UserId）。

### 13.2 Defensive Copy
是什么：复制输入或输出防止外部篡改内部状态。  
为什么：保护封装与线程安全。  
怎么用：Collections.unmodifiableList + copy；返回新对象。  
关键细节：Date、数组等引用类型风险高。  
面试提示：说明未复制导致的真实 Bug。

### 13.3 equals/hashCode 合约
是什么：相等对象必须同 hash；hash 不必唯一。  
为什么：影响 HashMap/HashSet 正常工作。  
怎么用：基于不可变字段实现；重写时保持对称传递性。  
关键细节：浮点 NaN；BigDecimal equals 与 compareTo 差异。  
面试提示：描述错误实现导致元素丢失案例。

---

## 14. 设计与 API 可用性 [2]

### 14.1 语义清晰
是什么：命名与参数表达业务意图。  
为什么：提高可维护性减少误用。  
怎么用：方法名使用动词 + 领域对象；避免 boolean flag 抽象成策略对象。  
关键细节：重载导致歧义；拒绝“doProcess”泛化。  
面试提示：讲一次重构命名改善理解。

### 14.2 参数验证
是什么：前置条件校验保护方法不被非法参数调用。  
为什么：失败快速暴露错误而非静默失败。  
怎么用：Objects.requireNonNull / Preconditions；抛出合理异常。  
关键细节：避免晚期 NullPointer；区分 IllegalArgument vs IllegalState。  
面试提示：强调前置校验+清晰异常提高排障效率。

---

## 15. 资源管理与 AutoCloseable [3]

### 15.1 try-with-resources
是什么：编译器生成自动关闭语句的结构。  
为什么：避免资源泄漏与重复模板。  
怎么用：多个资源分号分隔；只针对实现 AutoCloseable。  
关键细节：关闭顺序逆序；异常抑制 suppressed。  
面试提示：对比手动 finally 漏关风险。

### 15.2 Cleaner 取代 finalize
是什么：Cleaner 提供更可控的回收回调替代 finalize。  
为什么：finalize 不确定性与性能差。  
怎么用：注册清理逻辑释放 native 资源。  
关键细节：仍非实时；优先显式关闭。  
面试提示：说明弃用 finalize 的原因。

---

## 16. 内存与对象模型基础 [3]

### 16.1 对象头
是什么：Mark Word（锁状态、哈希、年龄）+ Klass Pointer；压缩指针减少空间。  
为什么：理解锁升级与监控工具输出。  
怎么用：排查锁竞争、对象哈希分布。  
关键细节：偏向锁 → 轻量级 → 重量级升级；sync 竞争路径。  
面试提示：解释锁状态转换。

### 16.2 对齐与填充
是什么：对象按 8 字节对齐；字段可能填充。  
为什么：提高访问性能但浪费少量空间。  
怎么用：结构紧凑字段排序（大类型靠前可减少填充）。  
关键细节：@Contended 避免伪共享；过度填充浪费。  
面试提示：说明伪共享与填充关系。

### 16.3 装箱与缓存
是什么：基本类型包装对象与缓存范围（Integer[-128,127]）。  
为什么：频繁装箱产生垃圾与性能退化。  
怎么用：使用原始类型或 LongAdder；避免在热路径频繁自动装箱。  
关键细节： == 比较包装对象需谨慎；拆箱 NPE 风险。  
面试提示：展示装箱热点对 GC 的影响。
