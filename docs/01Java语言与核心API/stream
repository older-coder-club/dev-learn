### 4.1 Lambda 与闭包
- 是什么：以简洁语法表达行为单元；捕获外部“有效 final”变量形成闭包。  
- 为什么：减少样板，提升可读性与抽象级别。  
- 怎么用：集合变换 map/filter；策略替换；简化匿名内部类。  
- 关键细节：捕获外部对象延长生命周期；避免在热路径频繁装箱/分配。  
- 面试提示：指出合理使用与避免复杂多层嵌套。

### 4.2 流式管道惰性
- 是什么：中间操作构建描述，终止操作触发整体执行。  
- 为什么：可进行短路优化（anyMatch）、融合、延迟开销。  
- 怎么用：链式 map/filter/collect；短路匹配大型集合减少遍历。  
- 关键细节：有状态操作（sorted/distinct）需缓存中间数据；多次终止操作需重新创建流；避免滥用复杂链影响调试。  
- 面试提示：解释“distinct 大数据集内存膨胀”原因。

### 4.3 并行流陷阱
- 是什么：使用公共 ForkJoinPool 并行拆分任务。  
- 为什么：不当使用导致线程池污染、阻塞传播、性能退化。  
- 怎么用：仅在纯 CPU 密集、数据量较大且操作无共享状态时启用；或自定义 ForkJoinPool。  
- 关键细节：阻塞操作会占用池线程；拆分不均匀导致负载倾斜；装箱/同步结构影响收益。  
- 面试提示：列举“并行流在 IO 密集场景变慢”例子。

### 4.4 Collector 与自定义聚合
- 是什么：收集器定义供应器、累加器、组合器，支持并行安全聚合。  
- 为什么：扩展 reduce 类能力实现复杂分组与统计。  
- 怎么用：groupingBy、partitioningBy、mapping、reducing；自定义 Collector.of(...)。  
- 关键细节：组合器需无副作用；toMap 需提供合并函数避免键冲突异常。  
- 面试提示：说明自定义 collector 并行下注意事项。

### 4.5 Spliterator
- 是什么：可拆分迭代器提供特征 (SIZED/SORTED/CONCURRENT) 影响并行策略。  
- 为什么：提升并行划分效率；避免不均衡工作。  
- 怎么用：实现 trySplit 控制粒度；用于非集合数据源。  
- 关键细节：特征标志影响优化（ORDERED 保留顺序成本）。  
- 面试提示：说明为什么不正确 trySplit 导致性能差。

### 4.6 Optional 使用规范
- 是什么：表示可能为空的值的显式容器。  
- 为什么：提升语义与减少 NullPointer。  
- 怎么用：链式 map/flatMap/filter/orElseThrow；避免 get()。  
- 关键细节：不用于集合元素与字段（序列化成本与冗余）；orElse 与 orElseGet 区别（前者总执行参数）。  
- 面试提示：强调合理用法与限制。