### 9.1 ClassLoader 体系与双亲委派
- 是什么：类加载过程（加载→验证→准备→解析→初始化）；层次：Bootstrap(核心) → Platform(旧 Extension) → Application(System) → 自定义（URLClassLoader、模块 Layer）；双亲委派：优先向上委派避免核心类被篡改。  
- 为什么：隔离不同模块版本；支持插件与热替换；安全（防止伪造 java.lang.*）。  
- 怎么用：
  - 自定义：继承 URLClassLoader 或使用 ModuleLayer 定义模块隔离；
  - SPI：ServiceLoader 依赖 Thread Context ClassLoader 查找 META-INF/services；
  - 热加载：专用 Loader + 丢弃引用以便 GC。  
- 关键细节：
  - 同名类由不同 ClassLoader 加载 ⇒ 类型不兼容 (ClassCastException)；
  - 内存泄漏：Web/App 容器中静态缓存持有自定义 Loader 导致卸载失败；
  - ContextClassLoader：框架（JDBC、JAXP、ServiceLoader）在回调线程中查找应用类；
  - getResource 与 getResourceAsStream 依加载器搜索范围；
  - 模块系统强封装，需 --add-opens 打开包给反射。  
- 常见陷阱：
  - 直接使用 Class.forName 而非线程上下文导致 SPI 失败；
  - 忘记关闭 URLClassLoader 持有 Jar 文件句柄；
  - Mixed Delegation 破坏安全（未调用父加载器）。  
- 面试提示：能说明“为什么需要上下文 ClassLoader + 一个真实的泄漏案例（线程本地缓存持 Loader）”。

### 9.2 反射使用与性能优化
- 是什么：运行时检查/访问类型结构（Class、Field、Method、Constructor）；setAccessible 打破封装。  
- 为什么：框架通用化（DI、序列化、ORM、AOP）；动态适配未知类型。  
- 怎么用：
  - 启动阶段一次性扫描 + 缓存元数据（Method、Field、PropertyDescriptor）；
  - 访问字段优先 MethodHandle / VarHandle；
  - 批量构造对象：预热构造器句柄避免重复查找。  
- 关键细节：
  - setAccessible 在 Java 17+ 强封装模块里需 --add-opens；
  - 频繁反射阻碍 JIT 内联（invokeExact 可优化）；
  - 安全：反射可绕过 private，需最小化暴露；
  - VarHandle 提供更轻量字段访问 + 原子/内存语义操作；
  - AccessibleObject.canAccess 代替旧 isAccessible 检查。  
- 常见陷阱：
  - 每次调用通过 Class.getDeclaredXxx 查找未缓存；
  - 大量字段遍历导致启动慢；
  - 反射异常被吞（InvocationTargetException cause 丢失）。  
- 面试提示：描述“缓存反射元数据让启动从 2.3s 降到 1.1s”的案例 & 替换为 MethodHandle 的收益。

### 9.3 MethodHandle / VarHandle / invokedynamic
- 是什么：
  - MethodHandle：可优化的可组合调用句柄；
  - VarHandle：统一变量访问抽象（普通字段、数组元素、ByteBuffer）含原子/内存屏障；
  - invokedynamic：JVM 指令延迟绑定（Lambda、字符串拼接、动态语言）。  
- 为什么：降低反射成本，提供更接近 JVM 层的优化入口。  
- 怎么用：
  - Lookup lookup = MethodHandles.lookup();
  - findVirtual/findStatic/findConstructor；
  - LambdaMetaFactory 结合 invokedynamic 生成函数式对象；
  - VarHandle 获取并执行 getAndSet/compareAndExchange。  
- 关键细节：
  - MethodHandle 类型签名严格（invokeExact vs invoke）；
  - 组合器：filterArguments、filterReturnValue、dropArguments；
  - VarHandle 支持 acquire/release/opaque/volatile 访问模式；
  - Lambda 表达式字节码不生成匿名类，延迟引导提升性能。  
- 常见陷阱：
  - 忘记缓存 MethodHandle 重复 lookup；
  - 使用 invoke 而非 invokeExact 失去编译期签名校验；
  - 误解 VarHandle 与 Unsafe：前者更安全。  
- 面试提示：说明“为何框架迁移到 MethodHandle + JIT 内联优势”。

### 9.4 注解模型与元注解
- 是什么：注解 = 元数据；元注解：@Retention、@Target、@Documented、@Inherited、@Repeatable。  
- 为什么：增强可读性与工具处理能力，自描述配置。  
- 怎么用：
  - SOURCE：代码生成、静态检查；
  - CLASS：保留到字节码，运行时不读取；
  - RUNTIME：反射读取框架处理；
  - @Repeatable 通过容器注解实现多值。  
- 关键细节：
  - @Inherited 仅对类继承有效，对接口/方法无效；
  - 注解元素默认可以有 default 值，类型受限（基本类型、String、Enum、Class、注解、数组）；
  - 运行时获取：method.getAnnotations() / getDeclaredAnnotations()；
  - 合成注解（Spring）通过别名与组合整合配置。  
- 常见陷阱：
  - 忘记 Retention 导致运行时读取不到；
  - 滥用 RUNTIME 增加扫描开销；
  - default 值语义不清晰；缺少文档说明。  
- 面试提示：能列举自定义注解：@Target(ElementType.TYPE) @Retention(RUNTIME) @Documented，并解释选择 RUNTIME 的原因。

### 9.5 编译期注解处理与 APT
- 是什么：注解处理器 (JSR 269) 在编译阶段生成代码（MapStruct、AutoService、Lombok(借助内部 hook)）。  
- 为什么：减少运行时反射与启动时间；编译期失败更早反馈。  
- 怎么用：
  - 实现 AbstractProcessor；
  - 支持 @SupportedAnnotationTypes 与 @SupportedSourceVersion；
  - 利用 Filer 生成源文件或资源。  
- 关键细节：
  - 增量编译需正确声明支持；
  - 多轮处理 (rounds) 直到无新文件产生；
  - 需处理元素模型（TypeElement、ExecutableElement）。  
- 常见陷阱：
  - 生成代码包名/路径错误；
  - 忽略异常导致处理器静默失败；
  - 未处理重复注解导致冲突。  
- 面试提示：比较“运行时扫描 vs 编译期生成”性能与失败定位差异。

### 9.6 注解扫描与启动优化
- 是什么：框架通过类路径或包扫描收集注解（Spring、Jakarta）。  
- 为什么：自动配置、依赖注入、AOP 织入。  
- 怎么用：
  - 限定基础包；
  - 预构建索引（Spring AOT、Quarkus Jandex）；
  - 延迟初始化非关键 Bean。  
- 关键细节：
  - I/O 与反射叠加启动成本；
  - Native Image 需配置反射元数据；
  - JAR 内部扫描需处理多 ClassLoader 场景。  
- 常见陷阱：
  - 无包限制全盘扫描；
  - 过度使用 ClassPath 遍历导致冷启动慢；
  - Multi-release JAR 兼容性忽略。  
- 面试提示：给出“扫描包从 30 个减到 5 个启动缩短 40%”的量化。

### 9.7 动态代理技术栈对比
- 是什么：JDK Proxy（接口） vs CGLIB（继承） vs ByteBuddy（字节码 DSL） vs Javassist（源级/字节码混合）。  
- 为什么：实现横切关注点（事务、缓存、日志、限流、监控）。  
- 怎么用：
  - JDK：Proxy.newProxyInstance + InvocationHandler；
  - CGLIB：Enhancer.setSuperclass + MethodInterceptor；
  - ByteBuddy：new ByteBuddy().subclass(...).method(ElementMatchers...).intercept(...).make()。  
- 关键细节：
  - final 类/方法无法 CGLIB 代理；
  - equals/hashCode/toString 建议在代理层处理；
  - 自调用绕过代理 ⇒ 事务/缓存失效；
  - 代理链顺序影响执行（metrics → retry → circuit breaker）。  
- 常见陷阱：
  - 代理对象泄漏（缓存原始与代理混用）；
  - 过度嵌套代理导致调用栈深、性能下降；
  - InvocationHandler 中捕获异常后吞掉导致业务静默失败。  
- 面试提示：说明“如何解决 @Transactional 自调用：拆分服务或注入自身代理”。

### 9.8 反射与安全 / 模块封装
- 是什么：Java 9+ 模块系统限制未开放包的深反射访问。  
- 为什么：提高封装与安全边界。  
- 怎么用：
  - 在启动参数添加 --add-opens module/package=ALL-UNNAMED；
  - 尽量使用公共 API 或 MethodHandle。  
- 关键细节：
  - IllegalAccessException 在强封装下更常见；
  - 最小开放原则：仅对需要的包开放；
  - 禁止滥用 --illegal-access（已逐步移除）。  
- 常见陷阱：
  - 升级 JDK 后反射失效，未调整模块开放；
  - 使用 Unsafe 绕过封装造成兼容风险。  
- 面试提示：说明“迁移到 Java 17 遇到的反射失败处理步骤”。

### 9.9 反射内存与 GC 影响
- 是什么：反射缓存元数据与生成的代理 / 额外类增加元数据与元空间使用。  
- 为什么：大量动态生成类（CGLIB、ByteBuddy）可能导致 Metaspace 增长。  
- 怎么用：
  - 合理复用代理类；
  - 限制动态类生成数量；
  - 监控 Metaspace（JFR / jcmd VM.native_memory）。  
- 关键细节：
  - 旧 PermGen 已被 Metaspace 替代；
  - ClassLoader 引用链导致整批类无法卸载。  
- 常见陷阱：
  - 热加载循环生成新类未清理；
  - 将代理类放入静态集合永久持有。  
- 面试提示：提供一次“Metaspace OOM”排查过程。

### 9.10 典型面试问答速记
| 问题 | 要点速答 |
| ---- | -------- |
| 双亲委派意义 | 防止核心类被篡改，保证类型一致性与安全 |
| 为什么使用 MethodHandle | 更接近 JVM，JIT 可内联，低于反射开销 |
| @Inherited 作用范围 | 仅类继承层次，不影响方法/字段/接口 |
| 运行时扫描优化手段 | 限定包 + 预索引 + 缓存元数据 + 延迟加载 |
| 事务自调用失效原因 | 直接方法调用绕过代理，未触发切面逻辑 |
| VarHandle 优势 | 标准化内存语义访问，替代 Unsafe 某些场景 |
| 注解编译期处理价值 | 更早失败、减少运行时反射、生成高效代码 |

### 9.11 答题骨架示例（“为什么选择 MethodHandle 而非反射”）
1. 是什么：JVM 层直接可组合调用句柄。  
2. 为什么：更低调用开销、JIT 优化空间更大。  
3. 怎么用：启动阶段 lookup + 缓存句柄；invokeExact 保持签名。  
4. 关键细节：签名严格、可组合过滤器、对性能敏感路径适用。  
5. 风险与陷阱：未缓存导致重复 lookup；滥用 invoke 丢编译期检查。  
6. 案例：反射调用 QPS 下降 → 改 MethodHandle 提升 15%。  

### 9.12 实战最佳实践清单
- 扫描：限定基础包，避免全类路径遍历。  
- 缓存：字段/方法元数据缓存为轻量结构（name→MethodHandle）。  
- 降级：能用直接调用/接口聚合时不用反射。  
- 可测试性：封装反射访问到单独 Utility，便于 Mock 与替换。  
- 模块化：升级 JDK 时审查 --add-opens 配置，逐步依赖公开 API。  
- 动态类：合并拦截逻辑减少多层代理（使用组合切面顺序）。  
- 安全：仅开放必要包；禁止在公共库中暴露 setAccessible 滥用。  

### 9.13 常见陷阱对照
| 场景 | 问题 | 规避策略 |
| ---- | ---- | -------- |
| 热加载 | ClassLoader 泄漏 | 避免静态持 Loader；使用弱引用缓存 |
| 大量反射 | 启动慢 | 预索引 + 缓存 + 编译期生成 |
| 代理嵌套 | 调用栈深 | 合并横切逻辑、顺序链管理 |
| setAccessible 滥用 | 封装破坏/升级失效 | 改 MethodHandle / 公共 API |
| 未处理 InvocationTargetException | cause 丢失 | 捕获 unwrap 记录 |
| 事务自调用 | 失效 | 结构拆分 / 注入自身代理 |

### 9.14 推荐深度学习路径
- 源码：ClassLoader、ServiceLoader、MethodHandles、LambdaMetaFactory、Annotation Processing、ByteBuddy。  
- 工具：javap -c 查看 invokedynamic、JFR 事件分析反射热点、jdeps 分析模块依赖。  
- 实验：基准比较反射 vs MethodHandle vs 直接调用；扫描范围减少对启动影响测试。 