# 缓存与中间件面试指南（深化扩展版）

评分说明：5=必须掌握，4=很重要，3=熟练更佳，2=了解即可，1=加分项  
结构：单条聚焦一个知识点；统一使用“是什么 / 为什么 / 怎么用 / 关键细节 / 面试提示”五段，便于面试中层层追问与结构化输出。

---

## 1. Redis 核心数据结构（逐项拆分）[总体：5]

### 1.1 String 及整数优化 [5]
- 是什么：基础类型，内部可为 SDS（简单动态字符串）或整数（可直接用 long 存储减少开销）。  
- 为什么：高频计数、自增、分布式限流、简单 KV 场景延迟低。  
- 怎么用：INCR/INCRBY/SETEX/GETSET 做计数与过期；使用 Lua 保证复合操作原子性。  
- 关键细节：GETSET 会丢失旧值语义需谨慎；大 Value 导致网络传输与内存复制放大；使用 MSET/MGET 聚合减少 RTT。  
- 面试提示：说明为什么计数推荐用原子 INCR 而非读取再写入。

### 1.2 Bit 操作与 Bitmap [4]
- 是什么：使用位标记用户或事件状态，位序列压缩存储布尔信息。  
- 为什么：相比 Set 存储节省大量空间；批量统计效率高。  
- 怎么用：SETBIT/GETBIT/ BITCOUNT 统计活跃、签到、开关位；适合海量用户二值。  
- 关键细节：偏移大量稀疏可能扩大逻辑长度；不可直接删除单个位只可重置；需要额外记录总范围。  
- 面试提示：给出“1000万用户签到统计”位图优势。

### 1.3 Hash（小对象聚合）[5]
- 是什么：字段-值映射；ziplist / listpack（新版本）优化小 Field，超过阈值转换为 hashtable。  
- 为什么：节省多个 Key 管理开销，集中管理对象属性。  
- 怎么用：HMSET/HGETALL/HINCRBY；用于用户信息、配置对象。  
- 关键细节：HGETALL 在大 Hash 上风险；配置 hash-max-ziplist-entries/values 控制编码；单 Field 过大不宜放入。  
- 面试提示：说明“大 Hash”造成阻塞的场景与替代方案（拆分或分片）。

### 1.4 List（队列与双端）[4]
- 是什么：双端链表 QuickList；支持头尾推入弹出与阻塞操作。  
- 为什么：简易消息队列/任务队列；短期缓冲。  
- 怎么用：LPUSH/RPUSH + BRPOP/BLPOP；限制长度 LTRIM 避免无限增长。  
- 关键细节：长 List 的遍历操作效率低；阻塞命令需评估连接占用；不具可靠投递与消费确认机制。  
- 面试提示：区分使用 List 实现队列 vs 使用 Streams 的差异。

### 1.5 Set（去重集合）[4]
- 是什么：无序唯一集合；底层 intset 或 hashtable。  
- 为什么：快速去重、标签集合、在线用户集合。  
- 怎么用：SADD/SISMEMBER/SINTER/SUNION 做标签组合、共同好友、兴趣匹配。  
- 关键细节：大 Set 做差集/交集产生高 CPU；SPOP 随机弹出用数量限制；避免存放超大对象。  
- 面试提示：解释“为什么用 Set 做去重比 List 更安全”。

### 1.6 Sorted Set（排行榜与延迟队列）[5]
- 是什么：分值（score）+ 成员；底层跳表 + hash；支持按分值范围检索。  
- 为什么：构建实时排行榜、调度延迟任务（score=执行时间）。  
- 怎么用：ZADD/ZRANGE/ZREVRANGE/ZRANGEBYSCORE；延迟队列使用 ZRANGEBYSCORE 获取到期项。  
- 关键细节：频繁更新分值需评估跳表开销；大范围操作避免一次性取全；ZSET 作为延迟队列需加并发安全处理。  
- 面试提示：讲述“为什么不用 List 做延迟队列”。

### 1.7 HyperLogLog（近似计数）[3]
- 是什么：概率算法结构；用于独立用户（UV）统计，误差约 0.81%。  
- 为什么：大规模计数节省内存（12KB 固定）。  
- 怎么用：PFADD/PFCOUNT/PFMERGE 合并不同来源的 UV。  
- 关键细节：只能近似计数不能列举成员；误差可接受场景（运营报表）。  
- 面试提示：说明为何不能用于财务精确记账。

### 1.8 Bitmap vs HyperLogLog 对比 [3]
- 是什么：Bitmap 精确布尔位；HyperLogLog 近似基数。  
- 为什么：应用侧需求不同：精确 vs 近似节省内存。  
- 怎么用：按场景选择——每日签到/活跃用 Bitmap，UV 用 HyperLogLog。  
- 关键细节：Bitmap 受最大偏移；HyperLogLog 不支持删除单个元素影响结果。  
- 面试提示：给出“访问 UV vs 每日登录”区分。

### 1.9 GEO（地理空间）[3]
- 是什么：基于有序集合编码经纬度（Geohash）。  
- 为什么：实现附近地点检索与距离计算。  
- 怎么用：GEOADD/GEORADIUS（新版本 GEOSearch）获取范围内点。  
- 关键细节：精度受限；大量写入需评估更新成本；不适合复杂多边形查询。  
- 面试提示：说明为何复杂 GIS 应使用专门数据库。

### 1.10 Streams（消息队列增强）[4]
- 是什么：日志式追加结构；支持消费组、消息确认、重试与 pending 列表。  
- 为什么：比 List 更完善的消息机制（ACK、保留、游标）。  
- 怎么用：XADD -> XGROUP CREATE -> XREADGROUP -> XACK；定期处理 PEL 重试。  
- 关键细节：阻塞读取 vs 定时轮询；未 ACK 堆积；内存按条增长需裁剪（XTRIM）。  
- 面试提示：对比 Kafka：说明可靠性与持久化差异。

---

## 2. Redis 内存与性能管理（细化）[5]

### 2.1 内存分配与碎片率 [4]
- 是什么：jemalloc 分配器管理多尺寸内存；碎片率 = used_memory_rss / used_memory。  
- 为什么：碎片高导致浪费与可能触发 OOM。  
- 怎么用：监控碎片率 >1.5 时评估重启或内存整理；控制大 Key 与频繁变动结构。  
- 关键细节：RDB/AOF fork 期 COW 放大内存需预留冗余；碎片率短时升高与长期稳定区别。  
- 面试提示：解释“为何实际 RSS 远高于逻辑内存”。

### 2.2 maxmemory 与回收策略 [5]
- 是什么：内存上限 + 淘汰策略：volatile-lru / allkeys-lru / volatile-ttl / volatile-random / allkeys-random / volatile-lfu / allkeys-lfu / noeviction。  
- 为什么：在容量达到后控制新写行为与冷热淘汰。  
- 怎么用：热点高更新使用 LFU；安全关键场景避免 noeviction 业务崩溃（提前预警）。  
- 关键细节：LFU 计数器近似；TTL 与 LRU 混用；统计不精确延迟变化。  
- 面试提示：选型依据（访问模式 vs 数据价值）。

### 2.3 大 Key 风险与拆分 [5]
- 是什么：单 Key 存储过大数据结构（大 Hash/大 ZSET/巨大字符串）。  
- 为什么：阻塞删除、迁移、网络传输耗时放大。  
- 怎么用：Key 拆分为分段（hash:uid:segment）、对列表分页、避免一次性 HGETALL。  
- 关键细节：DEL 阻塞 vs UNLINK 异步；SCAN 分批遍历；迁移/复制时大 Key 卡顿。  
- 面试提示：提供“线上由于一个 10MB Key 导致延迟”的分析。

### 2.4 Pipeline 与批处理 [4]
- 是什么：客户端批量发送命令减少 RTT；服务端按序处理。  
- 为什么：提升吞吐、降低网络延迟占比。  
- 怎么用：批量写入/读取构造 Pipeline；控制每批命令数量避免阻塞。  
- 关键细节：Pipeline 不保证原子性；单批过大占满输出缓冲；与事务区别。  
- 面试提示：说明“为什么 pipeline 不适合长耗时 Lua 脚本组合”。

### 2.5 RESP 协议与多路复用 [3]
- 是什么：文本协议（RESP3 支持类型提升）；底层 TCP 长连接；客户端常用连接池与多路复用。  
- 为什么：减少握手与提升资源利用率。  
- 怎么用：合理设置连接池大小；避免阻塞命令影响共享连接。  
- 关键细节：单线程执行模型 + I/O 多路复用实现高并发；慢命令导致排队。  
- 面试提示：解释“Redis 单线程为何仍高性能”（CPU 亲和 + 内存操作 + 避免上下文切换）。

---

## 3. Redis 持久化与高可用拆分 [4]

### 3.1 RDB 快照机制 [4]
- 是什么：定期将内存数据快照保存到磁盘。  
- 为什么：灾难恢复快速加载；文件紧凑。  
- 怎么用：配置 save 秒/写次数；低峰触发手动 BGSAVE。  
- 关键细节：fork + COW 需要内存预留；快照间隔数据可能丢失。  
- 面试提示：说明“为什么高写入吞吐下 RDB 触发会膨胀内存”。

### 3.2 AOF 日志与重写 [4]
- 是什么：追加写操作日志；重写（rewrite）压缩历史。  
- 为什么：更高数据安全（丢失窗口小）；支持恢复最近状态。  
- 怎么用：appendfsync=everysec 平衡性能与安全；配置重写阈值百分比。  
- 关键细节：重写期间额外内存；过大 AOF 恢复慢；混合持久化加快启动。  
- 面试提示：比较“单用 RDB vs 混合模式”的恢复时长。

### 3.3 混合持久化 [3]
- 是什么：RDB 文件 + AOF 增量记录合并。  
- 为什么：启动快同时丢失窗口小。  
- 怎么用：开启 aof-use-rdb-preamble；监控文件大小变化。  
- 关键细节：兼容性与扩展；IO 仍需评估。  
- 面试提示：说明选择混合的场景（高可靠 + 快速重启）。

### 3.4 Sentinel 故障转移 [4]
- 是什么：监控主节点、判定下线、选举新主并通知客户端。  
- 为什么：实现自动高可用。  
- 怎么用：配置 quorum、down-after-milliseconds；多 Sentinel 部署。  
- 关键细节：网络分区脑裂风险；客户端需支持重定向。  
- 面试提示：解释“为什么需要多个 Sentinel 避免误判”。

### 3.5 Cluster 模式与槽迁移 [4]
- 是什么：16384 哈希槽分配节点；MOVED/ASK 重定向；支持扩缩容。  
- 为什么：水平扩展容量与并发。  
- 怎么用：用哈希标签保证相关 Key 同槽；reshard 迁移过程控制速率。  
- 关键细节：不支持跨槽多键原子操作（需标签）；脚本限制；从节点延迟与一致性问题。  
- 面试提示：讲“哈希标签如何保证事务性操作同槽”。

### 3.6 复制与一致性风险 [3]
- 是什么：异步复制；PSYNC 增量；复制积压缓冲区支撑短暂断开。  
- 为什么：实现读扩展与高可用。  
- 怎么用：合理 backlog 大小；监控复制延迟；主从分工。  
- 关键细节：从库过期 Key 延迟删除；读不保证最新。  
- 面试提示：说明“强一致读取策略”（强制主库或版本校验）。

---

## 4. Redis 常见问题与调优 [4]

### 4.1 缓存穿透防护 [5]
- 是什么：查询不存在数据导致频繁回源。  
- 为什么：加重数据库负载。  
- 怎么用：布隆过滤器提前拦截；缓存空值并设置短 TTL。  
- 关键细节：布隆误判率 vs 内存；空值缓存需防止缓存污染。  
- 面试提示：区分穿透与击穿与雪崩概念。

### 4.2 缓存击穿（热点失效）[5]
- 是什么：热点 Key TTL 到期瞬间并发大量请求。  
- 为什么：集中回源导致压力峰值。  
- 怎么用：互斥锁（SET NX PX）构建单线程重建；逻辑不过期（双 TTL：真实过期 + 逻辑刷新）。  
- 关键细节：锁超时与重建耗时平衡；防止锁失效重复重建。  
- 面试提示：说明“延迟双删对击穿的帮助有限”原因。

### 4.3 缓存雪崩 [5]
- 是什么：大量 Key 在同一时间集中过期。  
- 为什么：瞬时回源大量查询。  
- 怎么用：随机过期时间；分层缓存；预热错峰。  
- 关键细节：机器重启也会造成类似效果；监控过期分布。  
- 面试提示：给出“随机过期 + 预热”组合回答。

### 4.4 热点 Key 识别与治理 [4]
- 是什么：访问频率显著高的 Key/集合。  
- 为什么：容易形成单点瓶颈。  
- 怎么用：QPS 排名、命令慢日志、接入侧统计；分片/局部缓存/复制副本。  
- 关键细节：热点动态变化；复制副本需一致性策略。  
- 面试提示：谈上线前的压测如何揭示潜在热点。

### 4.5 分布式锁正确用法 [4]
- 是什么：SET key value NX PX ttl + 校验 value + Lua 解锁。  
- 为什么：避免锁竞争与误删；保证互斥。  
- 怎么用：续租或延长策略（Redisson）；锁结构包含随机 token。  
- 关键细节：锁不可重入需单独设计；RedLock 争议（网络分区/时钟问题）。  
- 面试提示：说明“为什么直接 DEL 不安全”。

### 4.6 过期集中失效抖动 [3]
- 是什么：大量 TTL 相同导致同时删除。  
- 为什么：短时命中率下降；回源增加。  
- 怎么用：过期增加随机偏移；逻辑过期策略。  
- 关键细节：偏移范围适度；避免过度延长失效。  
- 面试提示：说明监控指标（命中率曲线）变化。

---

## 5. 缓存架构模式与多级体系 [4]

### 5.1 旁路缓存（Cache Aside）[5]
- 是什么：读：先查缓存 miss → 查库写缓存；写：更新 DB 后删除缓存。  
- 为什么：灵活控制缓存生命周期。  
- 怎么用：统一封装访问层；写后删策略。  
- 关键细节：并发读写窗口；延迟双删补偿。  
- 面试提示：回答“为什么不是写后先删再写缓存”。

### 5.2 Read/Write Through 模式 [3]
- 是什么：由缓存层负责与数据库同步写入。  
- 为什么：简化应用代码。  
- 怎么用：缓存代理组件；适合中间件框架封装。  
- 关键细节：写路径延迟增加；与业务逻辑耦合。  
- 面试提示：对比 Cache Aside 的灵活性。

### 5.3 Write Behind（异步写回）[3]
- 是什么：先写缓存，异步批量刷库。  
- 为什么：提升写吞吐降低延迟。  
- 怎么用：要求严格幂等与数据丢失恢复机制。  
- 关键细节：宕机丢失风险；批量窗口大小；顺序保证。  
- 面试提示：说明业务适用前提（可容忍短暂不一致）。

### 5.4 多级缓存（L1/L2/L3）[4]
- 是什么：L1 本地（Caffeine）、L2 Redis、L3 数据库。  
- 为什么：减少网络访问延迟与集中瓶颈。  
- 怎么用：本地缓存失效广播（Pub/Sub）；热 Key 提前加载。  
- 关键细节：一致性难度提升；本地缓存容量控制；防雪崩联动策略。  
- 面试提示：给出读路径示例与失效事件流。

### 5.5 缓存预热与冷启动 [3]
- 是什么：应用启动或发布后提前填充关键 Key。  
- 为什么：避免上线初期缓存命中率低。  
- 怎么用：脚本批量加载、离线数据构建、渐进触发。  
- 关键细节：预热数据与真实访问分布偏差；过度预热浪费资源。  
- 面试提示：说明如何选取预热候选集合。

---

## 6. Kafka 基础与可靠性 [5]

### 6.1 Partition 分区与并行度 [5]
- 是什么：Topic 由多个分区组成，分区内部顺序保证。  
- 为什么：水平扩展吞吐与消费并发。  
- 怎么用：分区键（hash）控制数据倾斜；热点拆分。  
- 关键细节：分区数过多增加元数据与管理成本；顺序仅同分区有效。  
- 面试提示：说明“分区数与吞吐提升并非线性”。

### 6.2 副本与 ISR [5]
- 是什么：Leader + follower 构成副本；ISR（同步副本集合）用于确定 ack=all 持久性。  
- 为什么：保证容错与数据可靠。  
- 怎么用：min.insync.replicas 配合 acks=all；监控 ISR 缩减。  
- 关键细节：unclean leader election 可能丢数据；禁止开启除特殊场景。  
- 面试提示：描述一次 Leader 崩溃后的恢复过程。

### 6.3 日志段与保留策略 [4]
- 是什么：message log 分段存储；按大小/时间滚动；可启用压缩（compaction）。  
- 为什么：高效顺序写与归档。  
- 怎么用：retention.ms / retention.bytes / cleanup.policy=compact。  
- 关键细节：压缩基于 key 保留最新值；大消息影响页缓存。  
- 面试提示：解释“为什么小消息过多降低吞吐”。

### 6.4 消费位移管理 [5]
- 是什么：__consumer_offsets 内部主题记录消费进度。  
- 为什么：容错重启可恢复位置。  
- 怎么用：enable.auto.commit 或手动 commitSync/Async；批量处理后提交。  
- 关键细节：过早提交导致丢消息；过晚提交增加重复消费窗口。  
- 面试提示：给出“手动提交 + 幂等”组合策略。

### 6.5 Rebalance 机制与影响 [4]
- 是什么：成员加入/离开/订阅变更触发重新分配分区。  
- 为什么：保持负载均衡与故障恢复。  
- 怎么用：CooperativeSticky 降低暂停时长；优化分区映射。  
- 关键细节：过多 Rebalance 导致消费长时间停顿；会话超时设置。  
- 面试提示：分析“频繁 Rebalance”的根因（心跳/处理慢）。

### 6.6 ACK 语义与持久性 [4]
- 是什么：acks=0/1/all 控制确认策略；与 min.insync.replicas 组合实现高可靠。  
- 为什么：在延迟与可靠之间平衡。  
- 怎么用：金融/订单场景使用 acks=all + 合理 ISR。  
- 关键细节：acks=1 下 Leader 未落盘可能丢消息；幂等生产进一步降低重复。  
- 面试提示：对比 acks=all 与幂等区别。

### 6.7 幂等生产与事务 [5]
- 是什么：enable.idempotence 保证单分区去重；事务扩展跨分区 + 消费原子写入。  
- 为什么：构建 Exactly-Once 处理链。  
- 怎么用：事务：initTransactions -> beginTransaction -> send -> commitTransaction。  
- 关键细节：事务要求使用同一个 producer，超时与错误需 abort；幂等不解决跨分区原子性。  
- 面试提示：完整说出 Exactly-Once 必要条件组合。

### 6.8 Lag 与背压控制 [4]
- 是什么：Lag=生产位移 - 消费位移；衡量消费滞后。  
- 为什么：监控处理能力与拥塞。  
- 怎么用：基于 Lag 自动扩容消费者或报警；max.poll.interval.ms 改善批处理。  
- 关键细节：大量长处理阻塞心跳；避免一次拉取过多未处理。  
- 面试提示：Lag 持续增长排查路径（消费耗时 → 反序列化 → 分区不均）。

---

## 7. Kafka 性能调优 [4]

### 7.1 生产端批量参数 [4]
- 是什么：batch.size/linger.ms 控制批聚合；压缩算法 snappy/lz4/zstd。  
- 为什么：提高吞吐并降低网络与磁盘开销。  
- 怎么用：延迟容忍下增加 linger.ms 几毫秒聚合；适度 batch.size。  
- 关键细节：过大 linger 增加延迟；压缩适合大量可压缩文本；小消息压缩收益有限。  
- 面试提示：列出“吞吐 vs 延迟”调参取舍。

### 7.2 消费端拉取与并发 [4]
- 是什么：fetch.min.bytes/fetch.max.wait.ms 控制批量与等待；并发处理策略。  
- 为什么：把握吞吐 vs 响应时间。  
- 怎么用：高吞吐增大 fetch.min.bytes；多线程处理需保证顺序或使用分区线程池。  
- 关键细节：多线程共享 consumer 不安全；建议一个线程一个 consumer 或分发任务。  
- 面试提示：说明“为什么不建议多个线程直接操作同一个 consumer”。

### 7.3 零拷贝与 Page Cache 利用 [3]
- 是什么：sendfile 调用直接从文件描述符传输至 socket；减少用户态拷贝。  
- 为什么：提升吞吐与减少 CPU。  
- 怎么用：保持顺序写；避免过多随机访问。  
- 关键细节：Page Cache 命中率下降 → 磁盘 IO 提升；监控 OS 层指标。  
- 面试提示：解释“Kafka 不依赖内存数据库仍高性能”的原因。

---

## 8. 消息语义与投递模式 [4]

### 8.1 At-least-once 与幂等 [5]
- 是什么：至少一次可能重复；幂等保证业务结果一致。  
- 为什么：达到实用可靠：容忍重试。  
- 怎么用：幂等键、数据库唯一约束、状态检查。  
- 关键细节：重复窗口由提交策略与重试策略决定；重复非顺序的风险。  
- 面试提示：给出支付或库存幂等设计细节。

### 8.2 Exactly-once 处理链 [4]
- 是什么：Kafka 事务 + 幂等生产 + 消费端事务写入保证输入输出原子。  
- 为什么：避免重复与丢失组合影响。  
- 怎么用：事务消费者将偏移与结果写入一同 commit。  
- 关键细节：性能开销；跨系统（DB+Kafka）仍需外部机制。  
- 面试提示：指出“不是万能”适用范围限制。

### 8.3 延迟消息实现 [3]
- 是什么：Kafka 无原生定时精确投递；通过延迟主题或调度轮。  
- 为什么：实现定时任务/延迟重试。  
- 怎么用：分层重试 Topic；应用调度扫描到期消息。  
- 关键细节：大量延迟消息占压存储；轮询精度与性能权衡。  
- 面试提示：对比具备定时特性的消息系统（如 RocketMQ）。

---

## 9. Elasticsearch 核心原理 [3]

### 9.1 倒排索引与分词 [4]
- 是什么：词项 -> 文档 ID 列表；分词器将文本切分、归一化。  
- 为什么：高效关键字检索。  
- 怎么用：合理选择 analyzer（standard/ik/custom）；区分 keyword vs text。  
- 关键细节：错误分词配置导致搜索不命中；停用词与大小写处理。  
- 面试提示：讲“keyword 与 text 使用场景差异”。

### 9.2 Doc Values 与聚合 [3]
- 是什么：列式存储，用于排序/聚合。  
- 为什么：避免加载全部源文档。  
- 怎么用：为需要排序/聚合字段启用 doc_values（默认）。  
- 关键细节：大量高基数聚合耗内存；限制结果大小。  
- 面试提示：说明聚合慢的根因与优化（分桶设计/预聚合）。

### 9.3 Segment 刷新与合并 [3]
- 是什么：写入先入内存缓冲，refresh 生成新 segment，可搜索；后台 merge 合并小 segment。  
- 为什么：平衡实时性与写入性能。  
- 怎么用：调整 refresh_interval；批量写入减少频繁刷新。  
- 关键细节：过低 refresh 影响写吞吐；合并过程高 IO。  
- 面试提示：区分“近实时”与“实时”。

### 9.4 深分页与 search_after [3]
- 是什么：from+size 深分页性能差；search_after 利用上一页排序值游标。  
- 为什么：避免扫描与丢弃大量结果。  
- 怎么用：使用 search_after 或 Scroll/PIT；限制最大分页深度。  
- 关键细节：排序字段必须唯一稳定；Scroll 不适合实时变化数据长时间持有。  
- 面试提示：给出“深分页慢”的替代方案。

---

## 10. 分布式锁与协调中间件对比 [3]

### 10.1 Redis 锁 vs ZK/Etcd [3]
- 是什么：Redis 基于 TTL+随机值；ZK 临时顺序节点；Etcd 租约 + CAS。  
- 为什么：不同一致性模型与场景适用。  
- 怎么用：需要强一致选 ZK/Etcd（选主、配置）；需要高性能轻度互斥选 Redis。  
- 关键细节：Redis 单实例故障风险；ZK watch 机制通知；Etcd raft 保证线性一致性。  
- 面试提示：场景映射：Leader 选举 vs 简单互斥。

---

## 11. 缓存与数据库一致性策略 [5]

### 11.1 更新顺序与删缓存策略 [5]
- 是什么：写 DB → 删除缓存，避免先删后写并发回填脏数据。  
- 为什么：减少数据不一致窗口。  
- 怎么用：封装统一数据访问层；失败重试或延迟双删。  
- 关键细节：并发读在删除与写之间需考虑逻辑过期；捕捉失败日志补偿。  
- 面试提示：完整描述“延迟双删”执行流程。

### 11.2 Binlog 订阅修正 [4]
- 是什么：监听数据库变更（Canal）异步更新或删除缓存。  
- 为什么：进一步降低不一致风险。  
- 怎么用：消费 binlog 条目触发缓存更新/删除；幂等处理。  
- 关键细节：延迟与重试；程序异常丢事件需补偿。  
- 面试提示：说明与主动删缓存的协同。

### 11.3 版本号 / 时间戳方案 [4]
- 是什么：缓存中携带版本或更新时间；比较确定是否旧值。  
- 为什么：防止写入过期数据。  
- 怎么用：更新时带版本；读到旧版本进行刷新流程。  
- 关键细节：时钟漂移问题；版本递增策略。  
- 面试提示：举“并发写覆盖”场景解决。

---

## 12. 中间件安全与访问控制 [3]

### 12.1 Redis ACL 与命令控制 [3]
- 是什么：基于用户配置命令、Key 前缀权限。  
- 为什么：细粒度隔离与安全审计。  
- 怎么用：用户分级；禁止危险命令（FLUSHALL）。  
- 关键细节：ACL 文件同步；误配置导致授权失败。  
- 面试提示：说明默认 AUTH 密码不足以细粒度控制。

### 12.2 Kafka ACL 与认证 [3]
- 是什么：SASL/SCRAM / Kerberos + ACL 对 Topic/Group 控制。  
- 为什么：防止越权生产与消费。  
- 怎么用：集中管理脚本；定期审计 topic 权限。  
- 关键细节：明文配置安全风险；动态添加需滚动刷新。  
- 面试提示：描述最小权限实践。

### 12.3 Elasticsearch 安全 [3]
- 是什么：X-Pack/OpenSearch 提供角色、索引级权限与 TLS。  
- 为什么：保护敏感搜索与聚合数据。  
- 怎么用：角色映射；字段级屏蔽；审计日志。  
- 关键细节：默认无权限控制风险；内部节点通信需加密。  
- 面试提示：解释“为什么不能对外暴露未加固 ES”。

---

## 13. 监控与可观测性指标 [4]

### 13.1 Redis 指标体系 [4]
- 是什么：命中率、内存使用、碎片率、慢日志、阻塞命令、连接数。  
- 为什么：提前发现容量与性能问题。  
- 怎么用：采集 INFO、慢日志分析；阈值告警。  
- 关键细节：命中率下降需区分业务访问模式变化 vs 缓存失效；慢命令定位大 Key。  
- 面试提示：说明“命中率低不一定缓存设计失败”。

### 13.2 Kafka 关键指标 [4]
- 是什么：生产延迟、请求失败率、Lag、ISR 变化、字节入出、磁盘利用。  
- 为什么：保障吞吐与可靠性。  
- 怎么用：Lag 告警结合重试策略；ISR 缩减触发风险预警。  
- 关键细节：硬件瓶颈（磁盘、网络）；小消息过多。  
- 面试提示：排序排查：延迟→Lag→分区→消费速率。

### 13.3 Elasticsearch 指标 [3]
- 是什么：查询耗时分位、段合并队列、GC、磁盘水位、线程池拒绝。  
- 为什么：定位搜索慢与集群风险。  
- 怎么用：监控 pending tasks；水位策略调度。  
- 关键细节：合并与刷新影响写入；高基数聚合内存爆炸。  
- 面试提示：从“查询慢”到“聚合高基数字段无优化”链路说明。

---

## 14. 常见故障与排错模式 [4]

### 14.1 Redis 阻塞排查 [4]
- 是什么：慢命令或大 Key 操作导致主线程执行时间长。  
- 为什么：单线程模型所有请求排队。  
- 怎么用：慢日志、命令执行耗时分析；替换 KEYS 为 SCAN。  
- 关键细节：UNLINK 异步删除；AOF 重写与 RDB fork 期间性能波动。  
- 面试提示：给出标准排查步骤。

### 14.2 Kafka Rebalance 频繁 [4]
- 是什么：消费组频繁触发分区重新分配。  
- 为什么：心跳超时/处理慢/成员波动。  
- 怎么用：提高 session.timeout.ms；优化消费处理逻辑；稳定部署。  
- 关键细节：Cooperative 模式减轻一次性暂停；偏移提交异常引发踢出。  
- 面试提示：列出至少三种根因与对应措施。

### 14.3 ES 集群黄/红状态 [3]
- 是什么：黄表示副本未分配；红表示主分片丢失不可用。  
- 为什么：节点故障/磁盘水位/分片过多。  
- 怎么用：查看 allocation explain；清理磁盘；重建副本。  
- 关键细节：过多小索引碎片化；watermark 阈值阻止分配。  
- 面试提示：说明“主分片丢失恢复路径”。

---

## 15. 序列化与协议效率 [3]

### 15.1 JSON vs 二进制协议 [3]
- 是什么：JSON 可读性高；二进制 (Protobuf/Kryo) 更紧凑与高速。  
- 为什么：网络与 CPU 成本权衡。  
- 怎么用：热路径使用 Protobuf；外围管理使用 JSON。  
- 关键细节：Schema 演进兼容性；对象池减少创建。  
- 面试提示：说明“为什么大批量消息换用二进制后 TPS 提升”。

### 15.2 压缩策略 [3]
- 是什么：Snappy/LZ4/Zstd 在 Kafka 等中间件使用；降低带宽。  
- 为什么：批量与文本消息压缩收益显著。  
- 怎么用：配置 compression.type；评估 CPU 与延迟。  
- 关键细节：小消息集合压缩比高；高 CPU 场景慎用重压缩。  
- 面试提示：描述“压缩适用与不适用场景”。

---

## 16. 多租户与隔离 [2]

### 16.1 Redis 命名空间策略 [2]
- 是什么：前缀区分租户 Key；或使用多个逻辑数据库（不推荐大量）。  
- 为什么：避免冲突与便于统计。  
- 怎么用：前缀 + 监控聚合；集中清理。  
- 关键细节：逻辑 DB 隔离弱；脚本需考虑前缀。  
- 面试提示：说明前缀方式优点。

### 16.2 Kafka/ES 租户隔离 [2]
- 是什么：Topic/索引级权限与配额限制。  
- 为什么：防止资源互相竞争。  
- 怎么用：Quota 配置生产/消费速率；索引模板管理。  
- 关键细节：突发流量保护；ACL 定期审计。  
- 面试提示：强调监控配额超限告警。

---

## 17. 面试常见问答速览（补充）[辅助]
1. Redis 分布式锁安全释放条件？比较随机值确保是同一持有者再删除。  
2. 缓存雪崩与击穿差异？雪崩为大量 Key 同时过期；击穿为单热点 Key 到期。  
3. Kafka Exactly-once 如何实现？幂等生产 + 事务 + 消费端原子位移提交。  
4. Sorted Set 做延迟队列原理？score 存执行时间，按 ZRANGEBYSCORE 拉取到期任务。  
5. Elasticsearch 深分页替代方案？search_after/scroll/PIT。  
6. Redis Cluster 为什么使用槽？抽象层简化扩容与迁移部分数据而非全量重哈希。  
7. 延迟双删具体步骤？写 DB → 删除缓存 → 睡眠短暂 → 再删一次。  

---

## 18. 学习与实践建议 [辅助]
- 逐步：先掌握数据结构应用，再进入高可用与一致性策略。  
- 压测：对比 pipeline vs 单命令、Kafka linger.ms 调优曲线。  
- 演练：构造 Redis 主从切换、Kafka Rebalance、ES 分片丢失恢复。  
- 监控落地：定义指标→阈值→告警→回溯定位。  
- 规范：统一 Key 命名、消息 Schema 管理、缓存失效策略标准化。

---

## 19. 重要度汇总（更新）
- Redis 数据结构 / 缓存核心策略 / Kafka 分区副本与位移 / 缓存与数据库一致性：[5]
- Redis 内存管理 / 分布式锁 / Redis 高可用 / Kafka Rebalance & ACK / Sorted Set 延迟队列 / Pipeline：[4]
- Elasticsearch 基础 / 多级缓存 / 消息语义 / 监控体系 / 数据一致性版本策略 / AOF+RDB 混合：[3]
- 序列化与压缩 / 多租户隔离 / GEO / HyperLogLog / 深分页优化 / 预热策略：[2]

(完)