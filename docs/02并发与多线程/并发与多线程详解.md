# 并发与多线程面试指南（重排与扩展版）

评分说明：5=必须掌握，4=很重要，3=熟练更佳，2=了解即可，1=加分项  
结构说明：按“基础内核 → 同步原语 → 高级结构与模式 → 性能与诊断 → 新特性与扩展”层次重新排序。每个知识点依旧包含“是什么 / 为什么 / 怎么用 / 关键细节 / 面试提示”。

---

## 1. 线程/进程/虚拟线程对比 [4]
- 是什么：进程=资源/地址空间；OS 线程=调度实体；虚拟线程=Loom 轻量线程，阻塞转为挂起。
- 为什么：指导并发模型选择与资源预算。
- 怎么用：CPU 密集少线程；高并发阻塞 IO 用虚拟线程；跨边界用进程隔离。
- 关键细节：虚拟线程共享堆/锁；长持锁会阻塞载体线程；ThreadLocal 大对象需谨慎。
- 常见陷阱：把虚拟线程当“更快”误用；忽略锁导致载体线程饥饿。
- 面试提示：强调“阻塞=挂起”，不是魔法。
- 案例：将 10k 阻塞 HTTP 调用改虚拟线程，线程数降 95%，CPU 稳定。
- 速记：CPU→少线程；IO→虚拟线程；跨边界→进程。

## 2. 线程生命周期与中断 [3]
- 是什么：NEW→RUNNABLE→BLOCKED/WAITING/TIMED_WAITING→TERMINATED；中断是协作信号。
- 为什么：定位卡顿与退出策略。
- 怎么用：正确处理中断（恢复标志或上抛）；守护线程不阻止退出。
- 关键细节：ThreadLocal 清理；jstack 识别 WAITING vs BLOCKED。
- 常见陷阱：吞 InterruptedException；忘记清理 ThreadLocal。
- 面试提示：给出中断处理模板。
- 案例：修复吞中断导致无法关闭的问题。
- 速记：中断=协作退出；捕获→恢复→清理→返回。

## 3. JMM 与 happens-before [5]
- 是什么：可见性与有序性的规则集。
- 为什么：避免读取半初始化与竞态。
- 怎么用：利用锁/volatile/线程边界/final 构造完成建立 HB。
- 关键细节：指令可重排但不破坏单线程语义；DCL 需 volatile；this 逃逸破坏发布。
- 常见陷阱：认为 volatile 能保证 ++ 原子；构造期注册回调。
- 面试提示：背出 HB 规则与典型反例。
- 案例：DCL 单例加 volatile 解决未初始化读。
- 速记：HB 四钥匙：锁/volatile/线程启动终止/final。

## 4. 内存屏障与重排序 [3]
- 是什么：LoadLoad/StoreStore/LoadStore/StoreLoad 屏障限制重排。
- 为什么：建立跨线程顺序。
- 怎么用：用锁/volatile/原子类自动插入屏障。
- 关键细节：StoreLoad 最强；volatile 写前后含 Store/Load 屏障。
- 常见陷阱：自实现无锁发布不插屏障。
- 面试提示：举“先发引用后填充”的问题。
- 案例：引入锁后消除读取默认值。
- 速记：别手写屏障；用语言原语。

## 5. volatile 使用边界 [5]
- 是什么：轻量可见性+禁止相关重排；不保证复合原子性。
- 为什么：状态/标志传播无需重锁。
- 怎么用：关闭标志、配置引用、DCL。
- 关键细节：多变量一致性需锁/原子类；写频高开销大。
- 常见陷阱：volatile ++；复合检查-更新。
- 面试提示：列举“可/不可”清单。
- 案例：用 volatile 配置引用热替换。
- 速记：单值传播用；复合逻辑不用。

## 6. synchronized 与锁状态升级 [5]
- 是什么：监视器锁；无锁→偏向→轻量→重量。
- 为什么：无竞争时成本低，语义直观。
- 怎么用：小临界区；不可中断/超时场景优先。
- 关键细节：偏向撤销成本；锁粗化/消除依赖逃逸分析。
- 常见陷阱：需要中断/超时还用 synchronized。
- 面试提示：现代 JVM 下无竞争并不慢。
- 案例：拆分临界区，锁等待时间下降 80%。
- 速记：简单互斥=sync；中断/超时/条件→ReentrantLock。

## 7. AQS 框架 [5]
- 是什么：state + CLH 队列 + CAS + park/unpark 的抽象。
- 为什么：统一构建锁/信号量/栅栏等。
- 怎么用：重写 tryAcquire/tryRelease(独占/共享)。
- 关键细节：公平/非公平差异；可中断获取。
- 常见陷阱：未处理中断与超时；释放不对称。
- 面试提示：画 acquire 流程图。
- 案例：自定义限流器（共享模式）0 抖动。
- 速记：state+FIFO；独占/共享两条线。

## 8. ReentrantLock/ReadWriteLock/StampedLock [5]
- 是什么：可重入锁/读写锁/带乐观读戳锁。
- 为什么：提供中断/超时/条件队列/高性能读。
- 怎么用：tryLock(超时) 防死锁；读多用 RW；超热读用 StampedLock 乐观读 validate。
- 关键细节：StampedLock 不可重入；写饥饿；validate 失败回退悲观读。
- 常见陷阱：在 StampedLock 中使用条件队列。
- 面试提示：给选择矩阵。
- 案例：乐观读失败率<2% 吞吐+20%。
- 速记：控制→RL；读多→RW；热读→Stamped。

## 9. 原子类/CAS/LongAdder [5]
- 是什么：Atomic*、LongAdder、Accumulator 封装无锁更新。
- 为什么：减少阻塞、提升轻竞争性能。
- 怎么用：AtomicReference 状态机；*StampedReference 防 ABA；LongAdder 高并发计数。
- 关键细节：CAS 自旋重试；LongAdder sum 非实时。
- 常见陷阱：读要求强一致仍用 LongAdder。
- 面试提示：volatile vs Atomic 区别。
- 案例：AtomicLong→LongAdder p99 降 15%。
- 速记：低争用 Atomic；高争用 LongAdder；需要版本戳用 Stamped。

## 10. ConcurrentHashMap 深入 [5]
- 是什么：桶+链/树，协作扩容，弱一致迭代。
- 为什么：高并发吞吐。
- 怎么用：compute/merge/computeIfAbsent；forEach/search/reduce 并行阈值。
- 关键细节：树化阈值≥8 且 cap≥64；size 近似；键值不可为 null。
- 常见陷阱：get→put 复合竞态；依赖 size 精确控制。
- 面试提示：为何提供弱一致迭代。
- 案例：merge 取代三步更新 TPS +18%。
- 速记：三件套；size 近似。

## 11. JUC 容器与同步工具总览 [4]
- 是什么：ConcurrentLinkedQueue/BlockingQueue 系列/COW/DelayQueue/Semaphore/Latch/Barrier/Phaser/Exchanger。
- 为什么：减少手写同步风险。
- 怎么用：COW 读多写少；Semaphore 控并发；Barrier/Phaser 分阶段；Exchanger 对称交换。
- 关键细节：Latch 一次性；Phaser 动态注册；SynchronousQueue 零缓冲。
- 常见陷阱：无限队列掩盖背压。
- 面试提示：Latch vs Barrier vs Phaser。
- 案例：定长队列+拒绝策略避免 OOM。
- 速记：定长队列+背压；阶段工具匹配场景。

## 12. Semaphore vs RateLimiter [3]
- 是什么：并发数量 vs 速率控制。
- 为什么：不同维度保护资源。
- 怎么用：热点并发→Semaphore；平滑 QPS→令牌桶。
- 关键细节：可组合：先速率再并发。
- 常见陷阱：用 Semaphore 期望限速。
- 面试提示：清晰区分维度。
- 案例：组合使用降低峰值抖动。
- 速记：并发≠速率；可叠加。

## 13. Latch/Barrier/Phaser 对比 [4]
- 是什么：一次性倒计数/可重用栅栏/多阶段动态参与。
- 为什么：满足不同协作语义。
- 怎么用：预热等待→Latch；分批聚合→Barrier；复杂多阶段→Phaser。
- 关键细节：BrokenBarrierException；Phaser arrive/arriveAndAwaitAdvance。
- 常见陷阱：栅栏破损未处理。
- 面试提示：是否重用/是否多阶段。
- 案例：批处理流水线用 Phaser 稳定推进。
- 速记：一次性→Latch；阶段→Barrier/Phaser。

## 14. CompletableFuture 编排与异常 [4]
- 是什么：声明式异步组合。
- 为什么：避免回调地狱。
- 怎么用：thenCompose/thenCombine/allOf/exceptionally/orTimeout。
- 关键细节：commonPool 不适合阻塞；join 阻塞位置谨慎；handle 会吞异常。
- 常见陷阱：thenApply 造成嵌套 Future。
- 面试提示：thenCompose vs thenApply。
- 案例：自建池+超时 p99 稳定。
- 速记：阻塞→自建池；展开→thenCompose；异常尾部收敛。

## 15. ForkJoinPool 与工作窃取 [4]
- 是什么：分治递归+双端队列窃取。
- 为什么：提升 CPU 利用率。
- 怎么用：设阈值；CPU 密集；阻塞用 ManagedBlocker。
- 关键细节：本地 LIFO、窃取 FIFO；parallelStream 不适 IO。
- 常见陷阱：阈值过小调度开销大。
- 面试提示：并行阈值如何定。
- 案例：阈值调优后吞吐 +30%。
- 速记：合适阈值；阻塞申明。

## 16. 虚拟线程 (Loom) 实战 [4]
- 是什么：轻量线程，阻塞自动挂起。
- 为什么：极简模型支持海量并发。
- 怎么用：newVirtualThreadPerTaskExecutor/Thread.ofVirtual()。
- 关键细节：重锁阻塞载体；ThreadLocal 内存放大；限流/背压仍需。
- 常见陷阱：把 CPU 密集改虚拟线程期望变快。
- 面试提示：最适阻塞 IO。
- 案例：爬虫并发数 10x，资源稳定。
- 速记：阻塞→挂起；谨慎锁与 ThreadLocal。

## 17. 并发设计模式 [4]
- 是什么：生产者-消费者、批量合并、分段锁、双缓冲、Actor、Disruptor。
- 为什么：提升吞吐/隔离延迟。
- 怎么用：队列削峰；批量 flush；分段锁；Actor 单线程。
- 关键细节：幂等；背压水位；缓存行填充。
- 常见陷阱：无限积压；批量无边界。
- 面试提示：按瓶颈选模式。
- 案例：批量合并 QPS +40%。
- 速记：削峰/批量/隔离/单线程。

## 18. 安全发布与不可变 [4]
- 是什么：完全初始化后对外可见；不可变对象天然线程安全。
- 为什么：避免半初始化与竞态。
- 怎么用：final 字段；构造不泄露；volatile 引用更新；不可变集合。
- 关键细节：防御性复制；记录类/值对象。
- 常见陷阱：返回内部可变集合。
- 面试提示：Holder/enum 单例。
- 案例：不可变配置避免加锁。
- 速记：final+不泄露；返回副本。

## 19. 死锁检测与预防 [5]
- 是什么：循环等待导致永久阻塞。
- 为什么：关键资源长时间占用。
- 怎么用：统一加锁顺序；tryLock+超时；减少嵌套。
- 关键细节：四条件；ThreadMXBean 检测；BrokenBarrier 处理。
- 常见陷阱：交叉锁无顺序；忽视异常路径释放。
- 面试提示：如何破坏四条件。
- 案例：加锁顺序标准化消除死锁。
- 速记：顺序/超时/降粒度。

## 20. 并发性能调优与诊断 [4]
- 是什么：指标驱动优化。
- 为什么：避免拍脑袋调参数。
- 怎么用：JFR/jstack/async-profiler；监控 p95/p99/锁等待/队列长度。
- 关键细节：无限队列掩盖背压；锁等待>执行时间要拆。
- 常见陷阱：盲目加线程。
- 面试提示：四步法：度量→采样→优化→验证。
- 案例：定长队列+拒绝策略稳定延迟。
- 速记：数据说话。

## 21. 工具与指标 [4]
- 是什么：JFR、jstack、jmap、perf、async-profiler、ThreadMXBean。
- 为什么：缩短定位时间。
- 怎么用：自动采集；阈值告警；基线对比。
- 关键细节：GC 停顿与锁等待叠加；上下文切换过多。
- 常见陷阱：只看平均忽略 p99。
- 面试提示：列关键指标清单。
- 案例：火焰图定位锁竞争热区。
- 速记：JFR 低入侵；看 p99。

## 22. 常见并发 Bug [4]
- 是什么：竞态/死锁/活锁/饥饿/伪共享/错误发布/写偏。
- 为什么：破坏正确性与性能。
- 怎么用：原子替代 check-then-act；统一锁序；版本戳；validate 乐观读。
- 关键细节：活锁=不断退让无进展；饥饿=不公平+高优先级任务。
- 常见陷阱：日志吞异常掩盖竞态。
- 面试提示：自带实战案例。
- 速记：先正再快；可证明。

## 23. 伪共享与缓存行 [3]
- 是什么：同缓存行多线程写导致失效风暴。
- 为什么：总线流量↑吞吐↓。
- 怎么用：@Contended、分桶、填充。
- 关键细节：需 JVM 参数；过度填充浪费内存。
- 常见陷阱：无度量盲用 @Contended。
- 面试提示：计数器分桶示例。
- 案例：分桶计数 + @Contended p99 降 20%。
- 速记：高冲突→分离。

## 24. 并发 vs 内存权衡 [3]
- 是什么：分段/副本换吞吐。
- 为什么：降低竞争。
- 怎么用：LongAdder 分槽；分片 Map；COW 小集合。
- 关键细节：监控堆/对象数/GC。
- 常见陷阱：为小收益付出大内存。
- 面试提示：量化取舍。
- 速记：空间换并发有度。

## 25. JVM 锁优化（偏向/轻量/消除/粗化）[3]
- 是什么：运行时根据逃逸与竞争优化。
- 为什么：降低无竞争开销。
- 怎么用：减少跨线程共享；避免碎片化小同步块。
- 关键细节：偏向批量撤销；锁消除依赖逃逸。
- 常见陷阱：误解“偏向锁=一定更快”。
- 面试提示：现代 sync 不再“天生慢”。
- 速记：不共享→可消除；小块→可粗化。

## 26. VarHandle/Unsafe 语义 [3]
- 是什么：VarHandle=标准化访问语义（plain/opaque/acquire/release/volatile）；Unsafe=受限底层。
- 为什么：细粒度内存序替代部分 Unsafe。
- 怎么用：getAcquire/setRelease 构建单向依赖；必要时 volatile。
- 关键细节：opaque 最弱仅可见；invokeExact 严格签名。
- 常见陷阱：误用 volatile 过度。
- 面试提示：为何引入 VarHandle。
- 速记：按需选语义；尽量避 Unsafe。

## 27. Disruptor/RingBuffer [3]
- 是什么：无锁高吞吐队列框架。
- 为什么：低延迟流水线。
- 怎么用：预分配环、序号发布、屏障依赖。
- 关键细节：缓存行填充；序号屏障。
- 常见陷阱：复杂路由/不稳定流下收益打折。
- 面试提示：对比 BlockingQueue。
- 速记：稳定流+预分配。

## 28. DCL 单例正确实现 [4]
- 是什么：延迟实例化。
- 为什么：节省启动与内存。
- 怎么用：volatile + 双检查 + sync；或 Holder/enum。
- 关键细节：构造重排风险。
- 常见陷阱：缺 volatile。
- 面试提示：字节码顺序说明风险。
- 速记：DCL 必 volatile；优先 Holder/enum。

## 29. 并发测试：jcstress/JMH [3]
- 是什么：jcstress 验证语义；JMH 微基准。
- 为什么：防“看似正确”。
- 怎么用：预热+fork；显式校验；隔离 IO。
- 关键细节：死代码消除；基准场景单一变量。
- 常见陷阱：一次跑出结论。
- 面试提示：微基准与生产差异。
- 速记：验证语义→jcstress；测性能→JMH。

## 30. Structured Concurrency（展望）[2]
- 是什么：结构化任务作用域管理生命周期/取消/异常。
- 为什么：防止“孤儿任务”，简化汇总。
- 怎么用：StructuredTaskScope/ScopedValue。
- 关键细节：仍在演进；与线程池职责区分。
- 常见陷阱：与虚拟线程混淆。
- 面试提示：价值=统一取消与异常聚合。
- 速记：作用域化并发。

## 31. 线程池参数估算与实践 [5]
- 是什么：核心/最大/队列/拒绝策略/线程工厂。
- 为什么：平衡吞吐与资源。
- 怎么用：CPU 密集 core≈CPU；IO 密集≈CPU×(1+阻塞/计算)；队列定长+拒绝策略。
- 关键细节：newCachedThreadPool 无界；监控队列/拒绝/活跃线程。
- 常见陷阱：盲目加线程；无背压。
- 面试提示：给估算公式与监控项。
- 速记：定长队列+度量调参。

---

## 常见面试延伸追问与回答框架（扩展版，≥20题）

1. volatile 能替代锁做计数吗？不能，复合操作非原子。  
2. 双重检查锁为何需 volatile？防止重排序将引用提前暴露。  
3. ConcurrentHashMap 为什么迭代弱一致？降低全局加锁成本提升并发。  
4. LongAdder 什么时候不适合？需要实时精确读取或参与后续逻辑判断。  
5. synchronized 与 ReentrantLock 选择标准？需中断/超时/公平/条件队列则用 ReentrantLock，否则简单互斥用 synchronized。  
6. ReadWriteLock 写偏问题是什么？大量读锁占用导致写锁长期等待。  
7. StampedLock 乐观读如何验证？通过 stamp validate，失败回退悲观读锁。  
8. ForkJoinPool 阈值设置依据？拆分成本与任务处理时间比，避免过度细粒度。  
9. parallelStream 为什么不适合阻塞 IO？阻塞占用少量工作线程导致饥饿。  
10. CompletableFuture thenCompose 与 thenApply 区别？前者展开内部 future，后者仅映射结果值。  
11. 线程池核心参数估算方法？CPU 密集 core≈CPU；IO 密集 core≈CPU×(1+等待/计算比)。  
12. 为什么不推荐 Executors.newCachedThreadPool 滥用？无限增长线程可能耗尽资源。  
13. 死锁四条件及破坏方式？互斥/占有等待/不可剥夺/循环等待；破坏锁顺序或使用 tryLock 超时。  
14. CountDownLatch 与 join 区别？Latch 可等待任意任务集合，join 仅等待线程结束。  
15. Phaser 优势是什么？支持多阶段与动态注册参与者。  
16. 伪共享如何定位？性能分析发现高速写变量彼此干扰，缓存行命中率低。  
17. 为什么无竞争 synchronized 仍快？偏向/轻量级锁优化消除重量级阻塞。  
18. VarHandle 与原子类区别？提供更细粒度内存语义与对数组/字段统一访问抽象。  
19. Unsafe 不建议使用原因？非安全、可导致崩溃，兼容性差，受限权限。  
20. 虚拟线程与线程池差别？成本低，阻塞挂起不占平台线程，适合海量阻塞任务。  
21. RateLimiter 与 Semaphore 能否一起用？可以，先速率限制再并发限制。  
22. 为什么需要安全发布？避免其他线程看到部分初始化状态导致逻辑错误。  
23. computeIfAbsent 比双检更安全原因？单方法内原子语义避免竞态窗口。  
24. Lock 公平模式何时使用？防止饥饿，但吞吐降低，适合长持锁且需顺序公平场景。  
25. AQS 为什么使用自旋 + park？减少短期等待的阻塞开销，长等待再挂起。  
26. 为什么线程过多会降低吞吐？上下文切换和缓存失效开销增加。  
27. 如何检测生产死锁？ThreadMXBean.findDeadlockedThreads 定期扫描 + 告警。  
28. Actor 模型优势？消息串行保证不需锁，易于隔离状态。  
29. Disruptor 比 BlockingQueue 快的原因？环形缓冲预分配 + 序号屏障 + 减少伪共享。  
30. 什么时候选择 CopyOnWriteArrayList？读远多于写且列表较小，需稳定迭代。

---

## 重要度汇总
- JMM / happens-before [5]
- synchronized 与锁升级机制 [5]
- AQS 框架与实现原理 [5]
- ReentrantLock / ReadWriteLock / StampedLock [5]
- ConcurrentHashMap 深入与原子操作模式 [5]
- 线程池参数估算与调优 [5]
- volatile 使用边界 [5]
- 死锁预防与检测 [5]
- 原子类 / CAS / LongAdder [5]
- CompletableFuture 编排与异常处理 [4]
- ForkJoinPool / 工作窃取 [4]
- 虚拟线程 (Project Loom) [4]
- 并发设计模式与实践 [4]
- 安全发布 / 不可变对象 [4]
- 并发性能诊断与指标 [4]
- JUC 同步工具对比 (Semaphore/Latch/Barrier/Phaser) [4]
- CountDownLatch / Barrier / Phaser 语义区分 [4]
- 内存屏障与重排序 [3]
- 伪共享优化 [3]
- 并发与内存权衡 [3]
- JVM 锁优化机制 [3]
- VarHandle / Unsafe 语义 [3]
- Disruptor / RingBuffer [3]
- 并发测试 jcstress / JMH [3]
- RateLimiter vs Semaphore [3]
- Structured Concurrency 概念 [2]

(完)