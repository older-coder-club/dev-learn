# 数据访问与数据库面试指南（扩展深化版）


说明：下文现有章节内容已按上述归类顺序排列并标注重要度，便于学习与面试复盘。后续如需细化到小节，请在对应归类下补充或移动原内容。

评分：5=必须掌握，4=很重要，3=熟练更佳，2=了解即可，1=加分项  
结构：单条聚焦一个知识点，按“是什么 / 为什么 / 怎么用 / 关键细节 / 面试提示”展开，便于追问。

---

## 1. 索引与 SQL 优化

### 1.1 EXPLAIN 与访问类型 [5]
是什么：EXPLAIN 列 (id/select_type/table/type/possible_keys/key/key_len/ref/rows/filtered/Extra) 与访问类型层级（const/system > eq_ref > ref > range > index > ALL）。
为什么：评估执行路径与代价，判断是否命中合适索引并避免全表扫描、额外排序、临时表。
怎么用：
- 先看 `type` 目标 ≥ range/ref；再看 `key`/`key_len` 是否预期；`rows` 是否过大；`Extra` 是否出现 Using filesort/temporary。
- 结合慢 SQL 模板与统计信息，迭代到更优访问级别。
关键细节：rows 为估算值依赖统计；key_len 反映索引前缀利用度；直方图可改善选择性判断。
常见陷阱：误以为 `COUNT(1)` 比 `COUNT(*)` 更快；函数包裹/隐式转换致索引失效。
面试提示：指出 Using filesort 根因并给出覆盖索引或索引顺序调整策略。
案例：将 ORDER BY 非索引列改为联合索引覆盖列，EXPLAIN 去除 Using filesort，响应缩短 40%。
速记：先看 type，再看 key/rows/Extra；消 filesort/temporary。

补充：EXPLAIN 诊断清单（可直接过一遍）
- 访问类型：`type` 是否达到 `range/ref/eq_ref/const`；`index/ALL` 需优化。
- 索引命中：`key` 是否预期；`key_len` 是否覆盖到关键前缀；`possible_keys` 是否包含候选。
- 扫描估计：`rows` 是否异常偏大；`filtered` 低说明过滤在后端发生。
- 额外代价：`Extra` 出现 `Using filesort/temporary` 时，考虑覆盖索引或改 ORDER BY 列顺序/条件重写。
- 联结顺序：多表场景关注 `id/select_type` 递增/递减关系与驱动表是否合适。

#### 访问类型详解（const/eq_ref/ref/range/index/ALL）
- const/system：单行常量访问（主键/唯一索引等值），最优；常见于 `WHERE pk = ?`。
- eq_ref：基于唯一索引的连接，每行最多匹配一行；典型主键/唯一键 JOIN。
- ref：普通索引等值匹配，选择性较好时性能稳定；
- range：范围扫描（`> < BETWEEN LIKE 'abc%'`），后续列可能失效；
- index：索引全扫描但不回表，仍有高 IO 成本；
- ALL：全表扫描，应通过索引与条件重写规避。

### 1.2 索引设计与覆盖索引 [5]
是什么：索引设计五步法 + 联合索引列顺序原则 + 覆盖索引的工程取舍。
为什么：系统化避免冗余/低效索引，提升过滤效率并减少回表。
怎么用：
- 五步法：识别查询模式 → 提取过滤/排序/连接列 → 计算选择性 → 最左前缀设计 → 验证覆盖与回表。
- 列顺序：等值且高选择性前置；范围/排序列后置；JOIN 列适度考虑。
- 覆盖索引：高频只读场景增加小而精准的联合索引；SELECT 精简列。
关键细节：范围条件后续列失效；索引过宽增加写放大；覆盖索引减少随机 IO。
常见陷阱：将“可能用到”的列一股脑塞进复合索引；范围列前置导致后续列失效。
面试提示：给出错误列顺序案例与修正；说明读多写少 vs 写多读少的策略差异。
案例：订单列表增加 `(user_id, status, created_at)` 覆盖索引，p95 降 40%。
速记：高选择性等值前置；范围后置；覆盖谨慎加列。

### 1.3 条件重写与下推（OR→UNION/派生列/ICP/Index Merge） [4]
是什么：通过条件重写与下推让优化器走索引路径：OR 拆 UNION、表达式改派生列、启用索引条件下推（ICP）、评估 Index Merge。
为什么：减少回表与 CPU 过滤量，避免 ALL/INDEX 扫描。
怎么用：
- 将 `WHERE A OR B` 拆为 `UNION ALL` 子查询；
- 将 `WHERE date(created_at)=?` 改为 `created_date` 派生列；
- 保持条件在索引字段可直接计算以启用 ICP。
关键细节：UNION vs UNION ALL 去重成本差异；Index Merge 不一定优于重建联合索引。
常见陷阱：依赖优化器“看懂”复杂表达式；过度依赖 Index Merge。
面试提示：对比重写前后 EXPLAIN（type 从 ALL 提升到 range/ref）。
案例：支付流水由函数过滤改派生列，IO 页访问下降 60%。
速记：OR→UNION；函数改派生；能下推就下推；联合索引优先。

补充：重写示例对照
- 原始：`WHERE status = ? OR user_id = ?` → 优化：
	```sql
	SELECT ... FROM t WHERE status = ?
	UNION ALL
	SELECT ... FROM t WHERE user_id = ?
	```
	两条子查询各走单列/联合索引，避免 `OR` 触发全表扫描。
- 原始：`WHERE DATE(created_at) = ?` → 优化：维护 `created_date` 派生列（`DATE(created_at)` 在写时或任务生成），查询改：`WHERE created_date = ?`，启用索引并可下推。
- 原始：`WHERE colA + colB > ?` → 优化：维护 `sum_ab` 派生列，查询 `WHERE sum_ab > ?`。

#### 索引条件下推（ICP）详解
- 条件：表达式能在索引字段上直接计算（无函数包裹/隐式转换）；
- 效果：在索引扫描阶段先过滤，显著减少回表行数与 CPU 过滤；
- 限制：部分存储引擎/复杂条件不支持；多列组合时以能下推的前缀为主；
- 实战：将 `WHERE LOWER(name)=?` 改为 `name_ci` 预处理列或使用合适排序规则索引，启用下推。

### 1.4 分页与全局排序（游标/延迟关联/跨分片归并） [4]
是什么：单库大分页优化与跨分片全局排序分页策略。
为什么：避免深度跳过导致大量无效扫描与高网络往返。
怎么用：
- 单库：延迟关联（先取主键后回表）、基于上一页最大 ID 的游标、`WHERE id > ? LIMIT N`。
- 跨分片：各分片超量抓取（limit*K）、应用层小根堆归并、游标推进。
关键细节：游标需稳定排序键；大 offset 昂贵；统一排序字段。
常见陷阱：直接拼接跨库 UNION 后排序。
面试提示：描述两层排序与归并复杂度与资源开销。
案例：全局倒序分页采用多分片超量抓取 + 小根堆，p95 降 50%。
速记：单库延迟/游标；分片先局部、应用归并。

### 1.5 统计与优化器（COUNT、ANALYZE、直方图、plan drift） [4]
是什么：统计体系（精确/近似计数）、统计刷新与直方图、计划漂移监控。
为什么：优化器基于统计估算成本；失真会选错索引路径。
怎么用：
- 精确 COUNT(*)；近似统计用汇总表/缓存；
- `ANALYZE TABLE` 刷新统计；为倾斜列建立直方图；
- 监控 plan drift 与强制索引的临时使用边界。
关键细节：直方图非自动更新；统计滞后影响 rows 估计；强制索引只救火。
常见陷阱：用 COUNT(1) 取巧；忽视统计刷新与数据倾斜。
面试提示：何时选择近似统计；如何判断统计失真并修复。
案例：创建直方图后优化器不再误选低效索引，延迟稳定。
速记：ANALYZE/Histogram；监控 plan；近似用汇总/缓存。

---

## 2. InnoDB 与事务锁

### 2.1 MVCC 与隔离级别 [5]
是什么：隐藏列 + undo 构建版本链的 MVCC；隔离级别 RU/RC/RR/Serializable 的并发语义。
为什么：提供一致性读、降低读写阻塞，权衡并发与一致性。
怎么用：RR 下快照读；当前读（for update）获取最新并加锁；分析查询可降级 RC。
关键细节：长事务阻塞 purge；undo 膨胀；幻读通过 Next-Key 锁防插入。
常见陷阱：在一个事务中混用快照与当前读导致预期外结果。
面试提示：阐述 RR/RC 快照差异与幻读处理。
案例：观测 History list length 激增后缩短事务边界，undo 回落。
速记：RR 默认；当前读加锁；长事务伤 purge。

#### MVCC 版本链详解
- 隐藏列：`trx_id` 标记事务，`roll_pointer` 指向 undo；
- 快照读：依据一致性视图（read view）选择可见版本，不加锁；
- 当前读：`SELECT ... FOR UPDATE/LOCK IN SHARE MODE` 获取最新并加锁；
- Purge：清理不可见旧版本，受长事务阻塞；
- 风险：同事务混用快照与当前读引发预期外结果，需规范读写路径。

### 2.2 锁类型与冲突诊断 [5]
是什么：Record/GAP/Next-Key/意向锁；死锁检测与等待链路分析。
为什么：保障范围一致性与并发控制，快速定位冲突根因。
怎么用：
- 统一加锁顺序；避免大范围条件；
- 用 `SHOW ENGINE INNODB STATUS` + Performance Schema 视图定位阻塞链路。
关键细节：意向锁不阻塞行锁；范围更新易扩大影响。
常见陷阱：无索引更新导致大范围锁与等待雪崩。
面试提示：展示标准排查脚本与顺序重排策略。
案例：统一更新顺序后死锁率从 0.8% 降至 0.05%。
速记：锁型清晰；顺序固定；用视图查链。

补充：锁矩阵速查
- 行锁(Record)：命中精确索引键的行更新/选择；冲突少，推荐。
- 间隙锁(Gap)：范围条件下防止插入到间隙，易扩大影响；注意索引与范围收窄。
- Next-Key：行+间隙，RR 下避免幻读；批量范围更新时常见。
- 意向锁：表级声明将要获取行锁，不与行锁直接冲突；用于多粒度协调。
排查脚本片段：
```sql
-- 阻塞链路
SELECT * FROM performance_schema.data_lock_waits;
SELECT * FROM information_schema.innodb_trx ORDER BY trx_started LIMIT 5;
SHOW ENGINE INNODB STATUS\G
```
修复路径：补索引（将范围转为精确行），统一更新顺序，减小批量，拆分热点为分桶。

#### 常见死锁场景与修复示例
- 场景：两个事务以不同顺序更新相同两行导致互相等待；
- 修复：固化更新顺序（按主键升序）、降低批次、改写为单语句批量更新；
- 观察：`LATEST DETECTED DEADLOCK` 中展示的持锁/等待锁对象与语句，作为重排依据。

### 2.3 长事务危害与缓解 [5]
是什么：长事务保持大量版本与锁，增加死锁与磁盘压力。
为什么：阻塞 purge/放大 undo/拖慢系统吞吐。
怎么用：拆批、缩短事务边界、异步化写、热点分桶与范围更窄。
关键细节：批次过大导致回滚成本高；异步需幂等保障。
常见陷阱：交互式会话长时间占用连接；单键热点计数。
面试提示：对比单行计数 vs 分桶累加的性能差异。
案例：热点计数拆 16 桶，冲突减少 90% 且吞吐提升。
速记：短事务；分桶；异步化；窄范围。

---

## 3. 数据访问层与连接池

### 3.1 连接池枯竭与泄漏排查 [4]
是什么：池参数调优与连接泄漏/慢借用定位。
为什么：保障高峰可用并避免资源枯竭事故。
怎么用：估算池大小；`leakDetectionThreshold`；统一 try-with-resources；监控 active/idle；`maxLifetime < DB 超时`。
关键细节：超大池增加竞争；老连接失效风险；未关闭 ResultSet/Statement 常见。
常见陷阱：事务边界跨网络调用；混乱路由导致半提交。
面试提示：线程 dump + pool metrics + SQL 慢点联动排查。
案例：订单导入长事务持连接 3 分钟，拆分批次后恢复。
速记：容量估算；自动关闭；寿命控制；看活跃/空闲。

### 3.2 ORM/MyBatis 的 N+1 与抓取/映射策略 [4]
是什么：惰性集合触发 N+1；抓取策略矩阵（fetch join/EntityGraph/batch-size/DTO 投影）与 MyBatis 嵌套映射。
为什么：减少往返与延迟，平衡一次性加载与按需查询。
怎么用：列表用 DTO/投影；详情用有限 fetch join；大集合用 batch-size；MyBatis 大集合用嵌套查询，小集合用嵌套结果。
关键细节：fetch join 过多导致笛卡尔爆炸；OSIV 反模式；ResultMap 映射准确。
常见陷阱：直接序列化实体树导致隐式懒加载；错误映射致 null。
面试提示：识别日志特征与修复路径；讲选择依据：集合大小 + 访问频率。
案例：商品页改 DTO + batch-size=50，QPS 降 35%。
速记：列表→投影；详情→有限 join；大集合→batch；映射要准。

### 3.3 参数化与注入防护（JDBC/MyBatis） [4]
是什么：预编译参数化复用执行计划，防止注入；JDBC/MyBatis 实践。
为什么：提升性能与安全性。
怎么用：外部输入统一 `#{}`；`${}` 仅用于受控对象名；排序字段白名单；开启驱动预编译缓存。
关键细节：动态拼接失效缓存；日志不回显敏感 SQL。
常见陷阱：`ORDER BY ${sort}` 无白名单引入注入。
面试提示：说明 `#{}` 优于 `${}`` 的安全与性能原因。
案例：预编译与缓存后重复查询延迟降 25%。
速记：参数化一切输入；白名单控动态；启用缓存。

---

## 4. 分库分表与一致性

### 4.1 分片与路由（槽位预留/聚合分页） [4]
是什么：按用户/时间/业务拆分与路由；跨分片聚合与分页策略。
为什么：突破单库容量与并发瓶颈，控制跨库开销。
怎么用：预留槽位便于再平衡；分片内局部排序，应用层归并。
关键细节：跨分片 JOIN 成本高；扩容再平衡影响写入。
常见陷阱：忽视槽位预留，扩容代价巨大。
面试提示：解释预留槽位与全局排序分页思路。
案例：预留 256 槽位便于横向扩容与再均衡。
速记：特征分片；预留槽位；局部+归并。

### 4.2 读写分离一致性（延迟阈值/关键读走主/GTID） [4]
是什么：读写分离下的延迟感知与关键读一致性保障。
为什么：最终一致不可避免，关键路径需避免脏读。
怎么用：在事务开始前决定路由；关键读强制主库；`seconds_behind_master` 超阈值切回主库；用 GTID 校验位置。
关键细节：读后写一致：读取后紧跟写需带主库标签或版本校验。
常见陷阱：下单后立即查订单走从库显示旧状态。
面试提示：给出关键读走主的实现与延迟阈值策略。
案例：支付结果查询强制主库，投诉率下降。
速记：关键读主；延迟监控；事务内不切源。

补充：关键读一致性落地清单
- 路由规则：事务开始前固定数据源；标记关键读 `Context.setCriticalRead(true)` 强制主库。
- 延迟阈值：当 `seconds_behind_master > X`（如 2s）全部切主；阈值恢复后再放开从库。
- GTID 校验：关键链路读取需要确认位点已覆盖（或以主库读替代）。
- 读后写一致：读取后如紧跟写操作，统一走主库或带版本号校验，避免不同源导致状态错乱。
示例（伪代码）：
```java
if (Context.isCriticalRead() || ReplicationLag.current() > 2) {
	Routing.use("MASTER");
} else {
	Routing.use("SLAVE");
}
```

#### GTID 与主从一致性详解
- GTID：每个事务拥有全局唯一标识，复制基于位点顺序，简化故障切换与一致性校验；
- 校验：关键读取需确认从库已应用到目标 GTID 集；否则回退主库；
- 风险：复制延迟/网络抖动导致 GTID 落后；在事务内禁止切源避免读写不一致。

### 4.3 分布式事务退化（TCC/Saga/Outbox） [4]
是什么：跨库两阶段退化为 TCC/Saga/Outbox + 幂等补偿。
为什么：降低复杂性与故障面，提升可靠性。
怎么用：同库事务记录事件（Outbox），CDC/轮询发布；消费端以业务唯一键幂等；Saga 设计补偿动作。
关键细节：至少一次投递需去重；状态机与乱序处理；失败重试与告警闭环。
常见陷阱：无幂等键导致重复扣减；Outbox 无监控导致消息丢失。
面试提示：订单与库存示例解释 Saga 与 Outbox 区别。
案例：订单创建 Outbox→Kafka→库存幂等扣减，避免重复扣。
速记：同库记事；消费幂等；补偿可回滚。

---

## 5. 高并发缓解与数据架构

### 5.1 缓存前置与旁路策略 [4]
是什么：Cache Aside 与一致性版本号策略，热点预热与击穿防护。
为什么：降低数据库 QPS 与行锁竞争，控制一致性窗口。
怎么用：读 miss 查库回填；写库后删缓存（必要时延迟双删）；热点预热与随机过期错峰；版本号比较避免并发覆盖。
关键细节：回填窗口与并发写冲突；版本增长与时钟漂移。
常见陷阱：先写缓存再写库导致脏读。
面试提示：解释删除优于更新的原因与版本号策略。
案例：热点命中率提升后数据库 QPS 降 40%。
速记：读走缓存；写删缓存；版本控一致。

#### 延迟双删与版本号策略详解
- 顺序：写库→删缓存→延迟再删（如 500ms）以覆盖并发窗口；
- 版本号：数据携带逻辑版本/时间戳，更新时比较版本避免覆盖旧值；
- 陷阱：先写缓存再写库导致脏读；延迟过长会扩大不一致窗口；
- 实战：高并发写入场景结合消息/队列通知从缓存侧主动失效。

### 5.2 批量写与写路径优化 [4]
是什么：多值 INSERT/批量 UPDATE 摊薄网络与日志/锁开销；控制批次大小与事务边界。
为什么：提升吞吐与资源利用率，降低锁持有时间。
怎么用：按 500~2000 行控制批次；预聚合后一次写入；评估 redo/Buffer 命中与回滚成本。
关键细节：过大批次易触发长事务与回滚慢；写读竞争需异步化与分桶。
常见陷阱：无限增大批次误以为越大越快。
面试提示：给出批次上限依据（锁等待、redo 写速率、页命中）。
案例：每 1000 条批次，TPS 提升 3.2x。
速记：批量摊成本；适中批次；边界清晰。

### 5.3 热点行拆分与分桶 [4]
是什么：单键热点计数/状态拆分为多桶以降低写竞争。
为什么：减少行锁争用，提升并发吞吐。
怎么用：Hash 分桶 + 周期汇总；读取聚合结果；范围更窄更新。
关键细节：读取需聚合与精度延迟；桶数与负载平衡。
常见陷阱：桶数过少仍热点；过多影响聚合成本。
面试提示：展示 TPS 提升与冲突下降数据。
案例：拆 32 桶，TPS +2.5x。
速记：拆热点→分桶；读聚合。

### 5.4 限流与降级 [4]
是什么：令牌桶/滑动窗口与队列削峰，保护核心路径。
为什么：避免峰值压垮数据库。
怎么用：低价值写降级或拒绝；队列满直接拒绝；审计与告警闭环。
关键细节：降级策略需明确记录与可追溯；避免静默失败。
常见陷阱：降级无审计造成黑洞。
面试提示：给出日志写入降级方案与触发条件。
案例：峰值改削峰+限流后系统稳定无崩溃。
速记：限流削峰；满即拒；有审计。

### 5.5 数据模型与约束（规范化/反规范化/时区/金额） [3]
是什么：在高并发读写下的数据建模原则与约束体系落地（结构化字段、规范化/反规范化取舍、时区策略、金额精度）。
为什么：模型与约束决定查询/更新成本与正确性，直接影响热点路径性能与一致性。
怎么用：
- 热路径适度反规范化：冗余少量高频展示/过滤列，异步回填与校验；
- 字段选型：ID 用 `BIGINT`（雪花/号段），金额用 `DECIMAL(18,2)`；文本慎用 `TEXT`；
- 时区策略：统一存 UTC/epoch，展示层转换；
- 约束策略：UNIQUE/NOT NULL/CHECK 覆盖关键字段；外键在高并发写慎用，改应用层校验 + 对账；
关键细节：UTF8MB4 影响索引前缀长度；`BigDecimal` 构造用字符串或 `valueOf`，除法必须指定 `scale`+`RoundingMode`；软删除需索引/过滤配合。
面试提示：让候选人用一个“交易表冗余用户等级减少 JOIN”的例子说明反规范化收益与一致性保障。
案例：热门报表冗余用户等级字段，读路径减少 JOIN，p95 降 30%；后台异步纠偏维持一致性。
速记：热路径少量冗余；UTC 存储；金额用 DECIMAL；强约束稳数据。

### 5.6 监控与容量规划（基线/关键指标/外推） [3]
是什么：数据库性能监控三板斧与容量外推（QPS/TPS、慢查询模板、Buffer Pool 命中率）。
为什么：持续感知性能与风险，指导索引/架构调整与提前扩容。
怎么用：
- 建立压测/生产基线：记录并发、QPS、P95/P99；
- 指标看板：慢 SQL 模板聚合（按指纹），命中率 <90% 预警，秒级主从延迟监控；
- 容量外推：基于命中率/CPU/IOPS 趋势预测安全阈值触达时间，提前加节点或分片；
关键细节：分位数优于平均值；命中率下滑常见于数据集扩大/缓冲不足；慢查询区分偶发 vs 结构性问题；
面试提示：让候选人解释一次“命中率跌至 85%”的定位与缓解过程（归档/缓存/只读副本）。
案例：命中率与 CPU 趋势外推至阈值，提前扩容与归档，避免高峰故障。
速记：建基线；看慢查+命中率；趋势外推提前扩容。

### 5.7 安全与数据质量（最小权限/注入/审计/软删） [2]
是什么：权限收敛、参数化防注入、全量审计与软删除策略。
为什么：降低攻击面与误操作风险，提升可恢复性与合规。
怎么用：
- 最小权限：按角色授权，禁止 `*.*`；危险操作受控；
- 注入防护：JDBC/MyBatis 统一 `#{}` 参数化，动态对象名白名单；
- 审计与操作日志：慢 SQL/DDL/权限变更集中采集与分析；
- 软删除：`is_deleted` + 周期物理清理 + 索引与查询过滤配合；
关键细节：日志脱敏；操作留痕可追溯；软删在高并发查询需索引设计避免扫描放大。
面试提示：给一个“ORDER BY ${sort}”注入修复与白名单设计的示例。
案例：权限从全库收敛到按库按表最小集，审计风险显著下降；统一参数化后注入面消除。
速记：最小权限；参数化一切输入；全量审计；软删配索引。

### 5.8 迁移与在线变更（字符集/Online DDL/双写） [2]
是什么：不影响业务的架构/表结构迁移：字符集与 SQL 模式调整、Online DDL（gh-ost/pt-osc）、双写灰度切流。
为什么：大表直改风险高；需在不停机与低风险下演进。
怎么用：
- 字符集/SQL 模式：评估兼容性→灰度→备份与回滚预案；
- Online DDL：影子表复制 + 增量捕获 → 原子切换；
- 双写迁移：新旧库并行写入，持续对账校验一致后切流；
关键细节：索引长度变化与排序规则差异；触发器/复制延迟；双写延迟/冲突与幂等；
面试提示：为什么不能直接 ALTER 大表；如何设计切换的验证与回滚。
案例：gh-ost 迁移千万行在线完成；双写两周一致后平滑切换。
速记：评估→灰度→影子表在线改→一致后切流。




## 19. 面试常见问答速览 [2]
1. 联合索引顺序重要性：最左前缀决定可利用性与覆盖潜力。  
2. MVCC 可重复读：版本链 + undo 快照视图；当前读需锁。  
3. 大分页慢：深度扫描跳过行 → 使用游标/延迟关联。  
4. N+1 查询：惰性加载集合迭代触发多次 select → fetch join / batch。  
5. 主从延迟脏读避免：关键读走主库 + 延迟阈值判定回退。  
6. 分库全局排序：各分片取超量结果 → 小根堆归并。  
7. UUID 主键性能差：随机写导致页分裂与缓存局部性差。  

---

## 附录：重要度汇总（参考）
- SQL 执行计划与索引优化 [5]  
- InnoDB 索引/MVCC/锁/隔离级别 [5]  
- 事务与锁冲突诊断 [5]  
- 连接池配置与泄漏排查 [4]  
- ORM 性能与抓取策略 [4]  
- MyBatis 动态 SQL 与插件 [4]  
- 分库分表与读写分离 [4]  
- 数据一致性与幂等策略 [4]  
- 索引调优与执行计划案例 [4]  
- 高并发数据库负载缓解 [4]  
- 模型与结构规范 [3]  
- 数据库监控指标 [3]  
- 与缓存协同策略 [3]  
- 性能测试与容量规划 [3]  
- 常见故障诊断与恢复 [3]  
- 数据质量与约束 [2]  
- 迁移与在线变更 [2]  
- 安全与权限控制 [2]  
- Native ID 与主键策略优化 [3] (补充)  
- 面试问答速览 (辅助) [2]  

