# 数据访问与数据库面试指南（扩展深化版）

评分：5=必须掌握，4=很重要，3=熟练更佳，2=了解即可，1=加分项  
结构：单条聚焦一个知识点，按“是什么 / 为什么 / 怎么用 / 关键细节 / 面试提示”展开，便于追问。

---

## 1. SQL 基础与查询优化方法论 [5]

### 1.1 EXPLAIN 结果解读框架
- 是什么：EXPLAIN 输出列 (id/select_type/table/type/possible_keys/key/key_len/ref/rows/filtered/Extra) 描述语句的执行路径与代价估计。  
- 为什么：判断是否命中合适索引、是否存在全表扫描 / 回表 / 额外排序 / 临时表。  
- 怎么用：先看 type（目标 ≥ range / ref / eq_ref / const）；再看 key 是否预期；rows 估计是否过大；Extra 是否出现 Using filesort / Using temporary / Using where / Using index。  
- 关键细节：rows 为估算值依赖统计信息；key_len 用于判断索引利用到的前缀长度；多个同级 id 代表独立子查询，id 递减通常嵌套。  
- 面试提示：能快速指出“为何出现 Using filesort”以及给出覆盖索引或索引顺序调整策略。

### 1.2 访问类型优先级与目标
- 是什么：MySQL 访问路径类型：const/system > eq_ref > ref > range > index > ALL。  
- 为什么：越靠前说明扫描行数越少、选择性越高，执行效率更好。  
- 怎么用：通过索引设计（选择性、高区分度列前置、减少模糊/函数包裹）提升到 ref / range 级别以上。  
- 关键细节：const 多用于主键或唯一索引等值；range 用于 BETWEEN、>、<、前缀匹配；index 仅走索引全扫描仍可能高 IO；ALL 为全表扫描需警惕。  
- 面试提示：描述从 ALL 优化到 range/ref 的迭代过程与调整手段。

### 1.3 索引设计五步法
- 是什么：识别查询模式 → 提取过滤/排序/连接列 → 分析选择性 → 联合索引最左原则 → 验证覆盖与回表。  
- 为什么：系统化避免“拍脑袋建索引”与冗余索引写放大。  
- 怎么用：统计 distinct 值、观察 WHERE + ORDER BY + JOIN 条件；统一列顺序：高选择性前置 + 排序/范围列后置。  
- 关键细节：范围条件后续列失效（>、BETWEEN）；前缀索引需兼顾选择性与存储；覆盖索引减少回表 (Using index)。  
- 面试提示：给出一个错误联合索引示例并说明浪费原因。

### 1.4 常见查询反模式与规避
- 是什么：SELECT *、对索引列使用函数、隐式类型转换、OR 多分支未建索引、长 IN 列表、滥用 DISTINCT。  
- 为什么：导致索引失效、扫描行数膨胀、CPU 过滤成本增高。  
- 怎么用：显式列清单；避免函数包裹（改为预处理或冗余列）；拆 OR 为 UNION；缩短 IN（引入中间表或临时标识）；用 group by 规划代替 DISTINCT。  
- 关键细节：隐式转换（字符串 vs 数值）会触发全表扫描；DISTINCT+多列排序可能额外临时表。  
- 面试提示：快速定位“为什么这条语句走 ALL”。

### 1.5 大分页优化
- 是什么：limit offset 大时扫描行需跳过大量记录造成深度回表。  
- 为什么：无效扫描 IO 浪费，响应时间指数上升。  
- 怎么用：延迟关联（先取主键再回表），基于上一页最大 ID 游标，或采用“WHERE id > ? LIMIT N”滚动窗口。  
- 关键细节：游标策略需稳定排序键且避免跳跃；延迟关联让覆盖索引先筛选。  
- 面试提示：指出“单纯加索引无法解决 offset=100000 的慢分页”。

### 1.6 COUNT 与统计优化
- 是什么：COUNT(*) 精确统计；近似统计基于信息_schema / 预聚合表。  
- 为什么：超大表全表 COUNT 代价高；部分业务仅需近似数据展示。  
- 怎么用：定时维护汇总表、使用缓存层、对热点范围做分桶计数。  
- 关键细节：COUNT(*) 与 COUNT(列) 差异；COUNT(主键) 等价 COUNT(*)；COUNT(1) 无性能魔法。  
- 面试提示：阐述“场景驱动选择精确 vs 近似”。

### 1.7 写读竞争与批量写策略
- 是什么：写操作与读频繁竞争锁或造成缓冲池抖动。  
- 为什么：大事务锁持有时间长，阻塞其他会话。  
- 怎么用：拆分大事务、批次提交（合适 batch size）、控制行级锁范围、引入异步队列写。  
- 关键细节：过度拆分提升事务数量与日志开销需平衡；批量插入 VALUES 多行语句能显著减少往返。  
- 面试提示：描述一次“长事务 → 拆分缓解”案例。

### 1.8 索引统计信息维护
- 是什么：优化器根据统计信息估算成本决定执行计划。  
- 为什么：统计失真导致错误索引选择或回表放大。  
- 怎么用：ANALYZE TABLE、直方图 (Histogram) 对低基数异常分布列提升选择性判断。  
- 关键细节：频繁小更新表统计可能滞后；直方图非自动更新。  
- 面试提示：说明“执行计划不稳定”的根源与修复手段。

---

## 2. MySQL 存储引擎与索引结构 (InnoDB) [5]

### 2.1 B+ 树聚簇索引机制
- 是什么：主键索引叶节点存整行数据（聚簇），二级索引叶节点存主键指针。  
- 为什么：主键范围查询顺序 IO 友好；减少额外回表层次。  
- 怎么用：合理设计单调递增主键减少页分裂；避免频繁随机写。  
- 关键细节：页大小 16KB；页分裂产生碎片；二级索引访问需二次查主键。  
- 面试提示：说明“为什么覆盖索引能避免回表”。

### 2.2 主键选择策略
- 是什么：自增、雪花算法、UUID、数据库号+序列组合。  
- 为什么：影响写入局部性与页分裂、缓存命中率。  
- 怎么用：高并发分布式多节点使用雪花（时钟回拨处理）；尽量避免纯随机 UUID。  
- 关键细节：UUID v4 随机性高导致频繁页分裂；可用 UUID v1/v7 或顺序号替代；批量插入前排序提升局部性。  
- 面试提示：分析“换主键后慢查询减少”的原因。

### 2.3 MVCC 实现
- 是什么：通过隐藏列 trx_id/roll_pointer + undo log 构建版本链，提供一致性读。  
- 为什么：减少读写阻塞，提高并发吞吐。  
- 怎么用：REPEATABLE READ 下使用快照版本；当前读（for update）加锁获取最新。  
- 关键细节：长事务保留旧版本阻塞 purge；undo 空间膨胀；快照不含当前未提交。  
- 面试提示：说明“幻读为何需要 Next-Key Lock”与 MVCC 关系。

### 2.4 隔离级别与幻读处理
- 是什么：四级隔离：READ UNCOMMITTED / READ COMMITTED / REPEATABLE READ / SERIALIZABLE。  
- 为什么：权衡并发性能与一致性。  
- 怎么用：默认 REPEATABLE READ；某些分析查询可降级 READ COMMITTED。  
- 关键细节：REPEATABLE READ 通过一致性视图避免不可重复读；幻读通过间隙 + Next-Key 锁防止插入。  
- 面试提示：阐述“REPEATABLE READ 与 READ COMMITTED 的快照差异”。

### 2.5 锁类型与意向锁
- 是什么：行锁 (Record Lock)、间隙锁 (Gap Lock)、Next-Key（行+间隙），意向锁协调多粒度。  
- 为什么：防止幻读与维护范围一致性；提高并发分级管理。  
- 怎么用：范围更新注意间隙锁扩大影响；减少大范围条件。  
- 关键细节：意向锁不会阻塞行锁申请；锁冲突诊断用 information_schema + ENGINE STATUS。  
- 面试提示：给出“插入被 gap 锁阻塞”排查思路。

### 2.6 索引条件下推 (ICP) 与索引合并
- 是什么：ICP 在索引扫描阶段提前过滤；Index Merge 利用多个单列索引组合结果。  
- 为什么：减少回表行数与 CPU 过滤量。  
- 怎么用：保持条件可在索引字段直接计算；避免函数包裹。  
- 关键细节：Index Merge 并不一定优于构建联合索引；ICP 受限于存储引擎与条件可下推性。  
- 面试提示：说明“何时不应依赖 Index Merge 而是重建联合索引”。

### 2.7 页分裂与碎片整理
- 是什么：插入导致页空间不足触发分裂；产生物理碎片降低顺序扫描性能。  
- 为什么：影响缓存效率与范围查询性能。  
- 怎么用：使用顺序主键、周期 OPTIMIZE TABLE 重建、在线 DDL 评估风险。  
- 关键细节：OPTIMIZE 会重建表占用额外空间并潜在锁表；需低峰执行。  
- 面试提示：解释“碎片过多如何观察与缓解”。

### 2.8 统计信息误差与执行计划不稳定
- 是什么：选择性估算不准导致错误索引路径。  
- 为什么：数据倾斜、高更新频度、统计未刷新。  
- 怎么用：ANALYZE TABLE、直方图为倾斜列建立分布；监控 plan drift。  
- 关键细节：执行计划缓存并不总稳定；强制索引仅临时手段。  
- 面试提示：给出“强制索引 vs 修复统计”取舍。

---

## 3. 事务与锁冲突诊断 [5]

### 3.1 长事务危害
- 是什么：事务持续时间过长保持大量行版本与锁。  
- 为什么：阻塞 purge，undo 膨胀，增加死锁概率。  
- 怎么用：拆分批处理、控制交互时间、避免交互式客户端长时间 idle。  
- 关键细节：show processlist 与 INNODB_TRX 观察；设置合理事务超时。  
- 面试提示：描述一次“长事务造成磁盘压力”的分析。

### 3.2 死锁检测与处理
- 是什么：InnoDB 自带死锁检测回滚最小成本事务。  
- 为什么：防止无限等待；维持系统吞吐。  
- 怎么用：SHOW ENGINE INNODB STATUS 阅读死锁图；优化加锁顺序。  
- 关键细节：批量操作顺序一致性、避免大范围锁；行级锁升级风险。  
- 面试提示：阐述“如何通过重排更新顺序减少死锁”。

### 3.3 锁等待排查
- 是什么：LOCK_WAITS / INNODB_TRX 视图与 Performance Schema 分析阻塞链路。  
- 为什么：快速定位热点冲突与慢 SQL 根源。  
- 怎么用：查询阻塞事务、截取 SQL、评估索引与访问范围。  
- 关键细节：阻塞通常来自范围条件 + 未命中索引；需区分行锁 vs gap 锁。  
- 面试提示：展示标准排查脚本或步骤。

### 3.4 常见冲突场景
- 是什么：范围更新 + 插入（间隙锁阻塞）；批量更新锁持久；主键热点计数。  
- 为什么：高并发写集中在少数键或范围。  
- 怎么用：拆分热点（分桶）、逻辑分片、乐观锁版本控制。  
- 关键细节：乐观锁需处理重试与冲突统计；分桶需查询聚合二次整合。  
- 面试提示：说明“热点行拆分到多行”策略收益。

### 3.5 降低冲突设计
- 是什么：减少写集中度、缩短锁持有周期。  
- 为什么：提升并发吞吐与响应时间稳定性。  
- 怎么用：写操作异步化、行级累加改为分桶 + 周期聚合、减少大范围扫描更新。  
- 关键细节：异步写需幂等保障；分桶聚合需校验精度误差。  
- 面试提示：对比“直接单行计数 vs 分桶累加”的性能差异。

---

## 4. 连接池与资源管理 (HikariCP 等) [4]

### 4.1 核心参数调优
- 是什么：maximumPoolSize、connectionTimeout、idleTimeout、maxLifetime、minimumIdle 控制池容量与连接生命周期。  
- 为什么：保证高峰可用连接同时避免死连接与泄漏。  
- 怎么用：基于并发请求数、平均占用时长估算池大小；maxLifetime < 数据库端连接回收时间。  
- 关键细节：超大池反而增加竞争；maxLifetime 太长导致老连接失效风险。  
- 面试提示：给出“估算池大小公式”：并发线程 * 平均占用秒 / (期望利用率因子)。

### 4.2 连接耗尽排查
- 是什么：池中无可用连接且请求等待超时。  
- 为什么：未释放资源、长事务、阻塞线程持有连接。  
- 怎么用：线程 dump + pool metrics + leakDetectionThreshold；确认是否忘记关闭 ResultSet/Statement。  
- 关键细节：try-with-resources 管理；监控“active vs idle”差距。  
- 面试提示：描述一次真实“连接耗尽”定位过程。

### 4.3 PreparedStatement 缓存与参数化
- 是什么：客户端或服务器端缓存预编译执行计划。  
- 为什么：降低重复解析与优化成本。  
- 怎么用：合理设置 JDBC 驱动缓存；避免多态 SQL 拼接。  
- 关键细节：过度动态拼接失效缓存；数据库侧可能有语句缓存上限。  
- 面试提示：说明“为什么 #{} 优于 ${}”安全与性能。

### 4.4 多数据源与路由一致性
- 是什么：基于 AbstractRoutingDataSource 动态选择数据源。  
- 为什么：读写分离 / 租户隔离 / 灰度迁移。  
- 怎么用：在事务开始前确定路由，避免中途切换；关键写强制主库。  
- 关键细节：跨数据源事务一致性风险；需业务补偿。  
- 面试提示：指出“在事务内动态切换数据源”是常见陷阱。

---

## 5. ORM (JPA/Hibernate) 缓存与抓取策略 [4]

### 5.1 实体生命周期与一级缓存
- 是什么：Transient → Persistent（Session 管理）→ Detached（脱离会话）→ Removed。一级缓存作用域为 Session。  
- 为什么：减少重复查询与合并脏数据自动 flush。  
- 怎么用：控制 Session 范围（避免长会话）；批量操作拆分 flush。  
- 关键细节：脏检测基于快照比对；过多持久对象导致内存膨胀。  
- 面试提示：解释“为什么批量 insert 需分批 clear()”。

### 5.2 N+1 查询成因与解决
- 是什么：访问懒加载集合在迭代时触发逐条额外 select。  
- 为什么：导致大量往返与延迟放大。  
- 怎么用：fetch join、EntityGraph、batch-size、DTO 定制查询。  
- 关键细节：fetch join 数量过多引发笛卡尔爆炸；批量抓取需配置合理 batch-size。  
- 面试提示：快速识别日志中 N+1 迹象。

### 5.3 抓取策略与 Lazy 初始化异常
- 是什么：EAGER / LAZY 决定关联加载时机；Lazy 在 Session 关闭后访问抛异常。  
- 为什么：过度 EAGER 引发“全量图”加载；性能退化。  
- 怎么用：只对确实频繁使用的关联设 EAGER；服务层内控制访问完毕。  
- 关键细节：开放 Session in View 反模式导致延迟查询不可控。  
- 面试提示：提供安全的 DTO 转换策略。

### 5.4 二级缓存使用边界
- 是什么：会话外共享缓存区域对实体或查询结果存储。  
- 为什么：减少重复读取静态/低变更数据。  
- 怎么用：配置 CacheRegion 策略（read-only / nonstrict-read-write / transactional）。  
- 关键细节：高频写实体不宜缓存；失效策略与并发一致性要明确。  
- 面试提示：回答“什么场景不要用二级缓存”。

### 5.5 乐观锁与并发更新
- 是什么：@Version 字段变更检测冲突，失败抛异常。  
- 为什么：避免行级悲观锁长时间阻塞。  
- 怎么用：在更新时自动检查版本；失败后重试或提示用户。  
- 关键细节：批量更新绕过版本检查需谨慎；版本字段类型（long / int / timestamp）。  
- 面试提示：区分乐观与悲观锁适用场景。

### 5.6 DTO 投影与性能
- 是什么：选择性字段映射避免加载整实体树。  
- 为什么：减少内存与序列化成本。  
- 怎么用：JPQL/Criteria 构造自定义查询；Spring Data Projection。  
- 关键细节：投影不触发懒加载集合；避免多层嵌套对象。  
- 面试提示：说明“为什么返回实体直接 JSON 序列化风险”。

---

## 6. MyBatis 动态 SQL / 插件机制 [4]

### 6.1 动态标签构建
- 是什么：<if>/<choose>/<trim>/<foreach> 构造灵活条件与批量语句。  
- 为什么：减少字符串拼接错误与 SQL 注入风险。  
- 怎么用：在 foreach 中使用 separator 管理逗号；trim 去除多余 AND/OR。  
- 关键细节：逻辑复杂时建议拆成多 mapper 方法；避免巨大 XML 可维护性差。  
- 面试提示：展示一个易错“多余 AND”修复示例。

### 6.2 一级/二级缓存差异
- 是什么：一级缓存作用于 SqlSession；二级缓存基于 Namespace。  
- 为什么：提升重复查询效率，降低数据库压力。  
- 怎么用：合理设置刷新条件；事务提交后二级缓存生效。  
- 关键细节：更新操作自动使相关缓存失效；谨慎缓存动态条件查询结果。  
- 面试提示：说明“为何长时间未命中二级缓存”可能原因。

### 6.3 拦截器扩展点
- 是什么：Executor / StatementHandler / ParameterHandler / ResultSetHandler 四大接口。  
- 为什么：实现分页、审计、字段加解密、SQL 规约。  
- 怎么用：链式注册，控制执行顺序；避免过度修改原 SQL。  
- 关键细节：性能敏感路径中拦截器逻辑需轻量；线程安全与并发。  
- 面试提示：区分分页插件与数据库原生 limit 差异。

### 6.4 参数绑定安全
- 是什么：#{} 使用预编译参数；${} 直接字符串拼接。  
- 为什么：防止 SQL 注入与复用执行计划。  
- 怎么用：所有外部输入使用 #{}；只有动态对象名场景谨慎使用 ${}。  
- 关键细节：动态排序字段白名单；避免注入绕过。  
- 面试提示：给出一个错误 ${} 使用的注入例子。

### 6.5 association/collection 映射策略
- 是什么：嵌套结果 vs 嵌套查询加载关联对象。  
- 为什么：平衡一次性加载与按需查询。  
- 怎么用：复杂关联用嵌套结果减少往返；超大集合惰性加载。  
- 关键细节：嵌套查询可能导致 N+1；ResultMap 正确 column-to-property 映射防止 null。  
- 面试提示：谈选择依据：集合大小 + 访问频率。

---

## 7. 分库分表与读写分离策略 [4]

### 7.1 分片维度与路由算法
- 是什么：按用户ID / 时间 / 地理 / 业务域拆分；算法取模、范围、哈希、一致性哈希。  
- 为什么：突破单库容量与并发瓶颈。  
- 怎么用：规划未来扩容槽位；元数据中心统一管理。  
- 关键细节：跨分片 JOIN 成本高；扩容再平衡影响写入。  
- 面试提示：解释“为什么预留空槽位方便扩容”。

### 7.2 全局唯一 ID 方案
- 是什么：雪花算法、数据库序列、Redis incr、UUID、有序号段分配。  
- 为什么：保证唯一性与可排序性支持分页/归档。  
- 怎么用：雪花需时钟漂移检测；号段预分配减少集中争抢。  
- 关键细节：时钟回拨处理：等待/开保护模式；ID 结构（时间位 + 机器位 + 序列位）。  
- 面试提示：说明“雪花 vs UUID 性能与索引局部性”。

### 7.3 跨分片聚合与分页
- 是什么：在每个分片执行局部查询 → 结果归并排序 → 截断。  
- 为什么：减少跨库吞吐影响与网络往返。  
- 怎么用：超量抓取（limit * 分片数）、分层归并（小根堆维护 top-N）。  
- 关键细节：大 offset 跨分片代价高；需游标或顺序键推进。  
- 面试提示：给出“全局排序分页”实现思路。

### 7.4 主从复制延迟补偿
- 是什么：读写分离导致从库数据滞后。  
- 为什么：最终一致复制非实时。  
- 怎么用：关键读取强制主库；延迟阈值监控 seconds_behind_master；GTID 确认位置。  
- 关键细节：读后写一致性：读后立即写需校验来源库；标记性请求强制主读。  
- 面试提示：说明“避免用户看到旧订单状态”策略。

### 7.5 分布式事务退化
- 是什么：跨库两阶段成本高与复杂性大。  
- 为什么：降低吞吐与提升故障面。  
- 怎么用：TCC/Saga/Outbox + 异步补偿；尽量边界内聚。  
- 关键细节：补偿需幂等；消息投递保证至少一次与重复抑制。  
- 面试提示：用一个订单与库存示例解释 Saga。

---

## 8. 数据一致性模式与策略 [4]

### 8.1 强一致 vs 最终一致决策
- 是什么：强一致保证读取立即反映最新写；最终一致允许延迟收敛。  
- 为什么：按业务对实时性与性能权衡。  
- 怎么用：核心计费/交易采用强一致；统计 / 推荐采用最终一致。  
- 关键细节：最终一致需定义可接受窗口与补偿机制。  
- 面试提示：给出“选择最终一致的理由”而非泛泛。

### 8.2 缓存双写与失效策略
- 是什么：更新数据库与缓存保持一致的顺序策略。  
- 为什么：避免读取到脏数据或缓存穿透。  
- 怎么用：写库 → 删缓存；或延迟双删：写库后删缓存 + 延迟再删。  
- 关键细节：并发写与读竞争窗口；可用版本号或逻辑时间戳。  
- 面试提示：指出“先写缓存再写库”风险。

### 8.3 Outbox Pattern
- 是什么：在同一数据库事务内记录事件表，后续异步可靠发布。  
- 为什么：避免 DB 与消息系统分布式事务。  
- 怎么用：轮询/CDC 提取事件 → 发布消息 → 标记发送成功。  
- 关键细节：去重、重试幂等、发送失败告警。  
- 面试提示：解释与普通异步写消息区别。

### 8.4 幂等设计
- 是什么：重复执行结果不变。  
- 为什么：抵抗重试、网络抖动、消息至少一次投递。  
- 怎么用：幂等键表 / 唯一索引 / 状态机严格前置。  
- 关键细节：区分“写入 vs 查询”幂等；非幂等操作需隔离。  
- 面试提示：给出充值接口防重复示例。

### 8.5 分布式锁选型
- 是什么：数据库悲观锁 / Redis SET NX PX / RedLock / ZK。  
- 为什么：控制跨节点互斥操作。  
- 怎么用：Redis 锁需续租 watchdog；超时释放策略；防误删用随机 token。  
- 关键细节：单实例 Redis 锁可靠性不足；RedLock 争议与时钟。  
- 面试提示：说明“业务是否真的需要分布式锁”。

---

## 9. 索引与执行计划调优案例 [4]

### 9.1 联合索引列顺序原则
- 是什么：高区分度列 + 等值条件列前置，范围列后置。  
- 为什么：提高过滤效率与减少回表。  
- 怎么用：分析查询频度与条件类型；利用 show index 和统计。  
- 关键细节：范围列后续索引失效；覆盖索引优先。  
- 面试提示：举一个错误顺序案例。

### 9.2 覆盖索引避免回表
- 是什么：查询所需列全部在二级索引叶子节点。  
- 为什么：减少主键回表 IO。  
- 怎么用：SELECT 精简列集合；创建包含频繁查询字段的复合索引。  
- 关键细节：过宽索引影响写性能与内存；适度。  
- 面试提示：说明添加无必要列的成本。

### 9.3 条件重写优化
- 是什么：将 OR 转 UNION ALL（再外层合并）、函数包裹列改为预处理值。  
- 为什么：让优化器使用索引路径。  
- 怎么用：提取列运算到应用层；使用派生列。  
- 关键细节：UNION 与 UNION ALL 的去重差异；可能需额外排序。  
- 面试提示：快速识别函数阻塞索引案例。

### 9.4 统计过期与直方图
- 是什么：Histogram 提升低基数或倾斜列选择性判断精度。  
- 为什么：避免优化器误选低效索引。  
- 怎么用：ANALYZE TABLE 之后创建直方图；监控 plan 变化。  
- 关键细节：过度直方图维护成本；需更新触发。  
- 面试提示：说明“如何判断统计失真”。

---

## 10. 高并发下数据库负载缓解 [4]

### 10.1 读写分层与缓存前置
- 是什么：热点读走缓存，异步写后台入库。  
- 为什么：降低数据库 QPS 与行锁竞争。  
- 怎么用：缓存旁路模式，写操作延迟刷新。  
- 关键细节：一致性窗口与补偿回写；失败重试策略。  
- 面试提示：衡量读写比例与数据新鲜度要求。

### 10.2 批量写与吞吐提升
- 是什么：多行 INSERT / 批量更新减少往返与日志开销。  
- 为什么：单条执行带来网络与解析放大。  
- 怎么用：控制批次大小（防止锁范围过大）；预聚合后一次性写入。  
- 关键细节：过大批次导致事务延迟与回滚成本高。  
- 面试提示：选择批次 size 的依据。

### 10.3 热点行拆分
- 是什么：将单行计数/状态拆分为多行或分桶。  
- 为什么：降低单键写竞争与行锁争用。  
- 怎么用：Hash 分桶 + 周期汇总；或随机桶。  
- 关键细节：读取需聚合；考虑精度延迟。  
- 面试提示：展示 TPS 提升数据。

### 10.4 限流与降级策略
- 是什么：对低价值写拒绝或延迟执行，保护核心路径。  
- 为什么：避免峰值压垮数据库。  
- 怎么用：令牌桶 / 滑动窗口 + 队列削峰；队列满直接拒绝。  
- 关键细节：降级时需审计与告警；避免静默失败。  
- 面试提示：给出“日志写入降级”方案。

### 10.5 数据冷热分离与归档
- 是什么：将历史数据迁移到低成本存储或分库。  
- 为什么：减少主库索引与扫描范围。  
- 怎么用：时间分区表、定期归档任务、只读副本。  
- 关键细节：查询跨冷热时路由；避免频繁冷热往返。  
- 面试提示：归档对成本与性能的双重收益。

---

## 11. 数据模型与规范 [3]

### 11.1 正规化 vs 反规范化
- 是什么：正规化减少冗余；反规范化提升读取性能。  
- 为什么：平衡写复杂度与读效率。  
- 怎么用：热路径增加冗余字段，后台异步同步源表。  
- 关键细节：冗余更新一致性；避免过度 join。  
- 面试提示：一个合理“适度反规范化”案例。

### 11.2 字段类型与长度选择
- 是什么：按数据范围选用 INT/BIGINT/DECIMAL/VARCHAR。  
- 为什么：存储空间与比较性能优化。  
- 怎么用：避免 TEXT 滥用；金额用 DECIMAL；枚举用 tinyint 映射表。  
- 关键细节：UTF8MB4 长度影响索引前缀；过宽字段影响页利用率。  
- 面试提示：说明“为什么不用 DOUBLE 存货币”。

### 11.3 时间字段与时区策略
- 是什么：TIMESTAMP 自动时区转换；DATETIME 原始表示。  
- 为什么：跨时区显示与排序需求。  
- 怎么用：统一存 UTC（TIMESTAMP/epoch），展示层转换。  
- 关键细节：DST 影响调度；避免本地时间直接比较。  
- 面试提示：回答“跨时区报表如何实现”。

### 11.4 枚举与版本演进
- 是什么：列值集合变化管理方式。  
- 为什么：业务迭代需灵活扩展。  
- 怎么用：tinyint + 映射表；或 enum 谨慎（修改成本）。  
- 关键细节：枚举语义文档化；避免魔法数字。  
- 面试提示：举例“不当使用 enum 导致迁移困难”。

---

## 12. 数据库监控与指标 [3]

### 12.1 核心性能指标
- 是什么：QPS/TPS、Slow Query、Buffer Pool 命中率。  
- 为什么：反映吞吐、延迟、缓存效率。  
- 怎么用：设阈值告警，聚合慢 SQL 模板。  
- 关键细节：命中率下降 → 页淘汰频繁；慢查询需区分偶发 vs 结构性。  
- 面试提示：说明“命中率 < 90%”排查路径。

### 12.2 连接与线程状态
- 是什么：SHOW PROCESSLIST / Performance Schema 线程执行情况。  
- 为什么：识别阻塞、睡眠、锁等待线程。  
- 怎么用：采样线程状态分布；定位 top blocking。  
- 关键细节：过多空闲连接浪费资源；队列堆积与连接耗尽联动。  
- 面试提示：展示一次“排查线程等待链”思路。

### 12.3 InnoDB 内部资源
- 是什么：Buffer Pool、Redo/Undo、行锁等待。  
- 为什么：支撑事务与 IO 性能。  
- 怎么用：监控 redo 写延迟、undo 膨胀、锁等待时间。  
- 关键细节：Buffer Pool 不足 → 频繁磁盘 IO；undo 清理滞后受长事务影响。  
- 面试提示：结合 innodb_metrics 指标说明问题定位。

### 12.4 复制延迟与重试
- 是什么：主从 seconds_behind_master、延迟队列、失败重试统计。  
- 为什么：评估读写分离一致性风险。  
- 怎么用：超过阈值触发切回主库；指标上报。  
- 关键细节：GTID 顺序保证；延迟波动需网络/IO 分析。  
- 面试提示：解释“延迟峰值的根因”分析步骤。

---

## 13. 常见故障与恢复 [3]

### 13.1 主库故障切换
- 是什么：检测主库不可用 → 自动/人工提升从库。  
- 为什么：保证高可用与业务连续性。  
- 怎么用：半同步复制减少数据漂移；GTID 简化位点定位。  
- 关键细节：脑裂风险；延迟窗口数据丢失评估。  
- 面试提示：说明“切换后数据一致性验证”方法。

### 13.2 大事务回滚
- 是什么：包含大量行的事务失败需撤回。  
- 为什么：回滚需要逐行恢复，耗时长。  
- 怎么用：拆分批处理；预检查条件；模拟 dry run。  
- 关键细节：undo 空间膨胀；锁持有时间延长。  
- 面试提示：给出避免策略。

### 13.3 误删与闪回
- 是什么：删除表/行后通过 binlog 或延迟复制恢复。  
- 为什么：减少人为操作造成不可逆损失。  
- 怎么用：定期全量备份 + 增量 binlog；point-in-time restore。  
- 关键细节：恢复窗口与最大可接受丢失；脚本自动化。  
- 面试提示：强调“恢复演练”的重要性。

### 13.4 索引失效突增
- 是什么：计划突然走全表扫描或错误索引。  
- 为什么：统计失真 / 查询模式变化 / 新字段增加。  
- 怎么用：分析历史执行计划变化；刷新统计；索引重建或重排。  
- 关键细节：强制索引只临时；根因需修复数据分布问题。  
- 面试提示：定位过程分步骤。

---

## 14. 迁移与版本升级 [2]

### 14.1 SQL 模式与字符集变更
- 是什么：STRICT、NO_ZERO_DATE、字符集 utf8mb4 升级。  
- 为什么：提升数据正确性与多语言兼容。  
- 怎么用：先测试兼容性；逐库灰度；字符集转换前备份。  
- 关键细节：索引长度变动；排序规则影响比较。  
- 面试提示：说明迁移风险点。

### 14.2 Online DDL 工具
- 是什么：gh-ost / pt-online-schema-change。  
- 为什么：避免长时间锁表影响业务。  
- 怎么用：影子表复制 + 增量捕获 → 原子切换。  
- 关键细节：触发器/延迟复制；大表维护窗口选择。  
- 面试提示：谈及“为什么不用直接 ALTER”。

### 14.3 双写灰度迁移
- 是什么：新旧库并行写入 + 校验一致性后切换。  
- 为什么：降低切换风险与数据丢失概率。  
- 怎么用：比对校验、异常差异对账。  
- 关键细节：双写延迟与冲突处理；幂等。  
- 面试提示：描述验证流程。

---

## 15. 安全与权限控制 [2]

### 15.1 最小权限原则
- 是什么：按功能粒度授予 SELECT/INSERT/UPDATE/DELETE。  
- 为什么：降低误操作与攻击面。  
- 怎么用：分角色授权；定期审计。  
- 关键细节：避免授予 *.* 全局权限；限制危险操作。  
- 面试提示：说明一次权限收敛优化。

### 15.2 SQL 注入防护
- 是什么：利用预编译参数绑定避免拼接注入。  
- 为什么：防止恶意修改或泄露数据。  
- 怎么用：所有外部输入参数化；动态部分白名单。  
- 关键细节：日志不回显敏感 SQL；避免 ${} 直拼。  
- 面试提示：给出注入示例与修复。

### 15.3 审计与操作日志
- 是什么：记录慢 SQL、DDL、权限变更。  
- 为什么：溯源与合规。  
- 怎么用：开启审计插件/日志采集；集中分析。  
- 关键细节：敏感数据脱敏；日志保留策略。  
- 面试提示：说明“如何追踪异常删除”。

---

## 16. 数据质量与校验 [2]

### 16.1 约束体系
- 是什么：NOT NULL/UNIQUE/FOREIGN KEY/CHECK。  
- 为什么：防止脏数据进入系统。  
- 怎么用：CHECK 定义数值范围；外键需评估写性能。  
- 关键细节：外键约束在高并发写场景可能成为瓶颈。  
- 面试提示：取舍外键 vs 应用层校验。

### 16.2 软删除 vs 物理删除
- 是什么：逻辑标记删除与真正删除行。  
- 为什么：审计与恢复 vs 空间回收。  
- 怎么用：is_deleted 标记 + 归档任务物理清理。  
- 关键细节：查询需过滤；索引选择考虑标记列。  
- 面试提示：说明软删除副作用。

### 16.3 脏数据修复
- 是什么：编写校验脚本发现并矫正异常记录。  
- 为什么：保障统计/业务正确性。  
- 怎么用：对账表、异常规则检测、回滚预案。  
- 关键细节：修复需幂等与审计。  
- 面试提示：强调“先快照再修复”。

---

## 17. 与缓存协同策略 [3]

### 17.1 旁路缓存模式
- 是什么：Cache Aside：读时缓存 miss → 查库写缓存；写时更新库并失效缓存。  
- 为什么：控制缓存与数据库一致性。  
- 怎么用：热点 Key 增加预热；写后删而非写后更新。  
- 关键细节：并发写导致回填窗口；加版本号或延迟双删。  
- 面试提示：解释“删除优于更新”的原因。

### 17.2 热点 Key 管理
- 是什么：高访问频率键值易击穿。  
- 为什么：防止瞬时回源压垮数据库。  
- 怎么用：预热、热点分片、随机过期时间错峰。  
- 关键细节：热点识别：访问统计 / 滑动窗口计数。  
- 面试提示：描述一次热点缓解策略。

### 17.3 一致性版本号策略
- 是什么：缓存数据携带逻辑版本或时间戳。  
- 为什么：判断是否过期或并发覆盖。  
- 怎么用：更新时比较版本；不匹配放弃写。  
- 关键细节：版本增长规则与回退；防止时钟漂移。  
- 面试提示：说明与简单 TTL 区别。

---

## 18. 性能测试与容量规划 [3]

### 18.1 基线建立
- 是什么：记录并发数、QPS、响应时间分位数(P95/P99)。  
- 为什么：衡量变更影响与增长趋势。  
- 怎么用：稳定环境重复压测；控制变量。  
- 关键细节：避免测试期间混入其他负载；预热。  
- 面试提示：说明“为什么看分位数而非平均值”。

### 18.2 压测数据建模
- 是什么：模拟真实访问分布、缓存命中率、读写比。  
- 为什么：避免乐观结果脱离生产。  
- 怎么用：采集生产统计 → 合成数据 → 混合场景。  
- 关键细节：数据集大小影响缓存命中；必须包含慢查询模式。  
- 面试提示：强调“不要只测理想路径”。

### 18.3 指标外推与增长
- 是什么：根据当前利用率预测资源耗尽时间。  
- 为什么：提前扩容与避免紧急故障。  
- 怎么用：线性/季节性趋势模型；容量安全阈值。  
- 关键细节：IOPS、Buffer Pool 命中率、CPU 饱和度协同观察。  
- 面试提示：举例“3 个月后需扩容”推断过程。

---

## 19. 面试常见问答速览
1. 联合索引顺序重要性：最左前缀决定可利用性与覆盖潜力。  
2. MVCC 可重复读：版本链 + undo 快照视图；当前读需锁。  
3. 大分页慢：深度扫描跳过行 → 使用游标/延迟关联。  
4. N+1 查询：惰性加载集合迭代触发多次 select → fetch join / batch。  
5. 主从延迟脏读避免：关键读走主库 + 延迟阈值判定回退。  
6. 分库全局排序：各分片取超量结果 → 小根堆归并。  
7. UUID 主键性能差：随机写导致页分裂与缓存局部性差。  

---

## 20. 重要度汇总
- SQL 执行计划与索引优化 [5]  
- InnoDB 索引/MVCC/锁/隔离级别 [5]  
- 事务与锁冲突诊断 [5]  
- 连接池配置与泄漏排查 [4]  
- ORM 性能与抓取策略 [4]  
- MyBatis 动态 SQL 与插件 [4]  
- 分库分表与读写分离 [4]  
- 数据一致性与幂等策略 [4]  
- 索引调优与执行计划案例 [4]  
- 高并发数据库负载缓解 [4]  
- 模型与结构规范 [3]  
- 数据库监控指标 [3]  
- 与缓存协同策略 [3]  
- 性能测试与容量规划 [3]  
- 常见故障诊断与恢复 [3]  
- 数据质量与约束 [2]  
- 迁移与在线变更 [2]  
- 安全与权限控制 [2]  
- Native ID 与主键策略优化 [3] (补充)  
- 面试问答速览 (辅助) [2]  

(完)