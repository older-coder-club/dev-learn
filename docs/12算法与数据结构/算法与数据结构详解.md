# 算法与数据结构面试指南（单点强化版）

评分说明：5=必须掌握，4=很重要，3=熟练更佳，2=了解即可，1=加分项  
结构：每个条目仅聚焦一个具体数据结构或算法，统一“是什么 / 为什么 / 怎么用 / 关键细节 / 面试提示”。

---

## 1. 时间复杂度与空间复杂度 [5]
- 是什么：衡量随输入规模增长的资源消耗；时间：操作步数阶；空间：额外内存（含递归栈）。  
- 为什么：指导选型与扩展性边界预测。  
- 怎么用：找主导项；递归用主定理或递归树；均摊分析解决周期性昂贵操作。  
- 关键细节：最坏/平均/均摊区别；Big-O 不含常数但工程需估常数；警惕隐藏 O(n)（如字符串拼接）。  
- 面试提示：能快速说明“哈希表均摊 O(1) 最坏 O(n)”。

## 2. 动态数组 (ArrayList) [5]
- 是什么：连续内存 + 自动扩容；随机访问 O(1)。  
- 为什么：大多数场景读多写少性能好。  
- 怎么用：扩容策略（通常 1.5~2x）；预估容量减少扩容次数。  
- 关键细节：扩容复制成本 O(n) 被均摊；频繁在头部插入性能差；越界检查。  
- 面试提示：解释“为什么频繁在头部插入不宜用 ArrayList”。

## 3. 链表 (单/双向) [4]
- 是什么：节点指针串联；不连续内存。  
- 为什么：已定位节点 O(1) 插删；适合频繁中间插入。  
- 怎么用：维护头/尾指针；双向支持 O(1) 删除节点自身。  
- 关键细节：反转指针顺序；环检测；迭代删除要保存 next。  
- 面试提示：可无误描述“反转链表三指针过程”。

## 4. 栈 (Stack) [4]
- 是什么：后进先出结构。  
- 为什么：表达式求值、括号匹配、递归模拟。  
- 怎么用：数组或链表实现 push/pop。  
- 关键细节：溢出与空栈检查；递归深度替换。  
- 面试提示：清晰说明“括号合法性判定栈思路”。

## 5. 队列 (Queue) [4]
- 是什么：先进先出结构。  
- 为什么：广度搜索、任务排队。  
- 怎么用：循环数组或链表；双指针控制头尾。  
- 关键细节：循环数组取模；长度与容量分离。  
- 面试提示：解释“为何 BFS 用队列而非栈”。

## 6. 双端队列 (Deque) [3]
- 是什么：两端插入删除 O(1)。  
- 为什么：滑动窗口、单调队列。  
- 怎么用：维护头尾指针或链表。  
- 关键细节：窗口过期元素需弹出；与队列区分。  
- 面试提示：说明“最大滑动窗口值算法结构”。

## 7. 单调栈 / 单调队列 [4]
- 是什么：保持单调性以 O(n) 获得邻近或窗口最值。  
- 为什么：替代嵌套枚举 O(n^2)。  
- 怎么用：入栈前弹出破坏单调元素。  
- 关键细节：存索引便于计算距离；队列处理窗口过期。  
- 面试提示：能讲“柱状图最大矩形单调栈逻辑”。

## 8. 哈希表 (HashMap) [5]
- 是什么：键通过哈希映射桶；冲突用链/树或开放定址。  
- 为什么：均摊 O(1) 查改。  
- 怎么用：合理装载因子控制扩容；定制 hashCode/equals。  
- 关键细节：高碰撞退化；并发需分段或 CAS。  
- 面试提示：说明“为什么自定义类要重写 hashCode 与 equals”。

## 9. 集合 (Set) [4]
- 是什么：元素唯一性结构（基于哈希或树）。  
- 为什么：快速去重与存在判断。  
- 怎么用：HashSet、TreeSet（有序）。  
- 关键细节：有序集合红黑树 O(log n)；迭代顺序差异。  
- 面试提示：区别 HashSet 与 TreeSet 使用场景。

## 10. 二分查找 [5]
- 是什么：在有序或“答案单调”空间中对半缩减。  
- 为什么：降线性到对数时间。  
- 怎么用：循环不变量 + 中点计算防溢出。  
- 关键细节：边界处理易错；浮点二分需精度判断。  
- 面试提示：写出“第一个 >= target”模板。

## 11. 二叉搜索树 (BST) [4]
- 是什么：左<根<右；中序有序。  
- 为什么：支持有序遍历与范围查询。  
- 怎么用：递归或迭代插入/查找。  
- 关键细节：退化链；删除节点三种情况。  
- 面试提示：简述删除含两个子节点处理。

## 12. AVL 树 [3]
- 是什么：高度平衡 BST；平衡因子 -1/0/1。  
- 为什么：查找稳定 O(log n)。  
- 怎么用：插入后自底向上旋转。  
- 关键细节：四种旋转（LL/LR/RL/RR）；维护高度。  
- 面试提示：说明与红黑树取舍（旋转频率 vs 实现复杂度）。

## 13. 红黑树 [4]
- 是什么：近似平衡 BST，节点黑/红规则保证最长路径≤2×最短。  
- 为什么：较少旋转，工程常用。  
- 怎么用：插入红色→修正；删除→双黑修复。  
- 关键细节：性质五条；颜色翻转与旋转组合。  
- 面试提示：能列关键性质并说明“为什么性能稳定”。

## 14. 堆 (二叉堆) [4]
- 是什么：完全二叉树数组存储；父子满足堆序。  
- 为什么：O(log n) 维护最值。  
- 怎么用：上浮/下沉调整；建堆自底向上。  
- 关键细节：索引换算；懒删除策略。  
- 面试提示：解释“建堆 O(n) 而不是 O(n log n)”。

## 15. 优先队列 [4]
- 是什么：支持按优先级弹出元素的抽象（堆实现）。  
- 为什么：调度、Top-K、合并序列。  
- 怎么用：最小堆维护待处理最小值。  
- 关键细节：比较器一致性；扩容成本。  
- 面试提示：讲 Top-K 使用大小 k 的最小堆原因。

## 16. Trie (前缀树) [3]
- 是什么：按字符路径分层存储字符串。  
- 为什么：前缀查询 O(m) 不依赖集合总规模。  
- 怎么用：插入沿路创建；末尾标记终结。  
- 关键细节：空间膨胀；可压缩为 Radix。  
- 面试提示：说明“为什么不用排序+二分”。

## 17. 线段树 [4]
- 是什么：区间分治二叉树维护区间聚合。  
- 为什么：多次区间查询+更新 O(log n)。  
- 怎么用：节点存合并值；懒标记延迟传播。  
- 关键细节：懒标记覆盖 vs 叠加；内存 4n。  
- 面试提示：能解释“区间加与查询”流程。

## 18. Fenwick 树 (树状数组) [3]
- 是什么：利用最低位实现前缀和结构。  
- 为什么：实现简单内存小；前缀和/单点更新 O(log n)。  
- 怎么用：lowbit(x)=x&(-x)。  
- 关键细节：索引从 1 开始；不支持复杂区间操作。  
- 面试提示：区别于线段树适用边界。

## 19. 跳表 (Skip List) [3]
- 是什么：多层索引的链表结构近似平衡查改 O(log n)。  
- 为什么：实现简单可替代平衡树。  
- 怎么用：随机晋升层级。  
- 关键细节：概率 p；空间期望 ≈2n。  
- 面试提示：说明“为什么 Redis 使用它”.

## 20. 并查集 (Union-Find) [4]
- 是什么：维护集合连通关系结构。  
- 为什么：近乎 O(1) 合并与查找。  
- 怎么用：路径压缩 + 按秩合并。  
- 关键细节：递归或迭代 find；复杂度 α(n)。  
- 面试提示：说明岛屿计数如何应用。

## 21. 图表示 (邻接表 / 邻接矩阵) [3]
- 是什么：存储顶点与边的结构。  
- 为什么：算法执行需合适表示。  
- 怎么用：稀疏用邻接表，稠密用矩阵。  
- 关键细节：矩阵 O(n^2) 空间；边权存储方式。  
- 面试提示：选择结构理由。

## 22. BFS (广度优先搜索) [4]
- 是什么：按层遍历图/树。  
- 为什么：最短步数问题（无权）。  
- 怎么用：队列 + 访问标记。  
- 关键细节：访问顺序；多源初始化。  
- 面试提示：说明“无权最短路径依赖 BFS”。

## 23. DFS (深度优先搜索) [4]
- 是什么：沿路径深入回溯。  
- 为什么：遍历、连通分量、拓扑检测。  
- 怎么用：递归或栈模拟。  
- 关键细节：栈深与回溯状态恢复。  
- 面试提示：讲“拓扑检测环”如何用 DFS 回边。

## 24. 拓扑排序 [4]
- 是什么：DAG 顶点线性序列满足依赖顺序。  
- 为什么：任务调度、编译顺序。  
- 怎么用：Kahn 入度法或 DFS 栈。  
- 关键细节：存在环则失败；入度更新。  
- 面试提示：区分两种实现。

## 25. Dijkstra 最短路 [4]
- 是什么：非负权单源最短路径。  
- 为什么：高效求路径。  
- 怎么用：最小堆选当前最短未确定节点。  
- 关键细节：负边不适用；堆优化 O(m log n)。  
- 面试提示：指出与 Bellman-Ford 差异。

## 26. Bellman-Ford 算法 [3]
- 是什么：允许负权边单源最短路径。  
- 为什么：检测负环并处理负权。  
- 怎么用：迭代松弛 n-1 次。  
- 关键细节：复杂度 O(nm)；终止优化。  
- 面试提示：负环判定条件。

## 27. Floyd-Warshall [3]
- 是什么：全源最短路动态规划。  
- 为什么：密集小图多对路径。  
- 怎么用：三重循环更新 dist[i][j]=min(dist[i][j], dist[i][k]+dist[k][j])。  
- 关键细节：O(n^3)；初始化自环 0。  
- 面试提示：适用场景“小规模全路径”。

## 28. A* 搜索 [3]
- 是什么：启发式最短路径（代价 g + 估价 h）。  
- 为什么：减少搜索空间。  
- 怎么用：优先队列按 f=g+h 排序。  
- 关键细节：h 可行下界（不高估）；一致性提升效率。  
- 面试提示：说明“启发函数性质”。

## 29. Kruskal 最小生成树 [3]
- 是什么：按边权排序逐条选入并查集判环。  
- 为什么：稀疏图高效。  
- 怎么用：排序 + union。  
- 关键细节：边排序成本；并查集优化。  
- 面试提示：与 Prim 适用图差异。

## 30. Prim 最小生成树 [3]
- 是什么：逐步扩展当前树的最近边。  
- 为什么：稠密图可配合堆。  
- 怎么用：堆维护可选最小边。  
- 关键细节：访问标记；邻接矩阵实现。  
- 面试提示：对比 Kruskal。

## 31. KMP 字符串匹配 [4]
- 是什么：前缀函数避免回退主串。  
- 为什么：线性匹配长文本。  
- 怎么用：构建失配表 next；扫描匹配。  
- 关键细节：next 定义准确；边界回退。  
- 面试提示：说明“为何避免主串指针回退”。

## 32. Rabin-Karp [3]
- 是什么：滚动哈希批量模式搜索。  
- 为什么：支持多模式初筛。  
- 怎么用：窗口哈希更新；匹配后再精确比较。  
- 关键细节：冲突概率控制；取模与溢出。  
- 面试提示：指出与 KMP 差异（哈希 vs 前缀）。

## 33. Aho-Corasick 多模式匹配 [3]
- 是什么：Trie + 失败指针实现同时多模式线性匹配。  
- 为什么：大量关键词过滤高效。  
- 怎么用：BFS 构建失败指针。  
- 关键细节：内存大；输出链维护。  
- 面试提示：使用场景“敏感词过滤”。

## 34. 前缀和 [4]
- 是什么：预处理累积数组快速区间求值。  
- 为什么：将多次 O(k) 求和降为 O(1)。  
- 怎么用：prefix[i]=sum(0..i-1)。  
- 关键细节：下标偏移；二维扩展。  
- 面试提示：解释“和为 K 子数组”核心转化。

## 35. 差分数组 [3]
- 是什么：记录相邻差值批量区间增操作。  
- 为什么：多区间增效率高。  
- 怎么用：d[l]+=v; d[r+1]-=v。  
- 关键细节：最终还原前缀；不适合中途查询。  
- 面试提示：区分与前缀和用途。

## 36. 滑动窗口 [4]
- 是什么：双指针动态维护满足条件区间。  
- 为什么：替代双重循环。  
- 怎么用：扩右更新→满足后缩左。  
- 关键细节：窗口统计结构更新时机。  
- 面试提示：讲“最小覆盖子串”过程。

## 37. 双指针技巧 [4]
- 是什么：两个指针协同扫描结构。  
- 为什么：定位关系（距离、相交、快慢）。  
- 怎么用：快慢判环；左右夹逼排序数组。  
- 关键细节：终止条件；避免死循环。  
- 面试提示：说明“有序数组两数之和实现”。

## 38. 回溯 (DFS 枚举) [4]
- 是什么：探索解空间 + 撤销走错分支。  
- 为什么：生成组合/排列/子集。  
- 怎么用：路径列表 + used 标记 + 剪枝。  
- 关键细节：层内去重；状态恢复顺序。  
- 面试提示：组合总和剪枝点选择。

## 39. 动态规划 (DP) [5]
- 是什么：将原问题拆分为有重叠子问题与最优子结构的集合，通过保存子问题结果避免重复计算，典型形式：线性 DP、背包 DP、区间 DP、树形 DP、状态压缩 DP、数位 DP、概率/计数 DP、博弈 DP。  
- 为什么：将指数级搜索（回溯/枚举）降为多项式时间；提供系统化建模框架，减少随意猜算法；工程中用于资源规划、路径优化、序列分析。  
- 怎么用（通用五步）：1) 明确结果目标；2) 定义状态(维度与含义)；3) 给出转移方程（当前与前序依赖关系）；4) 初始化边界条件；5) 选择计算顺序（自底向上或记忆化）。根据空间维度考虑滚动或压缩；根据数据规模选取合适复杂度。  
- 关键细节：状态定义必须“最小充分”（多或少都会错）；维度数量直接决定复杂度；滚动数组须保证依赖已被保留；区间 DP 遍历区间长度，再枚举分割点；状态压缩 DP 要控制 n≤20 左右；数位 DP 需携带“已达到上界标志+前置约束”；树形 DP 后序遍历聚合子结果；计数类 DP 注意取模与溢出。  
- 面试提示：快速展开：“我会先判断是否存在重叠子问题→定义状态→写出转移→举 0/1 背包与 LIS 两个经典例子区分状态与转移方向”，并能比较“回溯 vs DP”在时间上的指数与多项式差异。

### 39.1 0/1 背包
- 状态：dp[i][w] 表示前 i 件物品在容量 w 下最大价值；空间优化：一维 dp[w] 从大到小迭代。  
- 转移：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])。  
- 关键：一维滚动时容量倒序防止同一物品被多次使用。  
- 面试提示：指出“为何倒序”体现理解。

### 39.2 完全背包
- 状态：dp[w] 表示容量 w 最大价值。  
- 转移：dp[w] = max(dp[w], dp[w-weight[i]] + value[i])（正序遍历 w）。  
- 关键：正序允许重复使用同一物品。  
- 面试提示：对比 0/1 背包遍历方向差异。

### 39.3 多重背包
- 做法：拆分二进制组（k → 1,2,4,...,剩余）转化为 0/1 背包；或单调队列优化。  
- 关键：二进制分解总项数 O(log k)。  
- 面试提示：能说出“为什么不直接内层循环 k 次”。

### 39.4 最长上升子序列 (LIS)
- O(n^2) DP：dp[i] 以前缀结尾的最长长度；转移遍历 j<i。  
- O(n log n) 优化：维护最小结尾数组 tail；二分更新。  
- 面试提示：强调“tail 长度即 LIS”。

### 39.5 最长公共子序列 (LCS)
- 状态：dp[i][j] 表示 A 前 i 与 B 前 j 的 LCS 长度。  
- 转移：A[i]==B[j] → dp[i-1][j-1]+1；否则 max(dp[i-1][j],dp[i][j-1])。  
- 关键：需要二维；回溯路径输出序列。  
- 面试提示：区分与最长公共子串（连续）。

### 39.6 编辑距离 (Levenshtein)
- 状态：dp[i][j] 表示 A 前 i 转为 B 前 j 最少操作数。  
- 转移：增/删/改 三种操作取最小 +1；字符相等继承。  
- 关键：初始化第一行列为 i/j。  
- 面试提示：能现场写转移公式。

### 39.7 区间 DP（矩阵链乘 / 石子合并）
- 状态：dp[l][r] 表示区间最优值。  
- 转移：枚举分割点 k：dp[l][r] = min/max(dp[l][k] + dp[k+1][r] + cost(l,r))。  
- 顺序：按区间长度 len 从小到大。  
- 面试提示：说明“为什么按区间长度”保证子问题已算。

### 39.8 树形 DP（删点、选点、最大独立集）
- 做法：后序遍历；节点状态依赖子节点。  
- 示例：选点权值最大且不选相邻：dp[u][1]=val[u]+Σ dp[v][0]；dp[u][0]=Σ max(dp[v][0],dp[v][1])。  
- 关键：递归返回两种状态。  
- 面试提示：清晰表达状态含义。

### 39.9 状态压缩 DP（旅行商 TSP）
- 状态：dp[mask][i] 表示访问集合 mask 且当前在 i 的最短路径。  
- 转移：dp[mask][i] = min(dp[mask ^ (1<<i)][j] + dist[j][i])。  
- 复杂度：O(n^2 2^n)。  
- 面试提示：指出 n≈20 就极限。

### 39.10 数位 DP
- 场景：统计区间内满足数字性质的数量（无连续相同、某数出现 k 次）。  
- 状态：pos / tight(是否受前缀上界限制) / 约束参数 / 前置值。  
- 做法：递归构造 + 记忆化。  
- 面试提示：能描述“tight 控制不越界”。

### 39.11 概率 / 计数 DP（掷骰和分布、方案数）
- 状态：dp[i][s] 表示前 i 次达到和 s 的方案数量；概率=数量/总数。  
- 优化：滚动数组；注意上界。  
- 面试提示：指出可用前缀提升求区间概率。

### 39.12 博弈 DP（拿石子 / 先后手差值）
- 状态：dp[l][r] 表示当前玩家在区间取得的最大净收益。  
- 转移：选择左或右：value[l] - dp[l+1][r] 与 value[r] - dp[l][r-1] 取 max。  
- 面试提示：强调“差值”避免记录双方两数组。

### 39.13 打家劫舍 / 打家劫舍 II
- 线性：dp[i]=max(dp[i-1], dp[i-2]+nums[i])。  
- 环形：拆成 0..n-2 与 1..n-1 两次。  
- 面试提示：指明“环导致首尾冲突”。

### 39.14 股票买卖系列
- 单次：dp[i][0/1] 持有/未持有；转移：买入/卖出。  
- 多次含冷却/手续费：扩展状态或在转移里扣减。  
- 面试提示：能写出手续费版关键转移：sell = hold + price - fee。

### 39.15 打表 + 滚动数组示例（背包）
- 滚动：一维 dp 降空间 O(W)。  
- 注意：遍历顺序决定是否允许重复取。  
- 面试提示：明确“正序 vs 逆序”的语义。

### 39.16 构造方案数与字典序最优
- 在 DP 中额外记录 count / 或路径 parent。  
- 面试提示：强调“记录 parent 指针回溯方案”。

### 39.17 记忆化搜索 vs 自底向上
- 记忆化：递归自然表达，适合稀疏访问；自底向上：适合全状态 & 更易滚动优化。  
- 面试提示：说明“何时用记忆化（状态不全遍）”。

### 39.18 优化策略汇总
- 空间：滚动 / 压缩维度 / 位压缩。  
- 时间：剪枝（跳过无效状态）、分组计算、预处理（前缀、组合数）。  
- 面试提示：举“二维转一维”减少内存示例。

### 39.19 常见误区
- 定义不最小 → 冗余倍增复杂度。  
- 初始化漏掉边界 → 转移出错。  
- 方向错误 → 使用尚未计算的状态。  
- 面试提示：列举一次踩坑复盘。

### 39.20 典型题目速查总表
| 类型 | 示例 | 核心状态/技巧 |
| ---- | ---- | ------------- |
| 0/1 背包 | 最大价值 | dp[w] 倒序遍历 |
| 完全背包 | 组合数/完全硬币 | dp[w] 正序 |
| 多重背包 | 商品限购 | 二进制拆分 |
| LIS | 最长上升 | tail 二分 |
| LCS | 两串最长公共子序列 | 二维 dp |
| 编辑距离 | 最少操作 | 增删改取最小 |
| 区间 DP | 石子合并 | 长度枚举 |
| 树形 DP | 最大独立集 | 子节点聚合 |
| 状态压缩 | TSP | mask+i |
| 数位 DP | 计数约束 | tight 标志 |
| 股票买卖 | 手续费/冷却 | 持有/不持有 |
| 打家劫舍 | 线性/环形 | 两次线性 |
| 博弈 | 先后手差值 | 净收益 |
| 计数方案 | 走格子/排列数 | dp 累加+取模 |

## 40. 贪心算法 [4]
- 是什么：局部最优推导全局最优。  
- 为什么：更快替代 DP。  
- 怎么用：排序 + 单遍决策。  
- 关键细节：证明（交换论证）；失败条件识别。  
- 面试提示：活动选择结束时间排序理由。

## 41. 位运算与状态压缩 [3]
- 是什么：用位表示集合或状态。  
- 为什么：降低空间与加速子集枚举。  
- 怎么用：subset=(subset-1)&mask。  
- 关键细节：注意位数上限；long 防溢出。  
- 面试提示：旅行商 DP 状态描述。

## 42. Bloom Filter [3]
- 是什么：概率存在结构；误判但不漏。  
- 为什么：减少无效查询压力。  
- 怎么用：k 哈希置位；查询检查 k 位。  
- 关键细节：参数计算；不可删除。  
- 面试提示：场景“缓存穿透过滤”。

## 43. Count-Min Sketch [2]
- 是什么：频次近似结构。  
- 为什么：流式大数据频次估计。  
- 怎么用：多哈希行最小值估频次。  
- 关键细节：误差界限；哈希独立性。  
- 面试提示：说明与精确哈希表差异。

## 44. Reservoir Sampling [2]
- 是什么：单遍等概率采样 k 元素。  
- 为什么：未知总量流数据。  
- 怎么用：第 i 元素以 k/i 概率替换。  
- 关键细节：随机源质量；k 维度。  
- 面试提示：描述实现两行核心逻辑。

## 45. 一致性哈希 [3]
- 是什么：环上节点与键映射；顺时针最近节点。  
- 为什么：扩缩容迁移少量数据。  
- 怎么用：虚拟节点平衡分布。  
- 关键细节：节点过少倾斜；哈希函数选择。  
- 面试提示：阐述“迁移比例接近 1/N”。

## 46. LRU 缓存策略 [4]
- 是什么：淘汰最近最少使用元素。  
- 为什么：提高命中率。  
- 怎么用：双向链表+Hash O(1)。  
- 关键细节：并发锁粒度；过期与容量。  
- 面试提示：说出核心结构组合。

## 47. LFU 缓存策略 [4]
- 是什么：淘汰最不常用元素。  
- 为什么：高频访问保持缓存。  
- 怎么用：freq→双链桶 + 最小频次指针。  
- 关键细节：频次老化避免长期占用。  
- 面试提示：解释实现复杂度 vs LRU。

## 48. Monotonic Queue 应用 (滑动最大值) [4]
- 是什么：维护窗口内单调递减值。  
- 为什么：O(n) 获取每窗口最大。  
- 怎么用：入队前弹出小于新值元素。  
- 关键细节：队头过期需移除。  
- 面试提示：阐述时间复杂度来源。

## 49. 状态压缩 DP (旅行商 / 子集) [3]
- 是什么：用位集合表示已访问状态。  
- 为什么：枚举组合集合高效。  
- 怎么用：dp[mask][i] 表示到 i 的最优。  
- 关键细节：复杂度 O(n^2 2^n)；n 上限。  
- 面试提示：说明适用规模限制。

## 50. 回溯剪枝策略设计 [4]
- 是什么：提前排除不可能解支线。  
- 为什么：指数空间实用化。  
- 怎么用：排序 + 剪枝条件在递归前检测。  
- 关键细节：剪枝位置影响效率；去重层级。  
- 面试提示：举“数字过大终止”实例。

## 51. 滑动窗口变体：可变约束最优 [4]
- 是什么：约束为“窗口内计数/成本”最优或满足条件。  
- 为什么：优化最短/最长/计数问题。  
- 怎么用：控制 map / 频次 / sum 动态。  
- 关键细节：记录全局结果与当前窗口区分。  
- 面试提示：说明“替换次数 <= K 的最长子串”策略。

## 52. 工程实现考量 [4]
- 是什么：从理论到生产的差距：常数、内存、并发安全。  
- 为什么：真实性能与理论不同。  
- 怎么用：基准测试；压测边界；分析剖析器结果。  
- 关键细节：GC 影响；避免装箱；线程安全。  
- 面试提示：提及“为什么放弃某高复杂度结构”。

---

## 53. 面试速答锚点
1. 二分易错：边界更新与无限循环。  
2. 线段树 vs Fenwick：功能 vs 简洁。  
3. Trie 优势：前缀 O(m) 不依赖全量。  
4. Bloom 缺点：误判不可删除。  
5. LRU 结构：Hash + 双链。  
6. 一致性哈希：扩容迁移少。  
7. Dijkstra 不能负权原因。  
8. KMP 避免主串指针回退。  

---

## 54. 重要度汇总
- [5] 复杂度 / 动态数组 / 哈希 / 二分 / 动态规划 / 滑动窗口  
- [4] 栈 / 队列 / 单调结构 / 堆 / 优先队列 / BST / 红黑 / 线段树 / BFS / DFS / 拓扑 / Dijkstra / KMP / 回溯 / 贪心 / 前缀和 / LRU / LFU / 双指针 / 工程实现  
- [3] AVL / Fenwick / 跳表 / Trie / 并查集 / 差分 / 位运算 / Bloom / 一致性哈希 / 状态压缩 / A* / Kruskal / Prim / Rabin-Karp / Aho-Corasick  
- [2] Count-Min Sketch / Reservoir Sampling / Floyd / Bellman-Ford

## 55. 排序算法总览与选择策略 [5]
- 是什么：针对可比较集合元素按指定顺序排列的一类基础算法族，时间复杂度 / 空间复杂度 / 稳定性 / 是否原地 / 最坏与平均表现决定工程选型。
- 为什么：几乎所有数据处理链路前置步骤；不同数据分布及规模决定性能与资源消耗；理解特性可在面试中快速给出“场景→算法”映射。
- 怎么用：根据数据规模、是否需要稳定、内存限制、是否近乎有序、是否存在重复值 / 值域受限进行决策；可组合形成混合算法（如 IntroSort）。
- 关键细节：稳定性影响后续按多关键字排序的正确性；原地避免额外内存；外部排序需多路归并；近乎有序适合插入、冒泡优化、TimSort；随机化 Quick 防止最坏 O(n^2)。
- 面试提示：先给总体维度表述，再按场景选例：“海量整数有限值域→计数排序；近乎有序→插入；需要稳定 O(n log n)→归并”。

### 55.1 冒泡排序 (Bubble Sort) [1]
- 是什么：相邻元素两两比较交换，大元素逐步“冒”到末尾。
- 为什么：教学用、实现极简单，适合说明稳定性与交换机制。
- 怎么用：双重循环；内层若无交换可提前结束 (优化)。
- 关键细节：最坏/平均 O(n^2)；稳定；原地；大量已排序数据快。
- 面试提示：提及“交换标志优化”体现理解非死记。

### 55.2 选择排序 (Selection Sort) [2]
- 是什么：每轮选择剩余元素最小值放到当前起始位置。
- 为什么：交换次数最少 (至多 n-1)，结构直观。
- 怎么用：外层 i；内层找最小下标 minIdx；结束时一次交换。
- 关键细节：不稳定（最小元素与相等元素交换可能破坏顺序）；O(n^2)。
- 面试提示：指出“稳定性差+整体 O(n^2) 实际少用”。

### 55.3 插入排序 (Insertion Sort) [3]
- 是什么：维护已排序前缀，将新元素插入合适位置。
- 为什么：对小规模或近乎有序数据效率高。
- 怎么用：遍历 i；暂存 key；向左移动大于 key 元素后插入。
- 关键细节：稳定；最坏 O(n^2)；最好 O(n)（已排序）。
- 面试提示：说明“近乎有序→插入优于快排”。

### 55.4 希尔排序 (Shell Sort) [2]
- 是什么：基于分组（步长 gap）对元素做多轮插入式排序，逐步减少 gap。
- 为什么：降低大量逆序对移动成本；比插入快。
- 怎么用：gap 初始 n/2 或特定序列（Knuth）；gap→1。
- 关键细节：不稳定；复杂度依赖 gap 序列（常用 ~O(n^(3/2))）。
- 面试提示：强调“基于分组的插入加速”核心思想。

### 55.5 归并排序 (Merge Sort) [5]
- 是什么：分治：分半递归排序后归并两个有序序列。
- 为什么：稳定 O(n log n)，适合需要稳定性的大数据（可外排）。
- 怎么用：递归或自底向上迭代 (width=1,2,4...)；归并使用临时数组。
- 关键细节：额外 O(n) 空间；链表归并可原地；外部排序利用磁盘块多路归并。
- 面试提示：可快速写出“空间+稳定”对比快排理由。

### 55.6 快速排序 (Quick Sort) [5]
- 是什么：选择枢轴 (pivot) 分区，小于在左大于在右，递归排序。
- 为什么：平均 O(n log n) 原地常数低；工程常用。
- 怎么用：随机或三数取中选 pivot；Hoare/Lomuto 分区策略。
- 关键细节：最坏 O(n^2)（有序+差 pivot）；需随机化；不稳定；尾递归优化；栈深风险。
- 面试提示：强调“随机化+三数取中+小段切换插入”混合优化。

### 55.7 堆排序 (Heap Sort) [4]
- 是什么：构建最大堆；不断弹出堆顶放末尾。
- 为什么：原地 O(n log n)；不依赖随机性。
- 怎么用：自底向上建堆 O(n)；循环 swap(0,end) 下沉。
- 关键细节：不稳定；常数略高于快排；适合需要保证最坏界。
- 面试提示：提“最坏仍 O(n log n)”作为和快排互补点。

### 55.8 计数排序 (Counting Sort) [4]
- 是什么：统计每个值出现次数后做前缀和定位输出。
- 为什么：值域有限且整数时线性 O(n+k)。
- 怎么用：频次数组 freq；前缀和定位；逆序遍历保持稳定。
- 关键细节：需额外 O(k)；k 过大会不适用；稳定实现需逆序输出。
- 面试提示：强调“适用：值域远小于 n”条件。

### 55.9 桶排序 (Bucket Sort) [3]
- 是什么：划分区间桶，分桶后各桶内部排序再拼接。
- 为什么：输入接近均匀分布时线性期望。
- 怎么用：确定桶数与区间；元素映射；桶内用插入或快排。
- 关键细节：分布不均导致退化；需估计最大最小值；可用于浮点。
- 面试提示：说明“依赖分布假设”。

### 55.10 基数排序 (Radix Sort) [4]
- 是什么：按位（低→高或高→低）使用稳定子排序处理每一位。
- 为什么：固定长度数字/字符串可达线性 O(d*(n+k))。
- 怎么用：低位优先 (LSD) 常与计数排序结合处理每位。
- 关键细节：需稳定子排序；位数 d 与基数 k 影响常数；适合统一长度键。
- 面试提示：对比“比较类 vs 非比较类”算法边界。

### 55.11 TimSort (Java/Python 默认) [5]
- 是什么：结合归并 + 插入 + 运行段检测的自适应稳定排序。
- 为什么：在真实近乎有序或含局部有序段数据集表现优越。
- 怎么用：扫描识别自然 runs（升/降序；降序反转）→扩展至最小 run 长度→归并。
- 关键细节：稳定；最坏 O(n log n)；run 长度策略（最小 ~32）；优化局部有序。
- 面试提示：能说“JDK Arrays.sort(Object[]) 使用 TimSort 及原因”。

### 55.12 IntroSort (混合快速/堆/插入) [4]
- 是什么：快排为主，递归深度超阈值切换堆排，小段用插入。
- 为什么：保持平均性能同时避免最坏退化。
- 怎么用：设最大深度=2*log n；深度超过用堆。
- 关键细节：不稳定；需要追踪深度；STL sort 实现参考。
- 面试提示：说明“深度阈值设计目的”。

### 55.13 外部排序 (External Merge) [3]
- 是什么：磁盘大数据分块排序 + 多路归并。
- 为什么：内存不足情形处理海量数据。
- 怎么用：划块→内存排序写回→k 路最小堆归并。
- 关键细节：块大小 = 内存可容；I/O 优化顺序读；临时文件清理。
- 面试提示：强调“多路归并 + 堆”核心结构。

### 55.14 稳定 vs 不稳定 [3]
- 是什么：稳定保持相同键原相对顺序；不稳定可能打乱。
- 为什么：多关键字排序链式应用要求稳定保证最终结果正确。
- 怎么用：选择归并/插入/TimSort 等；快排默认不稳定除非特殊处理。
- 关键细节：稳定实现代价（额外空间或复杂逻辑）；非比较类多可稳定。
- 面试提示：给出“先按年龄后按名字”需稳定示例。

### 55.15 排序算法复杂度速表
| 算法 | 平均 | 最坏 | 空间 | 稳定 | 特征/使用场景 |
| ---- | ---- | ---- | ---- | ---- | ------------- |
| 冒泡 | n^2 | n^2 | 1 | 稳定 | 教学/近乎有序 |
| 选择 | n^2 | n^2 | 1 | 不稳 | 交换少 |
| 插入 | n^2 | n^2 | 1 | 稳定 | 小规模/近序 |
| 希尔 | n^1.3~1.5 | n^2 | 1 | 不稳 | 插入改进 |
| 归并 | n log n | n log n | n | 稳定 | 需要稳定/外排 |
| 快排 | n log n | n^2 | log n | 不稳 | 原地高效，随机化 |
| 堆排 | n log n | n log n | 1 | 不稳 | 保证最坏界 |
| 计数 | n+k | n+k | n+k | 稳定 | 值域小整数 |
| 桶排 | n | n^2 | n+k | 稳定(桶内选稳定) | 均匀分布 |
| 基数 | d*(n+k) | d*(n+k) | n+k | 稳定 | 固定位宽键 |
| TimSort | n log n | n log n | n | 稳定 | 真实数据优 |
| IntroSort | n log n | n log n | log n | 不稳 | STL sort |
| 外排 | n log n | n log n | 取决于缓冲 | 稳定 | 海量数据 |

### 55.16 面试常见速答模板
1. “近乎有序数据如何选？” → 插入 / TimSort。  
2. “需要稳定且 O(n log n)？” → 归并 / TimSort。  
3. “大量重复整数小值域？” → 计数 / 基数。  
4. “防止快排最坏退化？” → 随机化 pivot / IntroSort 深度切换。  
5. “外部排序核心？” → 分块 + 多路归并 + 最小堆。

### 55.17 Java 排序实现要点
- Arrays.sort(int[])：Dual-Pivot QuickSort（JDK 7+），优化分区减少比较。
- Arrays.sort(Object[])：TimSort（稳定）。
- Collections.sort(list)：转数组执行 TimSort。
- 并行排序：Arrays.parallelSort 使用分治+ForkJoin。
- 面试提示：区分基础类型与对象排序实现差异与稳定性。

### 55.18 常见优化策略
- 小段切换插入：阈值 ~16-32。
- 三数取中 / 随机 + 去重枢轴处理重复值（快排三向分区提升重复元素性能）。
- 归并迭代版减少递归栈。
- 计数/基数结合压缩值域（坐标压缩）。
- 面试提示：举“快排三向分区处理大量重复值”案例。

### 55.19 误区与踩坑
- 快排未随机化在有序数组上退化。
- 忽略稳定性导致多关键字链式排序错误。
- 基数排序未用稳定子排序破坏正确性。
- 外部排序未控制临时文件数量造成 I/O 放大。
- 面试提示：列一个实际线上“快排退化”事故说明改进。

### 55.20 选择流程速记
- 需要稳定？归并 / TimSort。
- 原地、平均快：快排/IntroSort。
- 最坏保证：堆排 / 归并。
- 值域小：计数 / 基数 / 桶。
- 近乎有序：插入 / TimSort。
- 海量外部：外排多路归并。
- 面试提示：按决策树回答体现系统化。
(完)