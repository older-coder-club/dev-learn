# JVM 与性能面试指南（加强版：逐条细化版）

评分：5=必须掌握，4=很重要，3=熟练更佳，2=了解即可，1=加分项  
说明：将原来的综合条目拆分为更细粒度，一个条目聚焦一个子知识点；仍按“是什么 / 为什么 / 怎么用 / 关键细节 / 面试提示”结构，便于被持续追问。

---

## 内存运行时结构与对象布局（拆分）

### 1.1 Java 堆概览 [5]
- 是什么：所有对象实例与数组存放区；分年轻代 (Eden + Survivor) 与老年代；G1/ZGC 等进一步按 Region 分片。
- 为什么：对象生命周期分层管理，降低回收成本。
- 怎么用：通过 -Xms/-Xmx 固定堆；根据分配速率与暂停目标选收集器。
- 关键细节：年轻对象朝生夕死 → 复制算法；老年代回收频率低 → 标记整理；大对象直接老年代（不同收集器策略不同）。
- 面试提示：解释为何“多数对象短命”支撑分代设计。

### 1.2 年轻代结构 (Eden/Survivor) 与晋升 [5]
- 是什么：Eden 初次分配；对象存活经多次 Minor GC 复制在 S0/S1 间并提升年龄，达到阈值或空间不足晋升老年代。
- 为什么：减少全堆扫描，加速回收。
- 怎么用：调 -XX:NewRatio 或 G1 年轻代比例；避免 Survivor 太小导致过度晋升。
- 关键细节：对象年龄通过对象头记录；动态年龄判定（累计大小超过 Survivor）。
- 面试提示：讲晋升失败触发 Full GC 的链条。

### 1.3 老年代与空间压力 [5]
- 是什么：存放长寿命或直接晋升对象；回收成本高。
- 为什么：降低频繁 GC 停顿；保证大业务对象稳定。
- 怎么用：监控 Old Gen 增长曲线；优化大 Map 缓存策略。
- 关键细节：老年代碎片影响分配（非压缩收集器）；并发标记周期决定触发频率。
- 面试提示：说明老年代持续上涨调优策略。

### 1.4 TLAB (Thread Local Allocation Buffer) [4]
- 是什么：线程私有分配缓冲区，避免多线程竞争堆指针。
- 为什么：降低 CAS/锁开销，加速小对象分配。
- 怎么用：开启默认；通过 -XX:+PrintTLAB 诊断；确保热点对象大小适配。
- 关键细节：TLAB 用完时走慢路径；过大浪费，过小提高 refill 次数。
- 面试提示：说出“为什么多线程下仍可近似无锁分配”。

### 1.5 元空间 (Metaspace) [4]
- 是什么：类元数据（方法、字段、常量池、字节码、运行时结构）存于本地内存。
- 为什么：摆脱永久代固定大小限制，提高可扩展性。
- 怎么用：监控使用；限制动态类生成；处理类卸载条件。
- 关键细节：类卸载需：无存活实例 + ClassLoader 可达性丢失 + 安全点收集触发。
- 面试提示：常见泄漏：缓存 ClassLoader 强引用。

### 1.6 Java 栈与栈帧 [5]
- 是什么：每线程私有，方法调用分配栈帧（局部变量表、操作数栈、常量池引用）。
- 为什么：快速函数调用与局部数据隔离。
- 怎么用：通过 -Xss 控制栈深度；防止无限递归。
- 关键细节：溢出触发 StackOverflowError；栈上数据线程私有免同步。
- 面试提示：区分 StackOverflow 与 OutOfMemory: Metaspace。

### 1.7 程序计数器 / 本地方法栈 [3]
- 是什么：PC 保存当前指令地址；本地方法栈服务 JNI 调用。
- 为什么：保证字节码解释与线程切换正确恢复。
- 怎么用：一般无需调参；关注过度 JNI 调用开销。
- 关键细节：本地栈错误可能触发崩溃而非受控异常。
- 面试提示：说明为何 PC 不会 OOM。

### 1.8 直接内存 (Off-heap) [4]
- 是什么：使用 ByteBuffer.allocateDirect 或 JNI 分配的堆外内存。
- 为什么：减少复制，提升 I/O（零拷贝）性能。
- 怎么用：控制分配数量；监控进程 RSS；避免频繁小块分配。
- 关键细节：释放依赖 GC 触发 Cleaner；泄漏难监控；可能超出 -Xmx 仍 OOM (Direct buffer memory)。
- 面试提示：区别堆内 OOM 与直接内存 OOM 排查路径。

### 1.9 对象头与布局 (Mark Word / Klass Pointer) [5]
- 是什么：Mark Word 存储哈希、GC 年龄、锁状态；Klass Pointer 指向类元数据。
- 为什么：统一对象运行时元信息与锁机制。
- 怎么用：通过 JOL (Java Object Layout) 查看实际布局；优化字段顺序减少填充。
- 关键细节：压缩指针减少 64bit 堆指针大小；对齐填充保证 8 字节边界。
- 面试提示：解释为什么无竞争下偏向锁存储线程 ID。

### 1.10 四种引用类型 (强/软/弱/虚) [4]
- 是什么：控制对象可达与回收优先级；软引用适合缓存；弱引用用于临时映射；虚引用跟踪回收。
- 为什么：实现灵活缓存与资源清理。
- 怎么用：软引用 + 过期策略；弱引用用于 ClassLoader Map；虚引用与 ReferenceQueue 构建清理器。
- 关键细节：软引用在内存紧张才回收；弱引用下一次 GC 即回收；虚引用 get 返回 null。
- 面试提示：说明“仅软引用不等于完整缓存淘汰策略”。

---

## GC 基础与算法（拆分）

### 2.1 标记-清除算法 [4]
- 是什么：遍历可达对象标记，再清除未标记内存。
- 为什么：实现基本回收，避免复制整堆。
- 怎么用：老年代并发回收阶段使用；CMS 典型。
- 关键细节：产生碎片；需要后续压缩或碎片管理。
- 面试提示：指出碎片导致分配失败触发 Full GC。

### 2.2 标记-整理算法 [5]
- 是什么：标记后将存活对象向一端移动并整理空间。
- 为什么：消除碎片，支持大对象连续分配。
- 怎么用：老年代压缩阶段；Serial Old / CMS Full / G1 Mixed。
- 关键细节：对象移动需要更新引用；停顿时间较标记清除高。
- 面试提示：解释与复制算法的区别（跨区域 vs 整体）。

### 2.3 复制算法 [5]
- 是什么：将存活对象从 From 区复制到 To 区并清空原区。
- 为什么：分配指针重置，效率高。
- 怎么用：年轻代 Minor GC；Eden + Survivor。
- 关键细节：需预留未使用空间；高存活率降低效率。
- 面试提示：说明适用于“存活率低”的区域。

### 2.4 三色标记与并发安全 [4]
- 是什么：对象初始白色；扫描置灰；处理完成置黑；最终白色为不可达。
- 为什么：并发标记中避免漏标与误标。
- 怎么用：写屏障记录黑对象指向新白对象的变更；重标阶段修正。
- 关键细节：漂白问题通过 SATB（快照）或增量更新解决。
- 面试提示：讲 SATB 与增量更新差异（ZGC vs G1）。

### 2.5 写屏障 / Remembered Set [5]
- 是什么：记录跨分代引用或并发标记时修改的指针。
- 为什么：减少全堆扫描，提高并发安全。
- 怎么用：分代制度下更新指针写 card；G1 使用 Remembered Set 维护跨 Region 引用。
- 关键细节：写屏障增加写成本；Remembered Set 过大影响性能。
- 面试提示：说明为什么“大量跨代引用”会拖慢 GC。

### 2.6 分代回收策略 [5]
- 是什么：按对象生命周期分年轻与老年代。
- 为什么：降低扫描与复制成本，匹配对象生存曲线。
- 怎么用：调年轻比例；控制晋升速率；利用统计数据优化阈值。
- 关键细节：晋升失败导致 Full GC；动态年龄判断。
- 面试提示：解释为何不再仅仅是“两个区”而是细粒度 Region。

### 2.7 STW 与并发回收阶段 [4]
- 是什么：Stop-The-World 暂停所有应用线程执行 GC 阶段；并发阶段与应用并行执行。
- 为什么：保证内存结构一致性。
- 怎么用：G1/ZGC 尽量缩短 STW，扩大并发部分。
- 关键细节：Safepoint 到达时间影响总暂停；并发阶段可能回收不足引发补偿 GC。
- 面试提示：区分“并发”与“并行”回收。

### 2.8 Finalization 与 Cleaner [3]
- 是什么：finalize 过时且不可预测；Cleaner 使用虚引用回调释放资源。
- 为什么：避免 GC 次序不确定造成延迟释放。
- 怎么用：使用 try-with-resources 和 Cleaner 替代 finalize。
- 关键细节：finalize 队列延迟执行；可能复活对象。
- 面试提示：强调“不依赖 finalize 做关键资源释放”。

---

## 垃圾收集器（逐个）

### 3.1 Serial / Serial Old [3]
- 是什么：单线程收集器；年轻代复制，老年代标记整理。
- 为什么：简单、适合小堆与单核环境。
- 怎么用：测试或微服务极小堆场景。
- 关键细节：停顿长；无并发能力；易预测。
- 面试提示：说明不适合生产大堆。

### 3.2 Parallel Scavenge / Parallel Old [4]
- 是什么：多线程并行回收，吞吐优先。
- 为什么：批处理类应用追求最大吞吐。
- 怎么用：通过 -XX:MaxGCPauseMillis 尝试延迟控制但以吞吐为主；调整 -XX:ParallelGCThreads。
- 关键细节：停顿仍较长；不关注低延迟尾部。
- 面试提示：区分与 G1：无复杂 Region 模型。

### 3.3 CMS (已淘汰) [3]
- 是什么：并发标记清除，降低老年代停顿。
- 为什么：历史上的低暂停选择。
- 怎么用：新版本已被 G1/ZGC 取代。
- 关键细节：碎片风险；Concurrent Mode Failure → Full GC。
- 面试提示：说明弃用原因。

### 3.4 G1 (Garbage-First) [5]
- 是什么：Region 划分 + 年轻/混合回收 + 暂停预测模型。
- 为什么：在大堆获得相对可控停顿。
- 怎么用：设置 -XX:MaxGCPauseMillis；监控混合回收频率；优化 Humongous 对象。
- 关键细节：Remembered Set 开销；Humongous 分配跨 Region；并发标记 + Evacuation。
- 面试提示：解释暂停预测依据：历史统计 + 回收集大小估算。

### 3.5 ZGC [5]
- 是什么：低停顿收集器：颜色指针 + 并发重定位。
- 为什么：超大堆 <~ TB 级低延迟。
- 怎么用：启用 -XX:+UseZGC；监控并发周期；关注引用修复开销。
- 关键细节：Load Barrier 更新指针；无长时间 STW；支持大对象。
- 面试提示：对比 G1：真正并发移动对象。

### 3.6 Shenandoah [4]
- 是什么：Brooks Pointer + 并发 Evacuation 实现低停顿。
- 为什么：低延迟堆回收选择，特别在 OpenJDK 社区。
- 怎么用：-XX:+UseShenandoahGC；监控并发阶段时间。
- 关键细节：指针转发；全堆并发 evacuation；吞吐略低。
- 面试提示：说明与 ZGC 的实现差异（颜色指针 vs Brooks Pointer）。

### 3.7 Epsilon (No-Op GC) [2]
- 是什么：不做回收，仅分配，堆用尽退出。
- 为什么：性能测试基线或极短生命周期应用。
- 怎么用：确保应用在堆耗尽前结束。
- 关键细节：无回收；仅适用于实验。
- 面试提示：指出不可用于生产。

### 3.8 收集器选择指南 [5]
- 是什么：基于堆大小、延迟目标、吞吐、版本成熟度选择策略。
- 为什么：避免错误选型造成不可达指标。
- 怎么用：延迟敏感大堆：ZGC；中大堆：G1；吞吐批处理：Parallel；试验低延迟：Shenandoah。
- 关键细节：版本兼容与监控成熟度。
- 面试提示：用场景映射具体选择。

---

## 类加载与模块化拆分

### 4.1 双亲委派模型 [5]
- 是什么：加载请求自下向上委派，先父再子。
- 为什么：避免核心类被篡改，保证一致性。
- 怎么用：自定义 ClassLoader 时保留委派逻辑；插件隔离打破委派需谨慎。
- 关键细节：findClass vs loadClass 区别；上下文 ClassLoader 解决 SPI。
- 面试提示：说明打破委派潜在安全风险。

### 4.2 ClassLoader 泄漏与卸载条件 [4]
- 是什么：ClassLoader 未被回收导致 Metaspace 增长。
- 为什么：影响内存与 GC 频率。
- 怎么用：清理静态缓存引用；弱引用持有临时类映射。
- 关键细节：实例、Class、本地缓存任何强引用都阻止卸载。
- 面试提示：描述典型“热部署”泄漏场景。

### 4.3 JPMS 模块系统基础 [4]
- 是什么：module-info.java 声明依赖、导出、开放；模块路径与类路径分离。
- 为什么：强封装与显式依赖控制；减少类冲突。
- 怎么用：exports 暴露 API；opens 反射访问；uses/provides SPI。
- 关键细节：自动模块名冲突；未导出的包不可访问。
- 面试提示：说明与 OSGi 的主要差异：编译时强依赖图。

### 4.4 ServiceLoader 与 SPI [3]
- 是什么：基于配置文件提供服务实现动态发现。
- 为什么：低耦合扩展点。
- 怎么用：META-INF/services/ 接口全限定名列实现类。
- 关键细节：惰性迭代；线程安全实现需自行保证。
- 面试提示：指出缺点：不支持条件加载与版本选择。

---

## JIT 与同步优化拆分

### 5.1 分层编译 (Tiered Compilation) [4]
- 是什么：C1 快速编译 + Profiling，C2 高级优化。
- 为什么：兼顾启动速度与峰值性能。
- 怎么用：默认开启；分析 -XX:+PrintCompilation 输出。
- 关键细节：OSR 进入已运行热循环；去优化重新进入解释模式。
- 面试提示：解释为什么冷启动期间性能较低。

### 5.2 方法内联 (Inlining) [5]
- 是什么：将调用目标代码直接嵌入调用点。
- 为什么：去除调用开销，触发更多优化。
- 怎么用：减少过大方法与深层分支；避免多态调用阻碍内联。
- 关键细节：大小阈值与热度限制；Megamorphic 调用难内联。
- 面试提示：举“内联→常量传播→死代码删除”链条案例。

### 5.3 逃逸分析与标量替换 [4]
- 是什么：对象未逃逸方法 → 拆为局部标量。
- 为什么：减少堆分配与 GC 压力。
- 怎么用：避免返回内部可变对象；减少共享。
- 关键细节：栈上分配未全面；优化受复杂控制流影响。
- 面试提示：区分概念与实际限制。

### 5.4 锁消除与锁粗化 [3]
- 是什么：消除不可逃逸对象上的冗余锁；合并频繁小临界区。
- 为什么：减少同步开销或震荡。
- 怎么用：简化对象作用域；减少无必要同步。
- 关键细节：JIT 分析逃逸结果；粗化可能延长持锁。
- 面试提示：说明“性能不是简单加锁/减锁”的平衡。

---

## 内存与对象优化拆分

### 6.1 装箱与拆箱成本 [4]
- 是什么：基本类型与包装类型转换产生临时对象。
- 为什么：多余对象增加 GC。
- 怎么用：使用原始类型集合（TIntArrayList 等第三方）或基本数组。
- 关键细节：Integer 缓存 [-128,127]；频繁自动装箱隐藏分配。
- 面试提示：指出在热路径日志拼接的装箱问题。

### 6.2 字符串处理优化 [4]
- 是什么：避免多次拼接创建临时对象。
- 为什么：降低 Allocation Rate。
- 怎么用：StringBuilder / format 缓存；减少 substring 大对象保留（JDK8 起独立数组）。
- 关键细节：intern 过度使用常量池膨胀。
- 面试提示：说明为什么循环中 + 拼接低效。

### 6.3 缓存与容量控制 [5]
- 是什么：对象留存老年代影响回收。
- 为什么：防止内存膨胀与 Full GC。
- 怎么用：LRU / LFU / 计时淘汰；软引用结合显式限制。
- 关键细节：仅软引用不可控；统计命中率评估价值。
- 面试提示：讲一个“缓存上限 + 命中率”调优案例。

### 6.4 数据结构选择 (ArrayList vs LinkedList) [4]
- 是什么：不同存储布局特性。
- 为什么：局部性与随机访问性能差异。
- 怎么用：首选 ArrayList，多插入中间仍评估成本；避免 LinkedList 在随机访问路径。
- 关键细节：LinkedList 节点对象开销；迭代器失效风险低但访问慢。
- 面试提示：纠正“链表插入 O(1)”误区（定位成本）。

---

## 性能工具与监控拆分

### 7.1 JFR (Java Flight Recorder) [5]
- 是什么：低开销事件采集框架。
- 为什么：生产可用持续监控。
- 怎么用：开启 profile / continuous 模式；分析事件：GC、线程、锁、分配。
- 关键细节：开销极低 <1%；与 Mission Control 配合。
- 面试提示：说明优于频繁堆 dump 的原因。

### 7.2 async-profiler 火焰图 [5]
- 是什么：采样 CPU / alloc / lock / wall / perf events。
- 为什么：快速热点定位。
- 怎么用：命令行触发 → 生成 svg；区分 on-cpu 与 off-cpu。
- 关键细节：采样避免安全点偏差；结合 JFR 互证。
- 面试提示：解释采样不等于精确时间线。

### 7.3 Arthas 在线诊断 [4]
- 是什么：运行时附加工具：trace、watch、jad、tt。
- 为什么：无需重启快速定位方法行为。
- 怎么用：tt 回放调用；trace 方法耗时链路。
- 关键细节：慎用高频 trace；生产安全策略。
- 面试提示：举一次实际故障排查流程。

### 7.4 GC 日志分析 [5]
- 是什么：结构化日志展示各阶段耗时与内存变化。
- 为什么：调优依据。
- 怎么用：-Xlog:gc* 收集；分类 Minor/Mixed/Full；计算晋升率。
- 关键细节：关注 Young 回收效率与老年代增长速度。
- 面试提示：展示“暂停时间与分配率相关性”分析。

### 7.5 关键监控指标体系 [5]
- 是什么：堆使用、Allocation Rate、GC Pause、CPU、线程数、锁等待、对象泄漏趋势。
- 为什么：持续预警容量与性能风险。
- 怎么用：分层仪表板；阈值告警；历史趋势。
- 关键细节：尾延迟与 GC/锁等待交叉分析。
- 面试提示：说明为什么仅看平均值不够。

---

## 延迟与吞吐拆分

### 8.1 延迟优化策略 [4]
- 是什么：减少单请求响应时间。
- 为什么：提升用户体验与 SLA。
- 怎么用：缩短临界区；减少大批量操作；使用低停顿 GC。
- 关键细节：p95/p99 监控；避免锁争用与长 GC。
- 面试提示：说明延迟与对象风暴关系。

### 8.2 吞吐优化策略 [4]
- 是什么：单位时间处理更多任务。
- 为什么：提升总体产出。
- 怎么用：批处理合并；扩大并行度；Parallel GC 或适度 G1 调优。
- 关键细节：可能牺牲尾延迟；批量大小与内存峰值权衡。
- 面试提示：给出吞吐优化副作用示例。

---

## 常见性能陷阱拆分

### 9.1 反射与动态代理过度使用 [4]
- 是什么：Method.invoke / CGLIB 频繁出现在热路径。
- 为什么：阻断内联与类型分析。
- 怎么用：缓存 MethodHandle；代码生成静态绑定。
- 关键细节：代理链过深；开销累积。
- 面试提示：提供“代理链裁剪”收益数据。

### 9.2 原生序列化与安全风险 [3]
- 是什么：ObjectInputStream 可执行 gadget 链。
- 为什么：性能差 + 安全隐患。
- 怎么用：替换为 JSON / ProtoBuf；白名单类。
- 关键细节：serialVersionUID 兼容困难。
- 面试提示：说明为何不推荐生产使用默认序列化。

---

## GC 诊断与案例拆分

### 10.1 老年代持续增长问题定位 [5]
- 是什么：缓存滥用或长寿对象滞留。
- 为什么：增加 Full GC 风险。
- 怎么用：堆直方图、引用链、对象保留大小分析。
- 关键细节：Weak/Soft 缓存策略不当；大集合未清理。
- 面试提示：讲清一个解决故事。

### 10.2 Humongous 对象频发 [4]
- 是什么：超阈值大对象跨 Region 分配。
- 为什么：影响 G1 回收效率。
- 怎么用：分块存储；压缩结构；池化。
- 关键细节：不参与常规回收；可能导致碎片。
- 面试提示：说明“为什么减少尺寸分片可降低停顿”。

---

## 启动与预热拆分

### 11.1 CDS / AppCDS [3]
- 是什么：类元数据归档提前加载。
- 为什么：减少启动 I/O 与解析。
- 怎么用：生成归档 → 启动参数加载。
- 关键细节：依赖类路径一致；修改需重新生成。
- 面试提示：区别标准 CDS 与应用归档。

### 11.2 JIT 预热策略 [3]
- 是什么：模拟负载使热点编译完成。
- 为什么：缩短达到峰值性能时间。
- 怎么用：压测脚本启动前跑预热阶段。
- 关键细节：避免真实数据污染缓存。
- 面试提示：说明预热与生产冷启动差异。

---

## FFI 与 Native 拆分

### 12.1 JNI 调用开销管理 [2]
- 是什么：Java ↔ C/C++ 边界切换。
- 为什么：高频切换影响性能。
- 怎么用：批量处理；缓存指针；最小跨界次数。
- 关键细节：异常处理复杂；安全风险。
- 面试提示：说明避免微粒度 JNI 调用。

### 12.2 Panama 外部内存访问 [2]
- 是什么：MemorySegment + Linker 提供安全高性能跨语言。
- 为什么：减少手工 JNI 样板。
- 怎么用：声明内存段；函数符号绑定。
- 关键细节：生命周期管理；还在演进。
- 面试提示：预测未来替代部分 JNI。

---

## 性能测试拆分

### 13.1 JMH 微基准框架 [4]
- 是什么：防止虚假优化的标准工具。
- 为什么：精确测局部变更收益。
- 怎么用：@Benchmark + Warmup/Fork/Measurement。
- 关键细节：黑洞防死代码；独立进程 fork 防 JIT 污染。
- 面试提示：强调与集成压测的区别。

### 13.2 压测与真实流量回放 [4]
- 是什么：模拟生产并发 / 数据分布。
- 为什么：验证系统整体行为与容量。
- 怎么用：录制生产请求 → 回放；区分预热与测量阶段。
- 关键细节：环境隔离；速率与并发分层。
- 面试提示：说明只用微基准的风险。

---

## 调优流程与实践拆分

### 14.1 数据驱动调优流水线 [5]
- 是什么：目标→基线→定位→改动→验证→回滚。
- 为什么：减少盲目修改与回归风险。
- 怎么用：建立基线报表；单变量改动；记录差异。
- 关键细节：先算法后参数；避免同时多改动。
- 面试提示：复述并强调可回滚性。

### 14.2 关键指标关联分析 [4]
- 是什么：将 GC、锁、CPU、延迟、分配率关联。
- 为什么：识别根因与连锁效应。
- 怎么用：时间线叠加；事件→指标跳转。
- 关键细节：锁等待拉高 + GC 增加 = 双重延迟源。
- 面试提示：举一个多因素共振案例。


## 重要度汇总（更新）
- 堆/分代/TLAB/对象头/GC 算法/收集器选择/GC 日志/调优流程/工具栈/监控指标/Concurrent GC 原理：[5]
- 老年代压力/Humongous/内联/复制/写屏障/三色标记/缓存策略/性能工具/延迟与吞吐/数据结构选择/JMH/压测：[4]
- 元空间/逃逸分析/锁消除/反射陷阱/直接内存/启动预热/Safepoint/JIT 分层/引用类型/并发标记细节：[3]
- JNI/Panama/CDS/ServiceLoader/SP 模块细节/Epsilon 收集器：[2]


## 常见面试延伸问答示例
1. 为什么对象要分年轻代与老年代？生命周期分布差异降低扫描与复制成本。  
2. G1 如何达到暂停预测？基于 Region 统计与目标暂停时间选择回收集合。  
3. ZGC 与 G1 的核心差异？ZGC 使用颜色指针 + 并发重定位，停顿更低；G1 Region + 混合回收。  
4. 什么是 Humongous 对象？在 G1 中超过 Region 大小阈值（>50% 一个 Region 或多个连续 Region）的大对象特殊处理。  
5. 为什么频繁 Full GC？晋升失败、老年代满、大对象分配失败或元空间不足。  
6. 如何判断是否存在类元数据泄漏？Metaspace 持续增长且类卸载数低，ClassLoader 保持强引用。  
7. 为什么内联提高性能？减少调用开销并触发更多优化（常量折叠、循环优化）。  
8. 什么是逃逸分析的实际收益？锁消除与标量替换减少同步与对象分配。  
9. 为什么反射影响 JIT？阻碍内联与类型稳定分析。  
10. Allocation Rate 高应做什么？减少临时对象、复用缓冲、调整数据结构。  
11. 如何快速定位老年代膨胀？堆直方图 + 引用链分析 + 对象保留大小评估。  
12. 使用 Parallel 收集器的风险？停顿时间长，尾延迟较高。  
13. G1 Pause 目标调得过低结果？频繁 Young GC / Mixed GC，吞吐下降。  
14. 为什么说平均延迟不可靠？掩盖 p95/p99 尾部高延迟真实用户体验。  
15. SafePoint 造成长停顿的常见原因？大量线程或长时间执行本地代码阻止快速到达。  
16. 为什么要固定 -Xms 与 -Xmx？避免堆动态扩缩造成额外暂停与碎片。  
17. 哪些场景适合直接内存？高频 I/O、零拷贝传输；不适合大量小对象分配。  
18. 原生序列化不推荐原因？性能差、版本兼容脆弱、安全风险。  
19. 如何验证一次性能优化有效？对比基线指标（延迟、吞吐、GC）并做回归测试。  
20. JFR 与 async-profiler 组合优势？JFR 全局低开销事件，async-profiler 精确热点火焰图。  
21. 为什么替换 LinkedList 为 ArrayList 多数更优？连续内存提升局部性与缓存命中，降低指针追逐。  
22. 什么是 Card Table？记录跨代引用的脏卡，减少全堆扫描范围。  
23. 为什么 metaspace 溢出会触发 Full GC？尝试回收卸载类腾出元空间。  
24. 什么时候应考虑 ZGC？堆很大（数十 GB+）且延迟敏感。  
25. 锁消除条件是什么？对象与锁未逃逸出方法或线程上下文。  

(完)