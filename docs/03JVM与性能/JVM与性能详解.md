# JVM 与性能面试指南（加强版：逐条细化版）

评分：5=必须掌握，4=很重要，3=熟练更佳，2=了解即可，1=加分项  
说明：将原来的综合条目拆分为更细粒度，一个条目聚焦一个子知识点；仍按“是什么 / 为什么 / 怎么用 / 关键细节 / 面试提示”结构，便于被持续追问。

---

## 内存运行时结构与对象布局（拆分）

### 1.1 Java 堆概览 [5]
- 是什么：所有对象实例与数组存放区；分年轻代 (Eden + Survivor) 与老年代；G1/ZGC 等进一步按 Region 分片。
- 为什么：对象生命周期分层管理，降低回收成本，优化停顿时间。
- 怎么用：通过 `-Xms/-Xmx` 固定堆；根据分配速率与暂停目标选收集器。
- 关键细节：年轻对象朝生夕死 → 复制算法；老年代回收频率低 → 标记整理；大对象直接老年代。
- 常见陷阱：认为“堆越大性能越好”，忽略大堆 Full GC 的高昂成本；堆太小导致频繁 GC。
- 面试提示：解释为何“多数对象短命”这一假设是分代设计的基石。
- 案例：某服务 `-Xmx` 从 16G 降到 10G 并启用 G1，GC 平均停顿从 800ms 降到 150ms，整体 QPS 提升 10%。
- 速记：堆=对象主战场；分代匹配生命周期；合适才最优，非越大越好。

### 1.2 年轻代结构 (Eden/Survivor) 与晋升 [5]
- 是什么：Eden 初次分配；对象存活经多次 Minor GC 在 S0/S1 间复制并增龄，达阈值或空间不足晋升老年代。
- 为什么：快速回收“朝生夕死”对象，减少全堆扫描。
- 怎么用：调 `-XX:NewRatio` 或 G1 年轻代比例；避免 Survivor 太小导致过度晋升。
- 关键细节：对象年龄记录在对象头；动态年龄判定（同龄对象累计大小超 Survivor 一半）。
- 常见陷阱：Survivor 空间过小，导致大量短命对象过早晋升，增加老年代压力。
- 面试提示：讲清楚“晋升失败”如何一步步触发 Full GC 的链条反应。
- 案例：高分配率服务增加 Survivor 空间后，老年代增长速率减缓 70%，Full GC 频率从每小时数次降至一天一次。
- 速记：Eden 出生，Survivor 考验，老年代养老；年龄或空间压力决定晋升。

### 1.3 老年代与空间压力 [5]
- 是什么：存放长寿命或直接晋升的大对象；回收成本高，频率低。
- 为什么：为长生命周期对象提供稳定存储，避免被频繁 Minor GC 扫描。
- 怎么用：监控 Old Gen 增长曲线；优化大 Map 缓存策略，使用软/弱引用。
- 关键细节：老年代碎片是 CMS 等非压缩收集器的痛点；并发标记周期决定回收触发时机。
- 常见陷阱：无限制的本地缓存（如 Guava Cache 未设上限）持续填满老年代。
- 面试提示：说明老年代持续上涨的几种可能原因（泄漏、缓存、晋升过快）及对应调优策略。
- 案例：通过分析堆 Dump，发现一个静态 `HashMap` 缓存了所有历史订单，改为 LRU 策略后老年代占用下降 90%。
- 速记：老年代是“养老院”，增长过快是警报；缓存、泄漏是主因。

### 1.4 TLAB (Thread Local Allocation Buffer) [4]
- 是什么：JVM 在 Eden 区为每条线程分配的私有缓冲区，用于分配小对象。
- 为什么：避免多线程分配对象时对堆内存加锁的开销，提升分配效率。
- 怎么用：默认开启，通常无需调整。通过 `-XX:+PrintTLAB` 可诊断 TLAB 分配情况。
- 关键细节：TLAB 用完或对象过大时，会走慢路径（CAS 或加锁）在共享 Eden 分配。
- 常见陷阱：误以为所有对象分配都是无锁的，忽略了 TLAB refill 和大对象分配的同步开销。
- 面试提示：能清晰说出“为什么多线程下小对象分配仍可近似无锁”，点出 TLAB 是关键。
- 案例：在性能分析中，若发现 `eden_alloc` 或类似锁竞争热点，可能是 TLAB 设置不当或小对象过多。
- 速记：线程私有分配区，小对象分配加速器，避免“抢地盘”。

### 1.5 元空间 (Metaspace) [4]
- 是什么：存储类元数据（方法、字段、常量池、字节码等）的本地内存区域。
- 为什么：摆脱永久代固定大小限制，与堆解耦，降低 OOM 风险。
- 怎么用：监控使用率；限制动态类生成；正确处理类卸载条件。
- 关键细节：类卸载需同时满足：无存活实例、其 ClassLoader 可被回收、无其他地方引用 Class 对象。
- 常见陷阱：动态代理（CGLIB/JDK Proxy）或 Groovy 等脚本语言滥用，生成大量无法卸载的类。
- 面试提示：最常见的泄漏原因是“自定义 ClassLoader 实例被长生命周期对象（如线程池、静态集合）强引用”。
- 案例：某热部署系统频繁 OOM，MAT 分析发现大量旧版本的 ClassLoader 实例被 Tomcat 的 `ThreadLocal` 引用，无法卸载。
- 速记：类的家，在本地内存；ClassLoader 泄漏是其头号杀手。

### 1.6 Java 栈与栈帧 [5]
- 是什么：每条线程私有，用于存储方法调用的栈帧（含局部变量表、操作数栈、动态链接等）。
- 为什么：实现函数调用、参数传递和局部变量隔离，保证线程安全。
- 怎么用：通过 `-Xss` 控制栈大小；防止无限递归导致 `StackOverflowError`。
- 关键细节：栈上数据线程私有，无需同步；栈帧大小在编译期基本确定。
- 常见陷阱：误认为栈越大越好，导致在相同内存下能创建的线程数减少。
- 面试提示：清晰区分 `StackOverflowError`（栈深度溢出）与 `OutOfMemoryError: unable to create new native thread`（无法创建新线程）。
- 案例：一个深度递归的 JSON 解析函数，在处理复杂结构时频繁抛出 `StackOverflowError`，后改为迭代实现解决。
- 速记：方法调用的“记事本”，线程私有；无限递归是其噩梦。

### 1.7 程序计数器 / 本地方法栈 [3]
- 是什么：PC 保存当前线程执行的字节码指令地址；本地方法栈服务于 JNI (Native) 调用。
- 为什么：PC 保证字节码解释与线程切换后能正确恢复；本地方法栈隔离 Java 与 Native 调用。
- 怎么用：一般无需用户干预或调参；但需关注过度 JNI 调用带来的性能和稳定性问题。
- 关键细节：PC 是唯一不会发生 `OutOfMemoryError` 的区域；本地方法栈错误可能直接导致 JVM 崩溃。
- 常见陷阱：忽略 JNI 调用也是潜在的内存泄漏源（Native Heap Leak）。
- 面试提示：能清晰说明为何 PC 是线程私有且不会 OOM。
- 案例：某图像处理服务使用 JNI 库，因 Native 代码内存未释放，导致进程 RSS 持续增长，最终被系统 OOM Killer 终止。
- 速记：PC=指令导航仪；本地方法栈=JNI 调用专用栈。

### 1.8 直接内存 (Off-heap) [4]
- 是什么：使用 `ByteBuffer.allocateDirect` 或 JNI 在 Java 堆外分配的内存。
- 为什么：减少 Java 堆与 Native 堆之间的数据复制，提升 I/O 性能（零拷贝）。
- 怎么用：用于 Netty、NIO 等高性能 I/O 场景；通过 `-XX:MaxDirectMemorySize` 控制上限。
- 关键细节：其回收依赖于 `Cleaner` (虚引用)，由 GC 触发，不及时；泄漏难于通过堆 Dump 发现。
- 常见陷阱：忘记手动释放（如 Netty 的 `ByteBuf.release()`），导致直接内存泄漏。
- 面试提示：清晰说明堆内 OOM 与直接内存 OOM 的排查路径差异（前者用 MAT，后者靠 `jcmd` 或 `NMT`）。
- 案例：一个 Netty 服务因未正确释放 `ByteBuf`，导致直接内存耗尽，抛出 `OutOfMemoryError: Direct buffer memory`。
- 速记：堆外高速公路，I/O 加速器；忘记释放是灾难。

### 1.9 对象头与布局 (Mark Word / Klass Pointer) [5]
- 是什么：每个对象都有一个头部，Mark Word 存储哈希码、GC 年龄、锁状态；Klass Pointer 指向其类元数据。
- 为什么：为对象提供运行时元信息，并作为 `synchronized` 锁机制的基础。
- 怎么用：通过 JOL (Java Object Layout) 工具查看对象实际布局；优化字段顺序可减少内存填充。
- 关键细节：64位系统默认开启压缩指针（-XX:+UseCompressedOops），节省内存；锁状态在 Mark Word 中迁移（无锁→偏向→轻量→重量）。
- 常见陷阱：在需要精确计算内存占用的场景，忽略了对象头和对齐填充的大小。
- 面试提示：能解释 `synchronized` 锁升级过程中，Mark Word 的内容是如何变化的。
- 案例：通过 JOL 分析发现某个常用对象因字段顺序不当，多出 8 字节的对齐填充，调整后节省了大量内存。
- 速记：对象的“身份证”，存着年龄、锁状态和类型指针。

### 1.10 四种引用类型 (强/软/弱/虚) [4]
- 是什么：控制对象可达性与回收时机。强引用：不回收；软引用：内存不足时回收；弱引用：下次 GC 时回收；虚引用：跟踪对象回收。
- 为什么：实现灵活的缓存策略和资源清理机制。
- 怎么用：软引用可用于实现内存敏感缓存；弱引用（`WeakHashMap`）用于元数据映射；虚引用与 `ReferenceQueue` 结合实现 `Cleaner`。
- 关键细节：软引用并不能完全替代 LRU 等缓存淘汰策略；虚引用的 `get()` 方法永远返回 `null`。
- 常见陷阱：过度依赖软/弱引用做缓存，导致性能抖动，因为回收时机不确定。
- 面试提示：清晰说明“仅有软/弱引用”的对象，在什么条件下会被回收。
- 案例：一个图片缓存系统使用软引用，在高负载下因内存压力频繁 GC，导致缓存命中率急剧下降，后改为固定大小的 LRU 缓存+磁盘二级缓存解决。
- 速记：强=永不放手；软=内存紧张时放手；弱=看见就放手；虚=放手后通知你。


---

## GC 基础与算法（拆分）

### 2.1 标记-清除算法 [4]
- 是什么：遍历可达对象标记，再清除未标记内存。
- 为什么：实现基本回收，避免复制整堆。
- 怎么用：老年代并发回收阶段使用；CMS 典型。
- 关键细节：产生碎片；需要后续压缩或碎片管理。
- 面试提示：指出碎片导致分配失败触发 Full GC。

### 2.2 标记-整理算法 [5]
- 是什么：标记后将存活对象向一端移动并整理空间。
- 为什么：消除碎片，支持大对象连续分配。
- 怎么用：老年代压缩阶段；Serial Old / CMS Full / G1 Mixed。
- 关键细节：对象移动需要更新引用；停顿时间较标记清除高。
- 面试提示：解释与复制算法的区别（跨区域 vs 整体）。

### 2.3 复制算法 [5]
- 是什么：将存活对象从 From 区复制到 To 区并清空原区。
- 为什么：分配指针重置，效率高。
- 怎么用：年轻代 Minor GC；Eden + Survivor。
- 关键细节：需预留未使用空间；高存活率降低效率。
- 面试提示：说明适用于“存活率低”的区域。

### 2.4 三色标记与并发安全 [4]
- 是什么：对象初始白色；扫描置灰；处理完成置黑；最终白色为不可达。
- 为什么：并发标记中避免漏标与误标。
- 怎么用：写屏障记录黑对象指向新白对象的变更；重标阶段修正。
- 关键细节：漂白问题通过 SATB（快照）或增量更新解决。
- 面试提示：讲 SATB 与增量更新差异（ZGC vs G1）。

### 2.5 写屏障 / Remembered Set [5]
- 是什么：记录跨分代引用或并发标记时修改的指针。
- 为什么：减少全堆扫描，提高并发安全。
- 怎么用：分代制度下更新指针写 card；G1 使用 Remembered Set 维护跨 Region 引用。
- 关键细节：写屏障增加写成本；Remembered Set 过大影响性能。
- 面试提示：说明为什么“大量跨代引用”会拖慢 GC。

### 2.6 分代回收策略 [5]
- 是什么：按对象生命周期分年轻与老年代。
- 为什么：降低扫描与复制成本，匹配对象生存曲线。
- 怎么用：调年轻比例；控制晋升速率；利用统计数据优化阈值。
- 关键细节：晋升失败导致 Full GC；动态年龄判断。
- 面试提示：解释为何不再仅仅是“两个区”而是细粒度 Region。

### 2.7 STW 与并发回收阶段 [4]
- 是什么：Stop-The-World 暂停所有应用线程执行 GC 阶段；并发阶段与应用并行执行。
- 为什么：保证内存结构一致性。
- 怎么用：G1/ZGC 尽量缩短 STW，扩大并发部分。
- 关键细节：Safepoint 到达时间影响总暂停；并发阶段可能回收不足引发补偿 GC。
- 面试提示：区分“并发”与“并行”回收。

### 2.8 Finalization 与 Cleaner [3]
- 是什么：finalize 过时且不可预测；Cleaner 使用虚引用回调释放资源。
- 为什么：避免 GC 次序不确定造成延迟释放。
- 怎么用：使用 try-with-resources 和 Cleaner 替代 finalize。
- 关键细节：finalize 队列延迟执行；可能复活对象。
- 面试提示：强调“不依赖 finalize 做关键资源释放”。

---

## 垃圾收集器（逐个）

### 3.1 Serial / Serial Old [3]
- 是什么：单线程收集器；年轻代复制，老年代标记整理。
- 为什么：简单、适合小堆与单核环境。
- 怎么用：测试或微服务极小堆场景。
- 关键细节：停顿长；无并发能力；易预测。
- 面试提示：说明不适合生产大堆。

### 3.2 Parallel Scavenge / Parallel Old [4]
- 是什么：多线程并行回收，吞吐优先。
- 为什么：批处理类应用追求最大吞吐。
- 怎么用：通过 -XX:MaxGCPauseMillis 尝试延迟控制但以吞吐为主；调整 -XX:ParallelGCThreads。
- 关键细节：停顿仍较长；不关注低延迟尾部。
- 面试提示：区分与 G1：无复杂 Region 模型。

### 3.3 CMS (已淘汰) [3]
- 是什么：并发标记清除，降低老年代停顿。
- 为什么：历史上的低暂停选择。
- 怎么用：新版本已被 G1/ZGC 取代。
- 关键细节：碎片风险；Concurrent Mode Failure → Full GC。
- 面试提示：说明弃用原因。

### 3.4 G1 (Garbage-First) [5]
- 是什么：Region 划分 + 年轻/混合回收 + 暂停预测模型。
- 为什么：在大堆获得相对可控停顿。
- 怎么用：设置 -XX:MaxGCPauseMillis；监控混合回收频率；优化 Humongous 对象。
- 关键细节：Remembered Set 开销；Humongous 分配跨 Region；并发标记 + Evacuation。
- 面试提示：解释暂停预测依据：历史统计 + 回收集大小估算。

### 3.5 ZGC [5]
- 是什么：低停顿收集器：颜色指针 + 并发重定位。
- 为什么：超大堆 <~ TB 级低延迟。
- 怎么用：启用 -XX:+UseZGC；监控并发周期；关注引用修复开销。
- 关键细节：Load Barrier 更新指针；无长时间 STW；支持大对象。
- 面试提示：对比 G1：真正并发移动对象。

### 3.6 Shenandoah [4]
- 是什么：Brooks Pointer + 并发 Evacuation 实现低停顿。
- 为什么：低延迟堆回收选择，特别在 OpenJDK 社区。
- 怎么用：-XX:+UseShenandoahGC；监控并发阶段时间。
- 关键细节：指针转发；全堆并发 evacuation；吞吐略低。
- 面试提示：说明与 ZGC 的实现差异（颜色指针 vs Brooks Pointer）。

### 3.7 Epsilon (No-Op GC) [2]
- 是什么：不做回收，仅分配，堆用尽退出。
- 为什么：性能测试基线或极短生命周期应用。
- 怎么用：确保应用在堆耗尽前结束。
- 关键细节：无回收；仅适用于实验。
- 面试提示：指出不可用于生产。

### 3.8 收集器选择指南 [5]
- 是什么：基于堆大小、延迟目标、吞吐、版本成熟度选择策略。
- 为什么：避免错误选型造成不可达指标。
- 怎么用：延迟敏感大堆：ZGC；中大堆：G1；吞吐批处理：Parallel；试验低延迟：Shenandoah。
- 关键细节：版本兼容与监控成熟度。
- 面试提示：用场景映射具体选择。

---

## 类加载与模块化拆分

### 4.1 双亲委派模型 [5]
- 是什么：加载请求自下向上委派，先父再子。
- 为什么：避免核心类被篡改，保证一致性。
- 怎么用：自定义 ClassLoader 时保留委派逻辑；插件隔离打破委派需谨慎。
- 关键细节：findClass vs loadClass 区别；上下文 ClassLoader 解决 SPI。
- 面试提示：说明打破委派潜在安全风险。

### 4.2 ClassLoader 泄漏与卸载条件 [4]
- 是什么：ClassLoader 未被回收导致 Metaspace 增长。
- 为什么：影响内存与 GC 频率。
- 怎么用：清理静态缓存引用；弱引用持有临时类映射。
- 关键细节：实例、Class、本地缓存任何强引用都阻止卸载。
- 面试提示：描述典型“热部署”泄漏场景。

### 4.3 JPMS 模块系统基础 [4]
- 是什么：module-info.java 声明依赖、导出、开放；模块路径与类路径分离。
- 为什么：强封装与显式依赖控制；减少类冲突。
- 怎么用：exports 暴露 API；opens 反射访问；uses/provides SPI。
- 关键细节：自动模块名冲突；未导出的包不可访问。
- 面试提示：说明与 OSGi 的主要差异：编译时强依赖图。

### 4.4 ServiceLoader 与 SPI [3]
- 是什么：基于配置文件提供服务实现动态发现。
- 为什么：低耦合扩展点。
- 怎么用：META-INF/services/ 接口全限定名列实现类。
- 关键细节：惰性迭代；线程安全实现需自行保证。
- 面试提示：指出缺点：不支持条件加载与版本选择。

---

## JIT 与同步优化拆分

### 5.1 分层编译 (Tiered Compilation) [4]
- 是什么：C1 快速编译 + Profiling，C2 高级优化。
- 为什么：兼顾启动速度与峰值性能。
- 怎么用：默认开启；分析 -XX:+PrintCompilation 输出。
- 关键细节：OSR 进入已运行热循环；去优化重新进入解释模式。
- 面试提示：解释为什么冷启动期间性能较低。

### 5.2 方法内联 (Inlining) [5]
- 是什么：将调用目标代码直接嵌入调用点。
- 为什么：去除调用开销，触发更多优化。
- 怎么用：减少过大方法与深层分支；避免多态调用阻碍内联。
- 关键细节：大小阈值与热度限制；Megamorphic 调用难内联。
- 面试提示：举“内联→常量传播→死代码删除”链条案例。

### 5.3 逃逸分析与标量替换 [4]
- 是什么：对象未逃逸方法 → 拆为局部标量。
- 为什么：减少堆分配与 GC 压力。
- 怎么用：避免返回内部可变对象；减少共享。
- 关键细节：栈上分配未全面；优化受复杂控制流影响。
- 面试提示：区分概念与实际限制。

### 5.4 锁消除与锁粗化 [3]
- 是什么：消除不可逃逸对象上的冗余锁；合并频繁小临界区。
- 为什么：减少同步开销或震荡。
- 怎么用：简化对象作用域；减少无必要同步。
- 关键细节：JIT 分析逃逸结果；粗化可能延长持锁。
- 面试提示：说明“性能不是简单加锁/减锁”的平衡。

---

## 内存与对象优化拆分

### 6.1 装箱与拆箱成本 [4]
- 是什么：基本类型与包装类型转换产生临时对象。
- 为什么：多余对象增加 GC。
- 怎么用：使用原始类型集合（TIntArrayList 等第三方）或基本数组。
- 关键细节：Integer 缓存 [-128,127]；频繁自动装箱隐藏分配。
- 面试提示：指出在热路径日志拼接的装箱问题。

### 6.2 字符串处理优化 [4]
- 是什么：避免多次拼接创建临时对象。
- 为什么：降低 Allocation Rate。
- 怎么用：StringBuilder / format 缓存；减少 substring 大对象保留（JDK8 起独立数组）。
- 关键细节：intern 过度使用常量池膨胀。
- 面试提示：说明为什么循环中 + 拼接低效。

### 6.3 缓存与容量控制 [5]
- 是什么：对象留存老年代影响回收。
- 为什么：防止内存膨胀与 Full GC。
- 怎么用：LRU / LFU / 计时淘汰；软引用结合显式限制。
- 关键细节：仅软引用不可控；统计命中率评估价值。
- 面试提示：讲一个“缓存上限 + 命中率”调优案例。

### 6.4 数据结构选择 (ArrayList vs LinkedList) [4]
- 是什么：不同存储布局特性。
- 为什么：局部性与随机访问性能差异。
- 怎么用：首选 ArrayList，多插入中间仍评估成本；避免 LinkedList 在随机访问路径。
- 关键细节：LinkedList 节点对象开销；迭代器失效风险低但访问慢。
- 面试提示：纠正“链表插入 O(1)”误区（定位成本）。

---

## 性能工具与监控拆分

### 7.1 JFR (Java Flight Recorder) [5]
- 是什么：低开销事件采集框架。
- 为什么：生产可用持续监控。
- 怎么用：开启 profile / continuous 模式；分析事件：GC、线程、锁、分配。
- 关键细节：开销极低 <1%；与 Mission Control 配合。
- 面试提示：说明优于频繁堆 dump 的原因。

### 7.2 async-profiler 火焰图 [5]
- 是什么：采样 CPU / alloc / lock / wall / perf events。
- 为什么：快速热点定位。
- 怎么用：命令行触发 → 生成 svg；区分 on-cpu 与 off-cpu。
- 关键细节：采样避免安全点偏差；结合 JFR 互证。
- 面试提示：解释采样不等于精确时间线。

### 7.3 Arthas 在线诊断 [4]
- 是什么：运行时附加工具：trace、watch、jad、tt。
- 为什么：无需重启快速定位方法行为。
- 怎么用：tt 回放调用；trace 方法耗时链路。
- 关键细节：慎用高频 trace；生产安全策略。
- 面试提示：举一次实际故障排查流程。

### 7.4 GC 日志分析 [5]
- 是什么：结构化日志展示各阶段耗时与内存变化。
- 为什么：调优依据。
- 怎么用：-Xlog:gc* 收集；分类 Minor/Mixed/Full；计算晋升率。
- 关键细节：关注 Young 回收效率与老年代增长速度。
- 面试提示：展示“暂停时间与分配率相关性”分析。

### 7.5 关键监控指标体系 [5]
- 是什么：堆使用、Allocation Rate、GC Pause、CPU、线程数、锁等待、对象泄漏趋势。
- 为什么：持续预警容量与性能风险。
- 怎么用：分层仪表板；阈值告警；历史趋势。
- 关键细节：尾延迟与 GC/锁等待交叉分析。
- 面试提示：说明为什么仅看平均值不够。

---

## 延迟与吞吐拆分

### 8.1 延迟优化策略 [4]
- 是什么：减少单请求响应时间。
- 为什么：提升用户体验与 SLA。
- 怎么用：缩短临界区；减少大批量操作；使用低停顿 GC。
- 关键细节：p95/p99 监控；避免锁争用与长 GC。
- 面试提示：说明延迟与对象风暴关系。

### 8.2 吞吐优化策略 [4]
- 是什么：单位时间处理更多任务。
- 为什么：提升总体产出。
- 怎么用：批处理合并；扩大并行度；Parallel GC 或适度 G1 调优。
- 关键细节：可能牺牲尾延迟；批量大小与内存峰值权衡。
- 面试提示：给出吞吐优化副作用示例。

---

## 常见性能陷阱拆分

### 9.1 反射与动态代理过度使用 [4]
- 是什么：Method.invoke / CGLIB 频繁出现在热路径。
- 为什么：阻断内联与类型分析。
- 怎么用：缓存 MethodHandle；代码生成静态绑定。
- 关键细节：代理链过深；开销累积。
- 面试提示：提供“代理链裁剪”收益数据。

### 9.2 原生序列化与安全风险 [3]
- 是什么：ObjectInputStream 可执行 gadget 链。
- 为什么：性能差 + 安全隐患。
- 怎么用：替换为 JSON / ProtoBuf；白名单类。
- 关键细节：serialVersionUID 兼容困难。
- 面试提示：说明为何不推荐生产使用默认序列化。

---

## GC 诊断与案例拆分

### 10.1 老年代持续增长问题定位 [5]
- 是什么：缓存滥用或长寿对象滞留。
- 为什么：增加 Full GC 风险。
- 怎么用：堆直方图、引用链、对象保留大小分析。
- 关键细节：Weak/Soft 缓存策略不当；大集合未清理。
- 面试提示：讲清一个解决故事。

### 10.2 Humongous 对象频发 [4]
- 是什么：超阈值大对象跨 Region 分配。
- 为什么：影响 G1 回收效率。
- 怎么用：分块存储；压缩结构；池化。
- 关键细节：不参与常规回收；可能导致碎片。
- 面试提示：说明“为什么减少尺寸分片可降低停顿”。

---

## 启动与预热拆分

### 11.1 CDS / AppCDS [3]
- 是什么：类元数据归档提前加载。
- 为什么：减少启动 I/O 与解析。
- 怎么用：生成归档 → 启动参数加载。
- 关键细节：依赖类路径一致；修改需重新生成。
- 面试提示：区别标准 CDS 与应用归档。

### 11.2 JIT 预热策略 [3]
- 是什么：模拟负载使热点编译完成。
- 为什么：缩短达到峰值性能时间。
- 怎么用：压测脚本启动前跑预热阶段。
- 关键细节：避免真实数据污染缓存。
- 面试提示：说明预热与生产冷启动差异。

---

## FFI 与 Native 拆分

### 12.1 JNI 调用开销管理 [2]
- 是什么：Java ↔ C/C++ 边界切换。
- 为什么：高频切换影响性能。
- 怎么用：批量处理；缓存指针；最小跨界次数。
- 关键细节：异常处理复杂；安全风险。
- 面试提示：说明避免微粒度 JNI 调用。

### 12.2 Panama 外部内存访问 [2]
- 是什么：MemorySegment + Linker 提供安全高性能跨语言。
- 为什么：减少手工 JNI 样板。
- 怎么用：声明内存段；函数符号绑定。
- 关键细节：生命周期管理；还在演进。
- 面试提示：预测未来替代部分 JNI。

---

## 性能测试拆分

### 13.1 JMH 微基准框架 [4]
- 是什么：防止虚假优化的标准工具。
- 为什么：精确测局部变更收益。
- 怎么用：@Benchmark + Warmup/Fork/Measurement。
- 关键细节：黑洞防死代码；独立进程 fork 防 JIT 污染。
- 面试提示：强调与集成压测的区别。

### 13.2 压测与真实流量回放 [4]
- 是什么：模拟生产并发 / 数据分布。
- 为什么：验证系统整体行为与容量。
- 怎么用：录制生产请求 → 回放；区分预热与测量阶段。
- 关键细节：环境隔离；速率与并发分层。
- 面试提示：说明只用微基准的风险。

---

## 调优流程与实践拆分

### 14.1 数据驱动调优流水线 [5]
- 是什么：目标→基线→定位→改动→验证→回滚。
- 为什么：减少盲目修改与回归风险。
- 怎么用：建立基线报表；单变量改动；记录差异。
- 关键细节：先算法后参数；避免同时多改动。
- 面试提示：复述并强调可回滚性。

### 14.2 关键指标关联分析 [4]
- 是什么：将 GC、锁、CPU、延迟、分配率关联。
- 为什么：识别根因与连锁效应。
- 怎么用：时间线叠加；事件→指标跳转。
- 关键细节：锁等待拉高 + GC 增加 = 双重延迟源。
- 面试提示：举一个多因素共振案例。


## 重要度汇总（更新）
- 堆/分代/TLAB/对象头/GC 算法/收集器选择/GC 日志/调优流程/工具栈/监控指标/Concurrent GC 原理：[5]
- 老年代压力/Humongous/内联/复制/写屏障/三色标记/缓存策略/性能工具/延迟与吞吐/数据结构选择/JMH/压测：[4]
- 元空间/逃逸分析/锁消除/反射陷阱/直接内存/启动预热/Safepoint/JIT 分层/引用类型/并发标记细节：[3]
- JNI/Panama/CDS/ServiceLoader/SP 模块细节/Epsilon 收集器：[2]


## 常见面试延伸问答示例
1. 为什么对象要分年轻代与老年代？生命周期分布差异降低扫描与复制成本。  
2. G1 如何达到暂停预测？基于 Region 统计与目标暂停时间选择回收集合。  
3. ZGC 与 G1 的核心差异？ZGC 使用颜色指针 + 并发重定位，停顿更低；G1 Region + 混合回收。  
4. 什么是 Humongous 对象？在 G1 中超过 Region 大小阈值（>50% 一个 Region 或多个连续 Region）的大对象特殊处理。  
5. 为什么频繁 Full GC？晋升失败、老年代满、大对象分配失败或元空间不足。  
6. 如何判断是否存在类元数据泄漏？Metaspace 持续增长且类卸载数低，ClassLoader 保持强引用。  
7. 为什么内联提高性能？减少调用开销并触发更多优化（常量折叠、循环优化）。  
8. 什么是逃逸分析的实际收益？锁消除与标量替换减少同步与对象分配。  
9. 为什么反射影响 JIT？阻碍内联与类型稳定分析。  
10. Allocation Rate 高应做什么？减少临时对象、复用缓冲、调整数据结构。  
11. 如何快速定位老年代膨胀？堆直方图 + 引用链分析 + 对象保留大小评估。  
12. 使用 Parallel 收集器的风险？停顿时间长，尾延迟较高。  
13. G1 Pause 目标调得过低结果？频繁 Young GC / Mixed GC，吞吐下降。  
14. 为什么说平均延迟不可靠？掩盖 p95/p99 尾部高延迟真实用户体验。  
15. SafePoint 造成长停顿的常见原因？大量线程或长时间执行本地代码阻止快速到达。  
16. 为什么要固定 -Xms 与 -Xmx？避免堆动态扩缩造成额外暂停与碎片。  
17. 哪些场景适合直接内存？高频 I/O、零拷贝传输；不适合大量小对象分配。  
18. 原生序列化不推荐原因？性能差、版本兼容脆弱、安全风险。  
19. 如何验证一次性能优化有效？对比基线指标（延迟、吞吐、GC）并做回归测试。  
20. JFR 与 async-profiler 组合优势？JFR 全局低开销事件，async-profiler 精确热点火焰图。  
21. 为什么替换 LinkedList 为 ArrayList 多数更优？连续内存提升局部性与缓存命中，降低指针追逐。  
22. 什么是 Card Table？记录跨代引用的脏卡，减少全堆扫描范围。  
23. 为什么 metaspace 溢出会触发 Full GC？尝试回收卸载类腾出元空间。  
24. 什么时候应考虑 ZGC？堆很大（数十 GB+）且延迟敏感。  
25. 锁消除条件是什么？对象与锁未逃逸出方法或线程上下文。  

(完)