# JVM 与性能面试指南（加强版：逐条细化版）

评分：5=必须掌握，4=很重要，3=熟练更佳，2=了解即可，1=加分项  
说明：将原来的综合条目拆分为更细粒度，一个条目聚焦一个子知识点；仍按“是什么 / 为什么 / 怎么用 / 关键细节 / 面试提示”结构，便于被持续追问。

---

## 内存运行时结构与对象布局

### 1.1 Java 堆概览 [5]
- 是什么：所有对象实例与数组存放区；分年轻代 (Eden + Survivor) 与老年代；G1/ZGC 等进一步按 Region 分片。
- 为什么：对象生命周期分层管理，降低回收成本，优化停顿时间。
- 怎么用：通过 `-Xms/-Xmx` 固定堆；根据分配速率与暂停目标选收集器。
- 关键细节：年轻对象朝生夕死 → 复制算法；老年代回收频率低 → 标记整理；大对象直接老年代。
- 常见陷阱：认为“堆越大性能越好”，忽略大堆 Full GC 的高昂成本；堆太小导致频繁 GC。
- 面试提示：解释为何“多数对象短命”这一假设是分代设计的基石。
- 案例：某服务 `-Xmx` 从 16G 降到 10G 并启用 G1，GC 平均停顿从 800ms 降到 150ms，整体 QPS 提升 10%。
- 速记：堆=对象主战场；分代匹配生命周期；合适才最优，非越大越好。

### 1.2 年轻代结构 (Eden/Survivor) 与晋升 [5]
- 是什么：Eden 初次分配；对象存活经多次 Minor GC 在 S0/S1 间复制并增龄，达阈值或空间不足晋升老年代。
- 为什么：快速回收“朝生夕死”对象，减少全堆扫描。
- 怎么用：调 `-XX:NewRatio` 或 G1 年轻代比例；避免 Survivor 太小导致过度晋升。
- 关键细节：对象年龄记录在对象头；动态年龄判定（同龄对象累计大小超 Survivor 一半）。
- 常见陷阱：Survivor 空间过小，导致大量短命对象过早晋升，增加老年代压力。
- 面试提示：讲清楚“晋升失败”如何一步步触发 Full GC 的链条反应。
- 案例：高分配率服务增加 Survivor 空间后，老年代增长速率减缓 70%，Full GC 频率从每小时数次降至一天一次。
- 速记：Eden 出生，Survivor 考验，老年代养老；年龄或空间压力决定晋升。

### 1.3 老年代与空间压力 [5]
- 是什么：存放长寿命或直接晋升的大对象；回收成本高，频率低。
- 为什么：为长生命周期对象提供稳定存储，避免被频繁 Minor GC 扫描。
- 怎么用：监控 Old Gen 增长曲线；优化大 Map 缓存策略，使用软/弱引用。
- 关键细节：老年代碎片是 CMS 等非压缩收集器的痛点；并发标记周期决定回收触发时机。
- 常见陷阱：无限制的本地缓存（如 Guava Cache 未设上限）持续填满老年代。
- 面试提示：说明老年代持续上涨的几种可能原因（泄漏、缓存、晋升过快）及对应调优策略。
- 案例：通过分析堆 Dump，发现一个静态 `HashMap` 缓存了所有历史订单，改为 LRU 策略后老年代占用下降 90%。
- 速记：老年代是“养老院”，增长过快是警报；缓存、泄漏是主因。

### 1.4 TLAB (Thread Local Allocation Buffer) [4]
- 是什么：JVM 在 Eden 区为每条线程分配的私有缓冲区，用于分配小对象。
- 为什么：避免多线程分配对象时对堆内存加锁的开销，提升分配效率。
- 怎么用：默认开启，通常无需调整。通过 `-XX:+PrintTLAB` 可诊断 TLAB 分配情况。
- 关键细节：TLAB 用完或对象过大时，会走慢路径（CAS 或加锁）在共享 Eden 分配。
- 常见陷阱：误以为所有对象分配都是无锁的，忽略了 TLAB refill 和大对象分配的同步开销。
- 面试提示：能清晰说出“为什么多线程下小对象分配仍可近似无锁”，点出 TLAB 是关键。
- 案例：在性能分析中，若发现 `eden_alloc` 或类似锁竞争热点，可能是 TLAB 设置不当或小对象过多。
- 速记：线程私有分配区，小对象分配加速器，避免“抢地盘”。

### 1.5 元空间 (Metaspace) [4]
- 是什么：存储类元数据（方法、字段、常量池、字节码等）的本地内存区域。
- 为什么：摆脱永久代固定大小限制，与堆解耦，降低 OOM 风险。
- 怎么用：监控使用率；限制动态类生成；正确处理类卸载条件。
- 关键细节：类卸载需同时满足：无存活实例、其 ClassLoader 可被回收、无其他地方引用 Class 对象。
- 常见陷阱：动态代理（CGLIB/JDK Proxy）或 Groovy 等脚本语言滥用，生成大量无法卸载的类。
- 面试提示：最常见的泄漏原因是“自定义 ClassLoader 实例被长生命周期对象（如线程池、静态集合）强引用”。
- 案例：某热部署系统频繁 OOM，MAT 分析发现大量旧版本的 ClassLoader 实例被 Tomcat 的 `ThreadLocal` 引用，无法卸载。
- 速记：类的家，在本地内存；ClassLoader 泄漏是其头号杀手。

### 1.6 Java 栈与栈帧 [5]
- 是什么：每条线程私有，用于存储方法调用的栈帧（含局部变量表、操作数栈、动态链接等）。
- 为什么：实现函数调用、参数传递和局部变量隔离，保证线程安全。
- 怎么用：通过 `-Xss` 控制栈大小；防止无限递归导致 `StackOverflowError`。
- 关键细节：栈上数据线程私有，无需同步；栈帧大小在编译期基本确定。
- 常见陷阱：误认为栈越大越好，导致在相同内存下能创建的线程数减少。
- 面试提示：清晰区分 `StackOverflowError`（栈深度溢出）与 `OutOfMemoryError: unable to create new native thread`（无法创建新线程）。
- 案例：一个深度递归的 JSON 解析函数，在处理复杂结构时频繁抛出 `StackOverflowError`，后改为迭代实现解决。
- 速记：方法调用的“记事本”，线程私有；无限递归是其噩梦。

### 1.7 程序计数器 / 本地方法栈 [3]
- 是什么：PC 保存当前线程执行的字节码指令地址；本地方法栈服务于 JNI (Native) 调用。
- 为什么：PC 保证字节码解释与线程切换后能正确恢复；本地方法栈隔离 Java 与 Native 调用。
- 怎么用：一般无需用户干预或调参；但需关注过度 JNI 调用带来的性能和稳定性问题。
- 关键细节：PC 是唯一不会发生 `OutOfMemoryError` 的区域；本地方法栈错误可能直接导致 JVM 崩溃。
- 常见陷阱：忽略 JNI 调用也是潜在的内存泄漏源（Native Heap Leak）。
- 面试提示：能清晰说明为何 PC 是线程私有且不会 OOM。
- 案例：某图像处理服务使用 JNI 库，因 Native 代码内存未释放，导致进程 RSS 持续增长，最终被系统 OOM Killer 终止。
- 速记：PC=指令导航仪；本地方法栈=JNI 调用专用栈。

### 1.8 直接内存 (Off-heap) [4]
- 是什么：使用 `ByteBuffer.allocateDirect` 或 JNI 在 Java 堆外分配的内存。
- 为什么：减少 Java 堆与 Native 堆之间的数据复制，提升 I/O 性能（零拷贝）。
- 怎么用：用于 Netty、NIO 等高性能 I/O 场景；通过 `-XX:MaxDirectMemorySize` 控制上限。
- 关键细节：其回收依赖于 `Cleaner` (虚引用)，由 GC 触发，不及时；泄漏难于通过堆 Dump 发现。
- 常见陷阱：忘记手动释放（如 Netty 的 `ByteBuf.release()`），导致直接内存泄漏。
- 面试提示：清晰说明堆内 OOM 与直接内存 OOM 的排查路径差异（前者用 MAT，后者靠 `jcmd` 或 `NMT`）。
- 案例：一个 Netty 服务因未正确释放 `ByteBuf`，导致直接内存耗尽，抛出 `OutOfMemoryError: Direct buffer memory`。
- 速记：堆外高速公路，I/O 加速器；忘记释放是灾难。

### 1.9 对象头与布局 (Mark Word / Klass Pointer) [5]
- 是什么：每个对象都有一个头部，Mark Word 存储哈希码、GC 年龄、锁状态；Klass Pointer 指向其类元数据。
- 为什么：为对象提供运行时元信息，并作为 `synchronized` 锁机制的基础。
- 怎么用：通过 JOL (Java Object Layout) 工具查看对象实际布局；优化字段顺序可减少内存填充。
- 关键细节：64位系统默认开启压缩指针（-XX:+UseCompressedOops），节省内存；锁状态在 Mark Word 中迁移（无锁→偏向→轻量→重量）。
- 常见陷阱：在需要精确计算内存占用的场景，忽略了对象头和对齐填充的大小。
- 面试提示：能解释 `synchronized` 锁升级过程中，Mark Word 的内容是如何变化的。
- 案例：通过 JOL 分析发现某个常用对象因字段顺序不当，多出 8 字节的对齐填充，调整后节省了大量内存。
- 速记：对象的“身份证”，存着年龄、锁状态和类型指针。

### 1.10 四种引用类型 (强/软/弱/虚) [4]
- 是什么：控制对象可达性与回收时机。强引用：不回收；软引用：内存不足时回收；弱引用：下次 GC 时回收；虚引用：跟踪对象回收。
- 为什么：实现灵活的缓存策略和资源清理机制。
- 怎么用：软引用可用于实现内存敏感缓存；弱引用（`WeakHashMap`）用于元数据映射；虚引用与 `ReferenceQueue` 结合实现 `Cleaner`。
- 关键细节：软引用并不能完全替代 LRU 等缓存淘汰策略；虚引用的 `get()` 方法永远返回 `null`。
- 常见陷阱：过度依赖软/弱引用做缓存，导致性能抖动，因为回收时机不确定。
- 面试提示：清晰说明“仅有软/弱引用”的对象，在什么条件下会被回收。
- 案例：一个图片缓存系统使用软引用，在高负载下因内存压力频繁 GC，导致缓存命中率急剧下降，后改为固定大小的 LRU 缓存+磁盘二级缓存解决。
- 速记：强=永不放手；软=内存紧张时放手；弱=看见就放手；虚=放手后通知你。

### 1.11 指针压缩 (Compressed Oops) [3]
- 是什么：64 位 JVM 通过压缩对象指针（32 位偏移）访问堆，降低内存占用。
- 为什么：提升对象密度与缓存命中率，降低 GC 压力与停顿风险。
- 怎么用：通常默认开启；极大堆或诊断场景下评估开启/关闭差异。
- 关键细节：影响对象头与 Klass 指针（`UseCompressedClassPointers`）；对对象大小估算有影响。
- 常见陷阱：关闭压缩导致内存暴涨与尾延迟上升。
- 面试提示：解释“64 位并不总是更费内存”的原因。
- 案例：关闭压缩后 RSS 增长 40%，恢复压缩后 p99 下降。
- 速记：32 位指针驾驭 64 位堆，省内存。

### 1.12 Metaspace 调优与类卸载 [3]
- 是什么：类元数据存储在本地内存，需控制增长与卸载条件。
- 为什么：防止频繁 Full GC 触发类卸载尝试与内存膨胀。
- 怎么用：限制动态类生成；监控 `ClassUnload`；合理设置最大 metaspace；详见 1.5 元空间基础。
- 关键细节：类卸载需“无存活实例 + ClassLoader 可回收 + 无其它引用”。
- 常见陷阱：热部署保留旧 ClassLoader 强引用导致膨胀。
- 面试提示：能画出“卸载三条件”。
- 案例：清理线程池 ThreadLocal 对旧 ClassLoader 的引用后稳定。
- 速记：不卸载？优先查 ClassLoader。

### 1.13 TLAB 调优与诊断 [2]
- 是什么：线程私有分配缓冲区提升小对象分配效率，详见 1.4。
- 为什么：异常分配模式会带来慢路径锁竞争与 CAS 热点。
- 怎么用：`-XX:+PrintTLAB` 观察 refill 与浪费率；必要时调大小以降低慢路径比例。
- 关键细节：大对象绕过 TLAB；refill 频繁意味着共享 Eden 分配增多。
- 常见陷阱：将分配热点误归因于 GC。
- 面试提示：分配热点不等于 GC 热点；结合 JFR/alloc 事件分析。
- 案例：调大 TLAB 降低 CAS 热点，延迟下降。
- 速记：小对象走快道，别堵车。


---

## GC 基础与算法（拆分）

### 2.1 标记-清除算法 [4]
- 是什么：遍历可达对象标记，再清除未标记内存。
- 为什么：实现基本回收，避免复制整堆。
- 怎么用：老年代并发回收阶段使用；CMS 典型。
- 关键细节：产生碎片；需要后续压缩或碎片管理。
- 面试提示：指出碎片导致分配失败触发 Full GC。
- 常见陷阱：低估碎片影响，认为“只要还有空间”就安全；忽略大对象需要连续空间。
- 案例：CMS 老年代外部碎片导致无法为 8MB 大对象分配，触发一次 Full GC 后停顿飙升。
- 速记：标记+清除=快但碎片；连续空间差。 

### 2.2 标记-整理算法 [5]
- 是什么：标记后将存活对象向一端移动并整理空间。
- 为什么：消除碎片，支持大对象连续分配。
- 怎么用：老年代压缩阶段；Serial Old / CMS Full / G1 Mixed。
- 关键细节：对象移动需要更新引用；停顿时间较标记清除高。
- 面试提示：解释与复制算法的区别（跨区域 vs 整体）。
- 常见陷阱：忽视引用更新成本；在巨大堆上单次整理期望“极低暂停”不现实。
- 案例：一次 Full GC 标记整理移动大量长寿对象，暂停 2s，优化为 G1 混合回收后降至 300ms。
- 速记：整理=去碎片；成本：对象搬家。 

### 2.3 复制算法 [5]
- 是什么：将存活对象从 From 区复制到 To 区并清空原区。
- 为什么：分配指针重置，效率高。
- 怎么用：年轻代 Minor GC；Eden + Survivor。
- 关键细节：需预留未使用空间；高存活率降低效率。
- 面试提示：说明适用于“存活率低”的区域。
- 常见陷阱：Survivor 太小造成过度晋升；高存活期仍坚持过大年轻代导致复制成本高。
- 案例：年轻代存活率从 5% 升到 40%，Minor GC 耗时翻倍 → 调低新生代比例改善。
- 速记：低存活=复制快；高存活=成本飙。 

### 2.4 三色标记与并发安全 [4]
- 是什么：对象初始白色；扫描置灰；处理完成置黑；最终白色为不可达。
- 为什么：并发标记中避免漏标与误标。
- 怎么用：写屏障记录黑对象指向新白对象的变更；重标阶段修正。
- 关键细节：漂白问题通过 SATB（快照）或增量更新解决。
- 面试提示：讲 SATB 与增量更新差异（ZGC vs G1）。
- 常见陷阱：误把“黑对象永不再扫描”当绝对而忽略重新标记阶段；混淆 SATB 与增量更新触发条件。
- 案例：错误关闭 SATB 相关参数（试验版本）导致漏标，JVM 触发保护性崩溃。
- 速记：白→灰→黑；屏障防漏；两种补救策略。 

### 2.5 写屏障 / Remembered Set [5]
- 是什么：记录跨分代引用或并发标记时修改的指针。
- 为什么：减少全堆扫描，提高并发安全。
- 怎么用：分代制度下更新指针写 card；G1 使用 Remembered Set 维护跨 Region 引用。
- 关键细节：写屏障增加写成本；Remembered Set 过大影响性能。
- 面试提示：说明为什么“大量跨代引用”会拖慢 GC。
- 常见陷阱：忽视高更新率集合（如大型多线程 Map）写屏障放大成本；误删 RSet 导致不完整根集扫描。
- 案例：一个高写入缓存结构导致 RSet 膨胀，占用 15% 堆，调结构后下降至 3%。
- 速记：屏障=记变更；RSet 大=拖慢。 

### 2.6 分代回收策略 [5]
- 是什么：按对象生命周期分年轻与老年代。
- 为什么：降低扫描与复制成本，匹配对象生存曲线。
- 怎么用：调年轻比例；控制晋升速率；利用统计数据优化阈值。
- 关键细节：晋升失败导致 Full GC；动态年龄判断。
- 面试提示：解释为何不再仅仅是“两个区”而是细粒度 Region。
- 常见陷阱：将所有性能问题归因于“年轻代太小”单一视角；忽略晋升速率与分配爆发。
- 案例：通过调高年轻代比例降低老年代晋升压力，Full GC 从每小时 4 次降到 1 次。
- 速记：分代=匹配寿命；调比例看晋升。 

### 2.7 STW 与并发回收阶段 [4]
- 是什么：Stop-The-World 暂停所有应用线程执行 GC 阶段；并发阶段与应用并行执行。
- 为什么：保证内存结构一致性。
- 怎么用：G1/ZGC 尽量缩短 STW，扩大并发部分。
- 关键细节：Safepoint 到达时间影响总暂停；并发阶段可能回收不足引发补偿 GC。
- 面试提示：区分“并发”与“并行”回收。
- 常见陷阱：忽略 Safepoint 到达延迟只看 GC 日志暂停数字；并发阶段 CPU 紧张导致进度不足。
- 案例：压测中并发标记被业务线程抢占 CPU 导致后续补偿 GC，调整线程优先级后稳定。
- 速记：暂停=到达+执行；并发≠并行。 

### 2.8 Finalization 与 Cleaner [3]
- 是什么：finalize 过时且不可预测；Cleaner 使用虚引用回调释放资源。
- 为什么：避免 GC 次序不确定造成延迟释放。
- 怎么用：使用 try-with-resources 和 Cleaner 替代 finalize。
- 关键细节：finalize 队列延迟执行；可能复活对象。
- 面试提示：强调“不依赖 finalize 做关键资源释放”。
- 常见陷阱：在高频对象上残留 finalize 方法导致回收队列积压；复活逻辑引入隐藏泄漏。
- 案例：文件句柄类误用 finalize，峰值下 FDs 耗尽，引入显式 close + Cleaner 后恢复。
- 速记：finalize=不确定+可复活；Cleaner 更安全。 

### 2.9 Safepoint 与到达延迟 [4]
- 是什么：JVM 在安全点暂停执行以完成 GC/去优化等操作，线程需到达 safepoint 才能暂停。
- 为什么：解释“GC 暂停很短但应用体感卡顿较长”的到达延迟因素。
- 怎么用：减少长时间本地代码与无检查超长循环；监控 JFR 的 `Safepoint` 事件与到达时间统计。
- 关键细节：轮询点在方法调用、循环回边、异常检查；大量线程或 JNI 密集会拖慢到达。
- 常见陷阱：将总停顿完全归因于 GC 本身，忽略到达延迟。
- 面试提示：区分“GC 暂停时间”与“可感知停顿”。
- 案例：优化 JNI 图像处理批次粒度，Safepoint 到达从 300ms 降到 50ms。
- 速记：停顿两段式：到达→执行；到达慢=卡顿。

### 2.10 GC Roots 与可达性分析 [4]
- 是什么：以 GC Roots（栈、本地引用、静态等）为起点的可达性分析确定回收对象。
- 为什么：定位“为何对象没被回收”的根因。
- 怎么用：MAT/`jmap -histo` + 引用链分析查找保留路径；结合弱/软/虚引用规则。
- 关键细节：JNI 全局引用常见保留源；不同引用类型参与规则不同。
- 常见陷阱：只看对象大小不看引用链。
- 面试提示：能讲清一次泄漏的“保留路径”。
- 案例：静态缓存强引用导致配置对象常驻老年代。
- 速记：找链比看体积更重要。

---

## 垃圾收集器（逐个）

### 3.1 Serial / Serial Old [3]
- 是什么：单线程收集器；年轻代复制，老年代标记整理。
- 为什么：简单、适合小堆与单核环境。
- 怎么用：测试或微服务极小堆场景。
- 关键细节：停顿长；无并发能力；易预测。
- 面试提示：说明不适合生产大堆。
- 常见陷阱：无意识在大堆环境默认回退到 Serial（容器限核）；忽视停顿尖峰。
- 案例：1 核 512MB 服务使用 Serial GC 停顿 <50ms；迁移到 8GB 堆仍使用它导致 >2s 停顿。
- 速记：单核小堆可；大堆禁。 

### 3.2 Parallel Scavenge / Parallel Old [4]
- 是什么：多线程并行回收，吞吐优先。
- 为什么：批处理类应用追求最大吞吐。
- 怎么用：通过 -XX:MaxGCPauseMillis 尝试延迟控制但以吞吐为主；调整 -XX:ParallelGCThreads。
- 关键细节：停顿仍较长；不关注低延迟尾部。
- 面试提示：区分与 G1：无复杂 Region 模型。
- 常见陷阱：错误期望其达到“近实时”尾延迟；线程数与 CPU 绑定不当反而竞争。
- 案例：批量导入任务采用 Parallel GC 吞吐提升 20%，但 p99 延迟不适合在线请求场景。
- 速记：Parallel=吞吐王；尾延迟一般。 

### 3.3 CMS (已淘汰) [3]
- 是什么：并发标记清除，降低老年代停顿。
- 为什么：历史上的低暂停选择。
- 怎么用：新版本已被 G1/ZGC 取代。
- 关键细节：碎片风险；Concurrent Mode Failure → Full GC。
- 面试提示：说明弃用原因。
- 常见陷阱：继续在新 JDK 维持 CMS 参数导致不可预期行为；忽略碎片引发晋升失败。
- 案例：老系统升级后改用 G1，碎片相关 Full GC 消失，稳定性提升。
- 速记：CMS=旧低停顿+碎片；已退场。 

### 3.4 G1 (Garbage-First) [5]
- 是什么：Region 划分 + 年轻/混合回收 + 暂停预测模型。
- 为什么：在大堆获得相对可控停顿。
- 怎么用：设置 -XX:MaxGCPauseMillis；监控混合回收频率；优化 Humongous 对象。
- 关键细节：Remembered Set 开销；Humongous 分配跨 Region；并发标记 + Evacuation。
- 面试提示：解释暂停预测依据：历史统计 + 回收集大小估算。
- 常见陷阱：Pause 目标设过低频繁 Young GC；忽视 Humongous 导致 Region 被长占。
- 案例：调高 Pause 目标由 50ms→150ms，吞吐提升 12%，尾延迟持平。
- 速记：G1=Region+预测；目标别太激进。 

### 3.5 ZGC [5]
- 是什么：低停顿收集器：颜色指针 + 并发重定位。
- 为什么：超大堆 <~ TB 级低延迟。
- 怎么用：启用 -XX:+UseZGC；监控并发周期；关注引用修复开销。
- 关键细节：Load Barrier 更新指针；无长时间 STW；支持大对象。
- 面试提示：对比 G1：真正并发移动对象。
- 常见陷阱：期望“零暂停”；忽略屏障对峰值吞吐的影响；在小堆追求复杂性。
- 案例：堆 64GB 切换 Parallel→ZGC p99 从 600ms 降至 60ms，吞吐略降 5%。
- 速记：ZGC=并发迁移+低停顿；吞吐略换延迟。 

### 3.6 Shenandoah [4]
- 是什么：Brooks Pointer + 并发 Evacuation 实现低停顿。
- 为什么：低延迟堆回收选择，特别在 OpenJDK 社区。
- 怎么用：-XX:+UseShenandoahGC；监控并发阶段时间。
- 关键细节：指针转发；全堆并发 evacuation；吞吐略低。
- 面试提示：说明与 ZGC 的实现差异（颜色指针 vs Brooks Pointer）。
- 常见陷阱：与 ZGC 混用调参；忽视转发指针带来的读取额外开销。
- 案例：延迟敏感服务采用 Shenandoah p99 降低 50%，CPU 使用率上升 8%。
- 速记：Shenandoah=转发指针+低停顿。 

### 3.7 Epsilon (No-Op GC) [2]
- 是什么：不做回收，仅分配，堆用尽退出。
- 为什么：性能测试基线或极短生命周期应用。
- 怎么用：确保应用在堆耗尽前结束。
- 关键细节：无回收；仅适用于实验。
- 面试提示：指出不可用于生产。
- 常见陷阱：忘记在基准之外关闭 Epsilon；导致线上进程直接 OOM 退出。
- 案例：微基准使用 Epsilon 避免 GC 干扰对比不同算法纯计算性能。
- 速记：Epsilon=只分配不回收；实验用。 

### 3.8 收集器选择指南 [5]
- 是什么：基于堆大小、延迟目标、吞吐、版本成熟度选择策略。
- 为什么：避免错误选型造成不可达指标。
- 怎么用：延迟敏感大堆：ZGC；中大堆：G1；吞吐批处理：Parallel；试验低延迟：Shenandoah。
- 关键细节：版本兼容与监控成熟度。
- 面试提示：用场景映射具体选择。
- 常见陷阱：仅凭“社区讨论热度”选用；忽略硬件（核数/内存通道）对效果影响。
- 案例：电商系统从 Parallel 切换 G1，停顿降低但吞吐下降；根据 SLA 采样最终折中参数获平衡。
- 速记：选 GC=场景+目标+硬件。 

### 3.9 G1 关键旋钮与启发式 [4]
- 是什么：G1 通过暂停目标与区域收益选择回收集的启发式策略。
- 为什么：理解哪些参数影响选择，指导调优取舍。
- 怎么用：`-XX:MaxGCPauseMillis`、`-XX:InitiatingHeapOccupancyPercent`、`-XX:G1HeapRegionSize` 等参数协同调整。
- 关键细节：Humongous 对象与 RSet 开销决定回收收益；Mixed 周期节奏重要。
- 常见陷阱：盲目压低暂停目标导致频繁 GC、吞吐下降。
- 面试提示：清楚表达“降低尾延迟 vs 吞吐”的权衡。
- 案例：提高 IHOP 后减少并发标记频率，稳定延迟。
- 速记：暂停目标别太贪，收益要算。

### 3.10 ZGC 屏障类型与成本 [3]
- 是什么：Load/Store Barrier 保证并发重定位下指针正确，是 ZGC 低停顿的关键机制。
- 为什么：理解低停顿的代价来源与吞吐影响。
- 怎么用：观察 JFR 屏障事件；评估屏障开销对吞吐的影响，与业务目标匹配。
- 关键细节：颜色指针编码与跨线程指针修复。
- 常见陷阱：期待“零开销低停顿”。
- 面试提示：一句话对比 G1：ZGC 真并发迁移。
- 案例：吞吐略降但 p99 显著下降。
- 速记：屏障换低停顿。

### 3.11 String Deduplication（G1/ZGC）[3]
- 是什么：对相同内容的字符串共享后备数组降低老年代占用。
- 为什么：字符串重复常见，去重可显著降低占用。
- 怎么用：G1 `-XX:+UseStringDeduplication`；ZGC 根据版本支持策略。
- 关键细节：CPU 开销与对象寿命；与 `intern` 不同机制。
- 常见陷阱：高分配率服务盲目开启导致 CPU 抖动。
- 面试提示：收益高场景：重复常量/日志标签等。
- 案例：日志富文本服务开启后老年代下降 20%。
- 速记：重复字符串多→考虑去重。

---

## 类加载与模块化拆分

### 4.1 双亲委派模型 [5]
- 是什么：加载请求自下向上委派，先父再子。
- 为什么：避免核心类被篡改，保证一致性。
- 怎么用：自定义 ClassLoader 时保留委派逻辑；插件隔离打破委派需谨慎。
- 关键细节：findClass vs loadClass 区别；上下文 ClassLoader 解决 SPI。
- 面试提示：说明打破委派潜在安全风险。
- 常见陷阱：重写 loadClass 直接破坏委派导致核心类冲突；忽略线程上下文 ClassLoader 在 SPI 中的作用。
- 案例：插件系统未委派冲突替换 JDK 类引发 NoSuchMethodError。
- 速记：先父后子保安全；改委派慎重。 

### 4.2 ClassLoader 泄漏与卸载条件 [4]
- 是什么：ClassLoader 未被回收导致 Metaspace 增长。
- 为什么：影响内存与 GC 频率。
- 怎么用：清理静态缓存引用；弱引用持有临时类映射。
- 关键细节：实例、Class、本地缓存任何强引用都阻止卸载。
- 面试提示：描述典型“热部署”泄漏场景。
- 常见陷阱：线程池 ThreadLocal 引用旧 Loader；静态单例缓存类对象不释放。
- 案例：移除 ThreadLocal 中旧 Loader，类卸载事件出现，Metaspace 稳定。
- 速记：卸载要断引用；重点查 ThreadLocal/静态。 

### 4.3 JPMS 模块系统基础 [4]
- 是什么：module-info.java 声明依赖、导出、开放；模块路径与类路径分离。
- 为什么：强封装与显式依赖控制；减少类冲突。
- 怎么用：exports 暴露 API；opens 反射访问；uses/provides SPI。
- 关键细节：自动模块名冲突；未导出的包不可访问。
- 面试提示：说明与 OSGi 的主要差异：编译时强依赖图。
- 常见陷阱：误把 opens 当 exports；循环依赖与分包策略混乱拖慢启动。
- 案例：精简模块依赖图后 jar 数量减少，冷启动时间下降 25%。
- 速记：exports=访问；opens=反射；图要简洁。 

### 4.4 ServiceLoader 与 SPI [3]
- 是什么：基于配置文件提供服务实现动态发现。
- 为什么：低耦合扩展点。
- 怎么用：META-INF/services/ 接口全限定名列实现类。
- 关键细节：惰性迭代；线程安全实现需自行保证。
- 面试提示：指出缺点：不支持条件加载与版本选择。
- 常见陷阱：在热路径频繁遍历 ServiceLoader 重新创建实例；多个 ClassLoader 导致重复加载。
- 案例：缓存已解析服务列表后启动耗时减少 10%。
- 速记：简单 SPI；别频繁遍历。 

### 4.5 类初始化顺序与 <clinit> [2]
- 是什么：静态字段与静态块在 `<clinit>` 中初始化，首次使用触发。
- 为什么：影响冷启动时间与初始化依赖问题，可能引发阻塞或死锁。
- 怎么用：避免复杂静态初始化；分离懒加载与运行期初始化。
- 关键细节：类加载与初始化阶段区分；跨类静态依赖可能造成阻塞。
- 常见陷阱：链式静态初始化导致启动卡顿。
- 面试提示：能写出 `<clinit>` 的触发时机与典型风险。
- 案例：将重初始化迁移到启动后异步阶段，冷启动缩短。
- 速记：静态初始化要瘦身，别互相咬。

### 4.6 JPMS 启动图谱（进阶）[2]
- 是什么：模块依赖图影响类加载与启动路径与顺序。
- 为什么：复杂系统启动慢需定位瓶颈与解耦。
- 怎么用：结合 JFR 启动事件与阶段打点；优化模块拆分与导出/开放策略。
- 关键细节：自动模块名冲突；未导出包不可访问；循环依赖阻碍初始化。
- 常见陷阱：模块边界设计不当造成启动阻塞。
- 面试提示：简述模块对冷启动的影响与排查手段。
- 案例：裁剪模块后启动时间缩短 30%。
- 速记：模块瘦身，启动更快。

---

## JIT 与同步优化拆分

### 5.1 分层编译 (Tiered Compilation) [4]
- 是什么：C1 快速编译 + Profiling，C2 高级优化。
- 为什么：兼顾启动速度与峰值性能。
- 怎么用：默认开启；分析 -XX:+PrintCompilation 输出。
- 关键细节：OSR 进入已运行热循环；去优化重新进入解释模式。
- 面试提示：解释为什么冷启动期间性能较低。
- 常见陷阱：过早评估性能未完成热点提升；关闭分层编译导致冷启动更慢。
- 案例：压测显示 5 分钟后吞吐比启动初期提升 30%，确认分层编译效果。
- 速记：先快后优；热后再深优化。 

### 5.2 方法内联 (Inlining) [5]
- 是什么：将调用目标代码直接嵌入调用点。
- 为什么：去除调用开销，触发更多优化。
- 怎么用：减少过大方法与深层分支；避免多态调用阻碍内联。
- 关键细节：大小阈值与热度限制；Megamorphic 调用难内联。
- 面试提示：举“内联→常量传播→死代码删除”链条案例。
- 常见陷阱：过度追求“全部内联”导致方法体膨胀反而失去优化机会；忽略多态分派点。
- 案例：重构热点多态调用为静态分派后内联触发，延迟下降 15%。
- 速记：内联触发级联优化；多态是阻碍。 

### 5.3 逃逸分析与标量替换 [4]
- 是什么：对象未逃逸方法 → 拆为局部标量。
- 为什么：减少堆分配与 GC 压力。
- 怎么用：避免返回内部可变对象；减少共享。
- 关键细节：栈上分配未全面；优化受复杂控制流影响。
- 面试提示：区分概念与实际限制。
- 常见陷阱：期望所有小对象都栈上；反射/动态代理阻断优化却未意识。
- 案例：消除对可变对象的跨线程共享后触发锁消除与标量替换。
- 速记：不逃逸=可标量；复杂控制流会失效。 

### 5.4 锁消除与锁粗化 [3]
- 是什么：消除不可逃逸对象上的冗余锁；合并频繁小临界区。
- 为什么：减少同步开销或震荡。
- 怎么用：简化对象作用域；减少无必要同步。
- 关键细节：JIT 分析逃逸结果；粗化可能延长持锁。
- 面试提示：说明“性能不是简单加锁/减锁”的平衡。
- 常见陷阱：盲目手动扩大锁范围造成竞争；假设 JIT 一定能消除所有局部锁。
- 案例：移除热路径不必要的同步块后 CPU 利用率提升。
- 速记：锁可自动优化；写代码别过度同步。 

### 5.5 On-Stack Replacement (OSR) [3]
- 是什么：正在运行的热点循环在不中断方法的情况下切换到编译后版本。
- 为什么：减少等待整方法编译时间，提升长循环性能与冷启动体验。
- 怎么用：默认开启；通过 `-XX:+PrintCompilation` 或 JFR 观察 OSR 事件。
- 关键细节：去优化会回退解释模式；与分层编译协同工作。
- 常见陷阱：误以为整方法已全面优化。
- 面试提示：解释冷启动慢与“越跑越快”的原因。
- 案例：批处理长循环 CPU 利用率随时间上升。
- 速记：热循环即时换挡。

### 5.6 逃逸分析局限与期待 [3]
- 是什么：分析对象是否逃逸以做栈上分配与锁消除，详见 5.3。
- 为什么：理解为何“并非所有新对象都能栈上”，合理预期优化效果。
- 怎么用：减少共享与返回内部可变对象；配合 JIT 打通优化链。
- 关键细节：复杂控制流/反射/多态阻碍优化；不同版本效果有差异。
- 常见陷阱：过度依赖理论上的栈上分配。
- 面试提示：面向场景谈收益，不承诺绝对。
- 案例：重构去共享后锁消除触发，延迟下降。
- 速记：不共享更容易优化。

---

## 内存与对象优化拆分

### 6.1 装箱与拆箱成本 [4]
- 是什么：基本类型与包装类型转换产生临时对象。
- 为什么：多余对象增加 GC。
- 怎么用：使用原始类型集合（TIntArrayList 等第三方）或基本数组。
- 关键细节：Integer 缓存 [-128,127]；频繁自动装箱隐藏分配。
- 面试提示：指出在热路径日志拼接的装箱问题。
- 常见陷阱：在 Stream/集合频繁使用包装类型比较导致额外装箱；忽略装箱引入的 equals 成本。
- 案例：替换包装类型集合为原始数组 Allocation Rate 下降 25%。
- 速记：少装箱=少对象=少 GC。 

### 6.2 字符串处理优化 [4]
- 是什么：避免多次拼接创建临时对象。
- 为什么：降低 Allocation Rate。
- 怎么用：StringBuilder / format 缓存；减少 substring 大对象保留（JDK8 起独立数组）。
- 关键细节：intern 过度使用常量池膨胀。
- 面试提示：说明为什么循环中 + 拼接低效。
- 常见陷阱：在热循环里使用 String.format；错误滥用 intern 导致常量池压力。
- 案例：替换 format 为复用 StringBuilder 后吞吐提升 10%。
- 速记：热路径用 Builder；format 慢。 

### 6.3 缓存与容量控制 [5]
- 是什么：对象留存老年代影响回收。
- 为什么：防止内存膨胀与 Full GC。
- 怎么用：LRU / LFU / 计时淘汰；软引用结合显式限制。
- 关键细节：仅软引用不可控；统计命中率评估价值。
- 面试提示：讲一个“缓存上限 + 命中率”调优案例。
- 常见陷阱：无上限缓存导致老年代线性增长；软引用缓存随内存压力抖动命中率。
- 案例：加上最大条目与 TTL 后 Full GC 频率大幅降低。
- 速记：缓存要上限+度量；别信任软引用单独。 

### 6.4 数据结构选择 (ArrayList vs LinkedList) [4]
- 是什么：不同存储布局特性。
- 为什么：局部性与随机访问性能差异。
- 怎么用：首选 ArrayList，多插入中间仍评估成本；避免 LinkedList 在随机访问路径。
- 关键细节：LinkedList 节点对象开销；迭代器失效风险低但访问慢。
- 面试提示：纠正“链表插入 O(1)”误区（定位成本）。
- 常见陷阱：误将 LinkedList 用于频繁索引访问；忽略 GC 压力（节点多）。
- 案例：将 LinkedList 改为 ArrayList 后 CPU Cache Miss 降低，响应时间改善。
- 速记：访问多用数组结构；链表少用。 

---

## 性能工具与监控拆分

### 7.1 JFR (Java Flight Recorder) [5]
- 是什么：低开销事件采集框架。
- 为什么：生产可用持续监控。
- 怎么用：开启 profile / continuous 模式；分析事件：GC、线程、锁、分配。
- 关键细节：开销极低 <1%；与 Mission Control 配合。
- 面试提示：说明优于频繁堆 dump 的原因。
- 常见陷阱：仅在故障后临时开启导致缺乏基线；忽视事件配置粒度。
- 案例：持续 JFR 记录帮助回溯一次尾延迟激增源于锁膨胀。
- 速记：JFR=低开销时间线；常开得基线。 

### 7.2 async-profiler 火焰图 [5]
- 是什么：采样 CPU / alloc / lock / wall / perf events。
- 为什么：快速热点定位。
- 怎么用：命令行触发 → 生成 svg；区分 on-cpu 与 off-cpu。
- 关键细节：采样避免安全点偏差；结合 JFR 互证。
- 面试提示：解释采样不等于精确时间线。
- 常见陷阱：误读阻塞等待为 CPU 计算；仅看顶层不下钻栈帧导致误判。
- 案例：发现大量 off-cpu 时间源于数据库连接等待而非计算。
- 速记：火焰图找热点；交叉验证来源。 

### 7.3 Arthas 在线诊断 [4]
- 是什么：运行时附加工具：trace、watch、jad、tt。
- 为什么：无需重启快速定位方法行为。
- 怎么用：tt 回放调用；trace 方法耗时链路。
- 关键细节：慎用高频 trace；生产安全策略。
- 面试提示：举一次实际故障排查流程。
- 常见陷阱：长时间开启高频 trace 影响性能；未控制访问权限。
- 案例：使用 trace 快速定位一个异常分支导致的性能回退。
- 速记：Arthas=在线透视；控制频率。 

### 7.4 GC 日志分析 [5]
- 是什么：结构化日志展示各阶段耗时与内存变化。
- 为什么：调优依据。
- 怎么用：-Xlog:gc* 收集；分类 Minor/Mixed/Full；计算晋升率。
- 关键细节：关注 Young 回收效率与老年代增长速度。
- 面试提示：展示“暂停时间与分配率相关性”分析。
- 常见陷阱：只看总暂停忽略次数；忽略晋升失败前兆（老年代加速增长）。
- 案例：通过日志发现晋升率异常 → 调整 Survivor 大小降低 Full GC。
- 速记：看频率+趋势；不只看单次。 

### 7.5 关键监控指标体系 [5]
- 是什么：堆使用、Allocation Rate、GC Pause、CPU、线程数、锁等待、对象泄漏趋势。
- 为什么：持续预警容量与性能风险。
- 怎么用：分层仪表板；阈值告警；历史趋势。
- 关键细节：尾延迟与 GC/锁等待交叉分析。
- 面试提示：说明为什么仅看平均值不够。
- 常见陷阱：指标孤立观察；过度关注平均值忽略分位数。
- 案例：引入 p99 监控后发现少量慢请求源自锁竞争。
- 速记：指标要关联+分位数。 

### 7.6 Native Memory Tracking (NMT) [3]
- 是什么：JVM 原生内存使用分组统计工具，用于堆外内存排查。
- 为什么：定位 RSS 增长来源（直接内存、元空间、线程栈等）。
- 怎么用：`-XX:NativeMemoryTracking=summary|detail` + `jcmd VM.native_memory` 查看。
- 关键细节：有开销，生产建议 summary；与堆 Dump 维度不同。
- 常见陷阱：只看堆，忽略堆外增长。
- 面试提示：描述堆外 OOM 的排查路径。
- 案例：detail 模式定位 Thread Stack 过大导致 RSS 撑爆。
- 速记：堆外看 NMT，堆内看 MAT。

### 7.7 JIT 日志与性能剖析 [3]
- 是什么：`-XX:+PrintCompilation`/`-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly` 等输出与 JFR 事件。
- 为什么：定位内联、去优化、热点路径与优化机会。
- 怎么用：开发/诊断环境收集详细日志；生产使用 JFR 低开销事件替代。
- 关键细节：日志体量大需过滤；与 async-profiler 火焰图交叉验证热点。
- 常见陷阱：单靠汇编输出做结论。
- 面试提示：知道工具与用途，不必死记参数。
- 案例：通过日志发现 Megamorphic 调用阻碍内联，改静态分派提速。
- 速记：JIT 看热度，火焰图看热点。

### 7.8 JVMTI/Instrumentation 基础 [2]
- 是什么：JVM 工具接口与字节码插桩机制，用于在线诊断/APM/覆盖率。
- 为什么：在不重启的前提下观察与修改运行时行为。
- 怎么用：agent 在启动或运行时附加；使用 ClassFileTransformer 插桩。
- 关键细节：性能开销与安全策略；类重定义限制。
- 常见陷阱：生产环境无节制插桩造成性能问题。
- 面试提示：知道“agent”的角色即可，避免细节泛滥。
- 案例：仅在排障窗口临时附加诊断 agent。
- 速记：诊断靠 agent，慎用。

---

## 延迟与吞吐拆分

### 8.1 延迟优化策略 [4]
- 是什么：减少单请求响应时间。
- 为什么：提升用户体验与 SLA。
- 怎么用：缩短临界区；减少大批量操作；使用低停顿 GC。
- 关键细节：p95/p99 监控；避免锁争用与长 GC。
- 面试提示：说明延迟与对象风暴关系。
- 常见陷阱：盲目微调 GC 参数忽略业务批量操作；只看平均延迟忽略高分位。
- 案例：拆分批量写入为小批次后 p99 降低 40%。
- 速记：延迟=锁+GC+批量控制。 

### 8.2 吞吐优化策略 [4]
- 是什么：单位时间处理更多任务。
- 为什么：提升总体产出。
- 怎么用：批处理合并；扩大并行度；Parallel GC 或适度 G1 调优。
- 关键细节：可能牺牲尾延迟；批量大小与内存峰值权衡。
- 面试提示：给出吞吐优化副作用示例。
- 常见陷阱：过度批处理导致高峰内存爆；并行度提升忽略锁/IO 瓶颈。
- 案例：调优批处理大小与线程池后总吞吐提升 25%。
- 速记：吞吐靠批+并行；警惕尾延迟。 

---

## 常见性能陷阱拆分

### 9.1 反射与动态代理过度使用 [4]
- 是什么：Method.invoke / CGLIB 频繁出现在热路径。
- 为什么：阻断内联与类型分析。
- 怎么用：缓存 MethodHandle；代码生成静态绑定。
- 关键细节：代理链过深；开销累积。
- 面试提示：提供“代理链裁剪”收益数据。
- 常见陷阱：层层代理叠加 AOP 导致栈深与性能劣化；忽略 MethodHandle 可替代。
- 案例：裁剪 5 层代理到 2 层后 CPU 降 10%。
- 速记：少代理+缓存句柄。 

### 9.2 原生序列化与安全风险 [3]
- 是什么：ObjectInputStream 可执行 gadget 链。
- 为什么：性能差 + 安全隐患。
- 怎么用：替换为 JSON / ProtoBuf；白名单类。
- 关键细节：serialVersionUID 兼容困难。
- 面试提示：说明为何不推荐生产使用默认序列化。
- 常见陷阱：跨版本对象反序列化失败；未做黑/白名单引入漏洞。
- 案例：改用 ProtoBuf 后序列化时间下降 60%。
- 速记：原生慢+不安全；换协议。 

---

## GC 诊断与案例拆分

### 10.1 老年代持续增长问题定位 [5]
- 是什么：缓存滥用或长寿对象滞留。
- 为什么：增加 Full GC 风险。
- 怎么用：堆直方图、引用链、对象保留大小分析。
- 关键细节：Weak/Soft 缓存策略不当；大集合未清理。
- 面试提示：讲清一个解决故事。
- 常见陷阱：只看活动堆大小不做引用链；误判为“GC 不工作”。
- 案例：定位静态 Map 未淘汰后加 LRU，老年代稳定。
- 速记：增长=查缓存+链路。 

### 10.2 Humongous 对象频发 [4]
- 是什么：超阈值大对象跨 Region 分配。
- 为什么：影响 G1 回收效率。
- 怎么用：分块存储；压缩结构；池化。
- 关键细节：不参与常规回收；可能导致碎片。
- 面试提示：说明“为什么减少尺寸分片可降低停顿”。
- 常见陷阱：日志或批量缓冲巨型数组未切分；忽视 Humongous 触发 Mixed 回收延迟。
- 案例：拆分 20MB 数组为分片后 G1 Mixed 回收次数减少。
- 速记：巨大对象少用；能分片就分。 

---

## 启动与预热拆分

### 11.1 CDS / AppCDS [3]
- 是什么：类元数据归档提前加载。
- 为什么：减少启动 I/O 与解析。
- 怎么用：生成归档 → 启动参数加载。
- 关键细节：依赖类路径一致；修改需重新生成。
- 面试提示：区别标准 CDS 与应用归档。
- 常见陷阱：变更类路径未重新生成归档导致失效；过度期待对运行期性能提升。
- 案例：启用 AppCDS 冷启动缩短 12%。
- 速记：CDS=预热元数据；路径变需重建。 

### 11.2 JIT 预热策略 [3]
- 是什么：模拟负载使热点编译完成。
- 为什么：缩短达到峰值性能时间。
- 怎么用：压测脚本启动前跑预热阶段。
- 关键细节：避免真实数据污染缓存。
- 面试提示：说明预热与生产冷启动差异。
- 常见陷阱：预热负载与生产差异过大导致误判；忽视缓存层差异。
- 案例：预热阶段完成后峰值 QPS 更快达到稳定。
- 速记：预热=提前编译；负载要相似。 

---

## FFI 与 Native 拆分

### 12.1 JNI 调用开销管理 [2]
- 是什么：Java ↔ C/C++ 边界切换。
- 为什么：高频切换影响性能。
- 怎么用：批量处理；缓存指针；最小跨界次数。
- 关键细节：异常处理复杂；安全风险。
- 面试提示：说明避免微粒度 JNI 调用。
- 常见陷阱：在循环中单条 JNI 调用造成频繁栈切换；忽略释放本地资源。
- 案例：合并多次 JNI 调用为批处理后 CPU 使用率下降。
- 速记：JNI 少切换；批量合并。 

### 12.2 Panama 外部内存访问 [2]
- 是什么：MemorySegment + Linker 提供安全高性能跨语言。
- 为什么：减少手工 JNI 样板。
- 怎么用：声明内存段；函数符号绑定。
- 关键细节：生命周期管理；还在演进。
- 面试提示：预测未来替代部分 JNI。
- 常见陷阱：忽视内存段关闭时机；直接与旧 API 混用造成困惑。
- 案例：试验性替换部分 JNI 调用后代码量降低。
- 速记：Panama=更安全跨界；注意生命周期。 

---

## 性能测试拆分

### 13.1 JMH 微基准框架 [4]
- 是什么：防止虚假优化的标准工具。
- 为什么：精确测局部变更收益。
- 怎么用：@Benchmark + Warmup/Fork/Measurement。
- 关键细节：黑洞防死代码；独立进程 fork 防 JIT 污染。
- 面试提示：强调与集成压测的区别。
- 常见陷阱：错误使用基准结果评估整体系统表现；忽略 JVM 预热阶段。
- 案例：使用多 fork 设置避免一次性结果抖动。
- 速记：JMH=局部精测；不可替系统压测。 

### 13.2 压测与真实流量回放 [4]
- 是什么：模拟生产并发 / 数据分布。
- 为什么：验证系统整体行为与容量。
- 怎么用：录制生产请求 → 回放；区分预热与测量阶段。
- 关键细节：环境隔离；速率与并发分层。
- 面试提示：说明只用微基准的风险。
- 常见陷阱：测试环境与生产配置差异过大；未控制背景噪声导致结果失真。
- 案例：流量回放发现缓存雪崩场景，提前加熔断策略。
- 速记：压测=场景复刻+隔离。 

---

## 调优流程与实践拆分

### 14.1 数据驱动调优流水线 [5]
- 是什么：目标→基线→定位→改动→验证→回滚。
- 为什么：减少盲目修改与回归风险。
- 怎么用：建立基线报表；单变量改动；记录差异。
- 关键细节：先算法后参数；避免同时多改动。
- 面试提示：复述并强调可回滚性。
- 常见陷阱：跳过基线阶段直接修改参数；一次性多改动无法归因。
- 案例：严格执行单变量调整成功定位 GC 暂停来源。
- 速记：调优=基线+单改+可回滚。 

### 14.2 关键指标关联分析 [4]
- 是什么：将 GC、锁、CPU、延迟、分配率关联。
- 为什么：识别根因与连锁效应。
- 怎么用：时间线叠加；事件→指标跳转。
- 关键细节：锁等待拉高 + GC 增加 = 双重延迟源。
- 面试提示：举一个多因素共振案例。
- 常见陷阱：孤立看单指标做错误决策；忽略时间相关性。
- 案例：关联分析发现高分配率与锁竞争共同驱动尾延迟尖峰。
- 速记：指标互联找共振根因。 


## 重要度汇总（更新）
- 堆/分代/TLAB/对象头/GC 算法/收集器选择/GC 日志/调优流程/工具栈/监控指标/Concurrent GC 原理：[5]
- 老年代压力/Humongous/内联/复制/写屏障/三色标记/缓存策略/性能工具/延迟与吞吐/数据结构选择/JMH/压测：[4]
- 元空间/逃逸分析/锁消除/反射陷阱/直接内存/启动预热/Safepoint/JIT 分层/引用类型/并发标记细节：[3]
- JNI/Panama/CDS/ServiceLoader/SP 模块细节/Epsilon 收集器：[2]


## 常见面试延伸问答示例
1. 为什么对象要分年轻代与老年代？生命周期分布差异降低扫描与复制成本。  
2. G1 如何达到暂停预测？基于 Region 统计与目标暂停时间选择回收集合。  
3. ZGC 与 G1 的核心差异？ZGC 使用颜色指针 + 并发重定位，停顿更低；G1 Region + 混合回收。  
4. 什么是 Humongous 对象？在 G1 中超过 Region 大小阈值（>50% 一个 Region 或多个连续 Region）的大对象特殊处理。  
5. 为什么频繁 Full GC？晋升失败、老年代满、大对象分配失败或元空间不足。  
6. 如何判断是否存在类元数据泄漏？Metaspace 持续增长且类卸载数低，ClassLoader 保持强引用。  
7. 为什么内联提高性能？减少调用开销并触发更多优化（常量折叠、循环优化）。  
8. 什么是逃逸分析的实际收益？锁消除与标量替换减少同步与对象分配。  
9. 为什么反射影响 JIT？阻碍内联与类型稳定分析。  
10. Allocation Rate 高应做什么？减少临时对象、复用缓冲、调整数据结构。  
11. 如何快速定位老年代膨胀？堆直方图 + 引用链分析 + 对象保留大小评估。  
12. 使用 Parallel 收集器的风险？停顿时间长，尾延迟较高。  
13. G1 Pause 目标调得过低结果？频繁 Young GC / Mixed GC，吞吐下降。  
14. 为什么说平均延迟不可靠？掩盖 p95/p99 尾部高延迟真实用户体验。  
15. SafePoint 造成长停顿的常见原因？大量线程或长时间执行本地代码阻止快速到达。  
16. 为什么要固定 -Xms 与 -Xmx？避免堆动态扩缩造成额外暂停与碎片。  
17. 哪些场景适合直接内存？高频 I/O、零拷贝传输；不适合大量小对象分配。  
18. 原生序列化不推荐原因？性能差、版本兼容脆弱、安全风险。  
19. 如何验证一次性能优化有效？对比基线指标（延迟、吞吐、GC）并做回归测试。  
20. JFR 与 async-profiler 组合优势？JFR 全局低开销事件，async-profiler 精确热点火焰图。  
21. 为什么替换 LinkedList 为 ArrayList 多数更优？连续内存提升局部性与缓存命中，降低指针追逐。  
22. 什么是 Card Table？记录跨代引用的脏卡，减少全堆扫描范围。  
23. 为什么 metaspace 溢出会触发 Full GC？尝试回收卸载类腾出元空间。  
24. 什么时候应考虑 ZGC？堆很大（数十 GB+）且延迟敏感。  
25. 锁消除条件是什么？对象与锁未逃逸出方法或线程上下文。  

(完)